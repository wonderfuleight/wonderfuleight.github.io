<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Blockchain And Hyperledger Fabric</title>
      <link href="2020/12/30/Blockchain-And-Hyperledger-Fabric/"/>
      <url>2020/12/30/Blockchain-And-Hyperledger-Fabric/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230164142.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230164142.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230164140752"></p><h2 id="一、Bitcoin"><a href="#一、Bitcoin" class="headerlink" title="一、Bitcoin"></a>一、Bitcoin</h2><h4 id="1-1-现实中的-Bitcoin-到底是什么样"><a href="#1-1-现实中的-Bitcoin-到底是什么样" class="headerlink" title="1.1 现实中的 Bitcoin 到底是什么样"></a>1.1 现实中的 Bitcoin 到底是什么样</h4><p><a href="https://www.blockchain.com/">https://www.blockchain.com/</a></p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145003.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145003.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229144948657" style="zoom:200%;" /><h4 id="1-2-区块链技术的诞生"><a href="#1-2-区块链技术的诞生" class="headerlink" title="1.2 区块链技术的诞生"></a>1.2 区块链技术的诞生</h4><p>中心化：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145724.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229145722222"></p><p>去中心化：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145849.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229145849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229145847830"></p><blockquote><p>存在问题：</p><ul><li>先付钱，没发货</li><li>先发货，没付钱</li></ul></blockquote><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229170546.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229170546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229170544585"></p><blockquote><p>存在问题：</p><ul><li>此时，随便一个人捏造一个数据</li></ul></blockquote><p><code>简单的区块链模型</code></p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229170602.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201229170602.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229170600972"></p><h4 id="1-3-在货币网络中可能的攻击方法"><a href="#1-3-在货币网络中可能的攻击方法" class="headerlink" title="1.3 在货币网络中可能的攻击方法"></a>1.3 在货币网络中可能的攻击方法</h4><ol><li>偷比特币。王一有没有可能去其他用户的比特币呢？譬如王一创建了一个区块，区块中她试图伪造一个交易 <code>“王二 -----&gt; 王一：100BTC”</code>。如果要让这个交易合法，那么王一必须能够伪造王二的签名，但是王一如果没有王二的私钥，那么王一就不能伪造签名。所以，只要底层的密码学基础没有被破坏，王一就不可能偷王二的币。</li></ol><img src="../../../Library/Application Support/typora-user-images/image-20201229173410323.png" class="lazyload" data-srcset="../../../Library/Application Support/typora-user-images/image-20201229173410323.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201229173410323" style="zoom: 50%;" /><ol start="2"><li><p>拒绝服务。如果王一非常讨厌王二，她不愿意为王二提供服务，譬如在自己创建的区块中，王一就会故意忽略掉王二相关的交易。这个攻击的问题是，王一并不能控制区块的产生。即使王一在一个区块中忽略了王二的交易，其他诚实的节点会在交易中包括王二的交易。</p></li><li><p>双重支付。假如王二从王三那里买了东西，现在王二要支付比特币给王三，然后王二广播了一条交易 <code>&quot;王二 -----&gt; 王三 ： 50 BTC&quot;</code> ，诚实的节点看到了这条交易，并且将交易包含在区块中。当王三看到这条交易被包括进去的时候，王三认为王二已经支付了，所以将东西发送给了王二。然后王二开始准备攻击，她自己或者她控制的节点开始准备下一个区块，在这个区块中包含的消息是把王二刚才付给王三的币付给自己或者她控制的账号<code>&quot;王二 -----&gt; 王二 ： 50 BTC&quot;</code>。如果王二能够给成功地将第二条支付信息包含在区块链中，那么第一条消息，将会被忽视，就像从来没有出现过一样。</p></li></ol><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230082056.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230082056.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230082055380"></p><p>那么王三如何应对这个问题呢？</p><p>一个字形容就是：==等== </p><p>如果王三容易轻信，那么他可能在发现王二发布了付币给自己的时候就同意将东西发给王二，这个时候，称作 Zero-Confirmation Transaction（零确认交易）。如果王三有更多的保护自己的意识，他会等到王二付钱给自己的交易被多次确认之后才将软件发给王二。当交易被包含在区块中，称作一次确认；如果包含交易的区块之后又来了一个区块，称作2次确认。以此类推。</p><p>只要王三等足够的时间，那么当他发现包含王二付钱给自己的区块已经被遗弃的时候，他会放弃这次交易并且拒绝将东西发给王二。一般而言，一个交易获得的确认越多，这个交易成为最终的系统的共识的概率越大。</p><p>能够防止双重支付成功的原因，也即，包括双重支付的区块不能最终包括在链中的原因是我们假设大部分的节点是诚实的。</p><h4 id="1-4-矿工怎么挖矿"><a href="#1-4-矿工怎么挖矿" class="headerlink" title="1.4 矿工怎么挖矿"></a>1.4 矿工怎么挖矿</h4><p>在之前的过程中，我们多次做了假设，大部分的节点是诚实节点——诚实的节点会将自己收到的广播的交易打包，诚实的节点会沿着最长的分支扩展。</p><p>诚实节点到底是为什么是诚实的？一个字：==钱==</p><p>在比特币网络中，共有两个激励方式：</p><ul><li>Block reward（区块奖励）</li><li>Transaction fees（交易费用）</li></ul><p><code>区块奖励：</code> 任何创造出区块的节点可以在区块中包括一个特殊的交易——创造币的交易</p><p>创造一个区块的奖励是25个币，然后每210,000个区块这个数字会减半。</p><p>第一眼看来，这个好像没什么用处。因为，不管节点创造的是好的区块还是包括攻击交易的区块，他都能获得奖励。但是，这个奖励什么时候才有用呢？只有在他的区块被包括在长链中才行。因此，如果一个区块中包括无效的交易，这个区块相当于会被丢弃。所以，所有的节点都能尽力表现得诚实，这样，其他节点才会沿着他的区块继续添加新的区块。</p><p><code>交易费用:</code> 交易的创建者可以在创建交易时，输入大于输出，其中的差值就是交易费用。</p><p>Q：创造很多的节点以获得奖励？</p><p>A：挑选节点的时候，要根据一种人们不能独占的资源来选择：==算力==</p><p>比特币的工作证明就是hash puzzles。为了创建一个区块，节点需要能够找到一个数值：nonce，使得当计算哈希时，前一个hash，包含在区块中的交易，以及 nonce 这三者连接之后，它的哈希值小于某个 target。</p><p><img src="https://pic4.zhimg.com/80/v2-e1ac4c723bc354813dc650a848f94587_1440w.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-e1ac4c723bc354813dc650a848f94587_1440w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>找到这个Nonce的唯一方法就是尝试各种值，直到运气好找到一个</p></li><li><p>产生一个区块需要的计算大概是 10^20^ 次哈希</p></li><li><p>难度可调节。每2016个块，所有的节点一起参与计算，重新定义 target</p></li></ul><p><img src="https://www.abmedia.io/wp-content/uploads/2020/06/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2020-06-11-%E4%B8%8B%E5%8D%8812.54.21-%E4%B8%8B%E5%8D%88-1536x884.png" class="lazyload" data-srcset="https://www.abmedia.io/wp-content/uploads/2020/06/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2020-06-11-%E4%B8%8B%E5%8D%8812.54.21-%E4%B8%8B%E5%8D%88-1536x884.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><a href="https://www.huxiu.com/article/311309.html">比特币分叉往事</a></p><h4 id="1-5-真实的区块链"><a href="#1-5-真实的区块链" class="headerlink" title="1.5 真实的区块链"></a>1.5 真实的区块链</h4><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230104433.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230104433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230104431936"></p><p>在区块链中，多个交易是被打包到一个区块中。使用包含多个交易区块而不是单个交易作为共识的单位，主要的目的是优化，因为如果矿工是针对每个交易而不是多个交易一起进行共识，那么效率就太低了。</p><p><code>    父区块</code></p><p>由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。这将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。</p><p><code>Merkle树</code></p><p>区块中的所有交易都使用二进制 ==raw transaction== 的格式保存在区块中，然后对 raw transaction 进行哈希得到交易id（txid）。merkle 树就是使用这样的 txid 进行构造的。</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230110647.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230110647.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230110646057"></p><p>为什么使用 Merkle树？</p><p>默认情况下，一旦接受到一个新交易，节点需要验证它，特别是，验证交易的输入中的每一个之前是否被花费。为了完成这个验证，需要访问区块链。如果节点不信任网络上的其他节点，那么 这个节点需要保存网络上的所有区块，以便验证交易。这种节点称作全节点。在比特币发展的早期，所有节点都是全节点；当前的比特币核心客户端也是完整区块链节点。</p><p>因为全验证节点会维护整个区块链的数据，由于区块链的不可篡改和append-only，随着时间的增加，整个区块链的数据量非常大。现在要完整下载比特币的所有区块数据，需要200GB以上的空间。</p><p>全验证节点对硬件提出了很高要求，个人用户（移动设备）参与这个过程几乎是不可能的。为了客户友好，对于仅仅使用钱包的普通用户，也即轻量级的节点，比特币网络中的大部分用户都是轻量级的用户，比特币网络并不要求它们也存储所有的信息。这种节点只需要维护能够验证用户自己所 care 的交易的部分信息就行了。这也是中本聪在比特币白皮书中所提出的SPV（simple payment verification）的概念。SPV可以不需整个网络的数据而确认交易是否存在。</p><p>轻量级节点往往只需要存储区块链头部就可以了。使用有限的信息，轻节点就能够证明某一笔交易是否存在与区块链中。区块头是80字节，一个区块至少是1M，完整交易的区块比区块头的要大的多。因为区块头部信息很少，每年的增加总量大概是在5M左右，所以简单的硬件设备也完全可以运行。</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230112812.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230112812.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230112809718"></p><p>我们来使用分布式文件服务器做例子。如果两个服务器A和B都是对某个文件系统的冗余备份。现在希望A和B通信来确认一下，它们所保存的文件是一致的。如果不使用哈希，那么这个通信代价是整个的文件系统，需要把所有的文件都传递到一个进行比较的服务器上，然后进行字符串比较。这无疑是非常低效的。比较哈希当然是一个好方法。因为哈希的单向性和固定的输出长度，所以通信代价就大大降低了。那么为什么要用一棵树呢？</p><p>如果A和B两个服务器上存储的文件系统都是一致的，也即两个的哈希值是一样的，那么自然是很好的。如果两个不一致呢？譬如说A服务器上有一个文件更新了，而B服务器还没有来得及更新。怎么样能够快速地定位到导致两个文件系统不一致的文件？</p><p>这时就能体现树结构的好处了。如果两个哈希值不一致，A服务器就可以向B服务器要两个子节点的哈希值；然后沿着不一样的路径一直走下去，从而可以确定导致根哈希值不同的文件。</p><h4 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h4><p><code>去中心化</code></p><p>整个服务没有中心，意味着整个服务无需访问第三方机构，达成共识后，可以直接点对点的对接，具有一定的公平、公开的特点。但对外界来说，整个服务中的每个参与节点都是“中心”，同时也构成了一个“中心”。</p><p><code>防篡改</code></p><p>已存储的区块防止被非法修改，整个提交过程中，既要防止请求被篡改，也要防止非法消息的提交。</p><p><code>可追溯</code></p><p>依靠区块链的链式存储结构，每一次提交区块都是顺序执行。因此可以通过链式结构追溯到任意一次提交的信息。</p><h2 id="二、Hyperledger-Fabric"><a href="#二、Hyperledger-Fabric" class="headerlink" title="二、Hyperledger Fabric"></a>二、Hyperledger Fabric</h2><h4 id="2-1-区块链-1-0-VS-区块链-2-0"><a href="#2-1-区块链-1-0-VS-区块链-2-0" class="headerlink" title="2.1 区块链 1.0 VS 区块链 2.0"></a>2.1 区块链 1.0 VS 区块链 2.0</h4><table><thead><tr><th></th><th>区块链 1.0</th><th>区块链 2.0</th></tr></thead><tbody><tr><td>代表</td><td>比特币</td><td>以太坊</td></tr><tr><td>图灵完备</td><td>否</td><td>是</td></tr><tr><td>适用</td><td>单一应用，如：货币网络</td><td>平台应用</td></tr><tr><td>支持智能合约</td><td>否</td><td>是</td></tr></tbody></table><p><a href="https://www.cryptokitties.co/">https://www.cryptokitties.co/</a></p><h4 id="2-2-私有链、公有链、联盟链"><a href="#2-2-私有链、公有链、联盟链" class="headerlink" title="2.2 私有链、公有链、联盟链"></a>2.2 私有链、公有链、联盟链</h4><p><code>私有链：</code>一般适用于一个团体内使用，容错、安全可以酌情考虑，如果节点可信度较高，在选择共识算法上可以考虑无“不可控节点”（拜占庭）问题存在的paxos算法。</p><p><code>公有链：</code>适用于公开使用，所有参与者都是不可控的，每个节点都是直接的参与者，并且对待每个参与者都是无差别的，这样平台需要面对更多的问题，例如节点频繁加入、退出平台，或发送虚假消息，甚至被黑客劫持。因此平台对安全、容错性要求较高，同时“复杂”的共识算法也会导致整个共识过程非常缓慢。</p><p><code>联盟链：</code>适用于多个团体之间的链，参与者在进入服务平台之前，需要进行认证，确定参与者的属性后，才能使用平台。联盟链具有一定的约定性，可以接受“多中心化”的共识算法的介入，如果团体之间并不认可，也可以采取完全中心化的共识算法。</p><h4 id="2-3-为什么是-Hyperledger-Fabric"><a href="#2-3-为什么是-Hyperledger-Fabric" class="headerlink" title="2.3 为什么是 Hyperledger Fabric"></a>2.3 为什么是 Hyperledger Fabric</h4><ul><li><p>Q：为什么不是比特币？  </p><p>A：需要智能合约</p></li><li><p>Q：为什么不是以太坊？</p><p>A：典型的联盟链</p></li></ul><h4 id="2-4-Hyperledger-Fabric-模型"><a href="#2-4-Hyperledger-Fabric-模型" class="headerlink" title="2.4 Hyperledger Fabric 模型"></a>2.4 Hyperledger Fabric 模型</h4><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230145109.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230145109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201230145107266"></p><h4 id="2-5-证书颁发机构（Certificate-Authorities，CA）"><a href="#2-5-证书颁发机构（Certificate-Authorities，CA）" class="headerlink" title="2.5 证书颁发机构（Certificate Authorities，CA）"></a>2.5 证书颁发机构（Certificate Authorities，CA）</h4><ul><li>在区块链网络中的不同组件之间，彼此是使用证书来标识自己是来自于特定组织的；</li><li>可以用来为交易提供签名，来表明一个组织对交易的结果进行背书，背书是一笔交易可以被接受并记录到账本上的前提条件</li></ul><h4 id="2-6-Peer-节点"><a href="#2-6-Peer-节点" class="headerlink" title="2.6 Peer 节点"></a>2.6 Peer 节点</h4><p><code>Peer节点和应用程序</code></p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.6.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Peer6"></p><ol><li>应用程序 A 连接到了 P1 并且调用了链码 S1 来查询或者更新账本 L1</li><li>P1 调用了链码 S1 来生成提案响应，这个响应包含了查询结果或者账本更新的提案</li><li>应用程序 A 接收到了提案的响应，对于查询来说，流程到这里就结束了</li><li>对于更新来说，应用程序 A 会从所有的响应中创建一笔交易<ul><li>它会把这笔交易发送给排序节点 O1 进行排序；</li><li>O1 会搜集网络中的交易并打包到区块中；</li><li>然后将这些区块分发到所有 Peer 节点上，包括 P1。P1 在把交易提交到账本 L1 之前对交易进行验证。</li></ul></li></ol><p><code>Peer节点和排序节点</code></p><p>应用程序和 Peer 节点彼此互相交互来确保每个 Peer 节点的账本永远保持一致是通过以==排序节点==作为中心媒介的一种特殊机制</p><p>==1. 提案==</p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.10.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Peer10"></p><ul><li>应用程序 A1 生成了交易 T1 和提案 P，应用程序会将交易及提案发送给通道 C 上的 Peer 节点 P1 和 Peer 节点 P2；</li><li>P1 使用交易 T1 和 提案 P 来执行链码 S1，这会生成对交易 T1 的响应 R1，它会提供背书 E1。P2 使用交易 T1 提案 P 执行了链码 S1，这会生成对于交易 T1 的响应 R2，它会提供背书 E2；</li><li>应用程序 A1 对于交易 T1 接收到了两个背书响应，称为 E1 和 E2。</li></ul><p>==2. 排序和将交易打包到区块==</p><ul><li>排序节点是这个过程的关键——它接收交易，这些交易中包含了来自很多个应用的已经背书过的交易提案，并且将交易排序并打包进区块。</li></ul><p>==3. 验证和提交==</p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.12.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/peers.diagram.12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Peer12"></p><ul><li>排序节点 O1 将区块 B2 分发给了 Peer 节点 P1 和 Peer 节点 P2；</li><li>Peer P1 处理了区块 B2，产生了一个会被添加到 P1 的账本 L1 中的新区块；</li><li>Peer P2 处理了区块 B2，产生了一个会被添加到 P2 的账本 L1 中的新区块；</li><li>当这个过程结束之后，账本 L1 就会被一致地更新到了 Peer 节点 P1 和 P2 上，他们也可能会通知所连接的应用程序关于这笔交易已经被处理过的消息。</li></ul><h4 id="2-7-账本"><a href="#2-7-账本" class="headerlink" title="2.7 账本"></a>2.7 账本</h4><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.1.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ledger.ledger"></p><p><strong>世界状态</strong>是一个数据库，它存储了一组账本状态的<strong>当前值</strong>。通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值</p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.3.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ledger.worldstate"></p><p><strong>区块链</strong>是交易日志，它记录了促成当前世界状态的所有改变。交易被收集在附加到区块链的区块中，能帮助我们理解所有促成当前世界状态的改变的历史。区块链数据结构与世界状态相差甚远，因为一旦把数据写入区块链，就无法修改，它是<strong>不可篡改的</strong>。</p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.2.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ledger.blockchain"></p><p><img src="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.4.png" class="lazyload" data-srcset="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/_images/ledger.diagram.4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ledger.blocks"></p><p>我理解的区块链  VS  真正的区块链：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230164037.jpeg" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201230164037.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="WechatIMG20"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue-Priority Quque</title>
      <link href="2020/11/25/Queue-Priority-Quque/"/>
      <url>2020/11/25/Queue-Priority-Quque/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>​        还是来填一下优先队列的坑，在前面已经介绍过 <a href="http://wangba.me/2020/11/24/Queue/">队列</a> 了，而且在其中介绍了一种拥有特殊特性的队列：优先队列。在其中我们提到了，不管你是进入这个优先队列的顺序如何，出队的顺序是可以定制的 ( 也可以说是按照一定顺序的 )，让我们先看一个 Java 中的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LC0000PriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add elements</span></span><br><span class="line">        queue.add(<span class="number">9</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">8</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(queue.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><blockquote><p>1 3 5 8 9 </p></blockquote><p>只要将构造优先队列的方式改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; y -x);</span><br></pre></td></tr></table></figure><p>就可以看到结果变成了：</p><blockquote><p>9 8 5 3 1 </p></blockquote><p>让我们来仔细研究一下，这个进队无序，出队有序的数据结构吧！</p><h2 id="二、堆与二叉堆"><a href="#二、堆与二叉堆" class="headerlink" title="二、堆与二叉堆"></a>二、堆与二叉堆</h2><p>为什么介绍优先队列，要先介绍 <code>堆</code> 这个数据机构，在上一章就已经提到过了，优先队列是基于堆完成的。</p><p>所以首先介绍一下堆：</p><ul><li>堆是一颗完全二叉树 ( 这就是前面不想介绍堆的原因，它是基于树的 )</li><li>堆中所有结点的值必须大于或等于（或小于或等于）其孩子结点的值</li></ul><p>二叉堆：每个结点最多有两个孩子结点。正常情况下，不仔细描述，一般默认堆为二叉堆。</p><h3 id="2-1-实现堆"><a href="#2-1-实现堆" class="headerlink" title="2.1 实现堆"></a>2.1 实现堆</h3><p>如果要实现一个堆，首先就要考虑使用数组实现还是链表实现，这个时候就要考虑到它的性质呢，它是一个完全二叉树，那么用数组实现它是最好的选择，来看下例子：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125165137.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125165137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125165136575"></p><p>可以看到，在这里面不会浪费空间，除了第 0 号索引，那是为了方便后面计算暂定，用数组还会得到下面的巨大好处：</p><ul><li><p>每一个结点 ( i ) 的左孩子和右孩子的索引分别为：<code>2 * i</code> 和 <code>(2 * i) + 1</code></p><p>example : 父结点 9 的左孩子为：<code>1 * 2</code> ；右孩子为： <code>1 * 2 + 1</code></p></li><li><p>每一个子结点 ( j ) 的父结点为：<code>j / 2</code></p><p>example : 子结点 1 和 子结点 3 的父结点为：<code>4 / 2</code> 和 <code>5 / 2</code></p></li></ul><p>既然我们已经确定用什么来存储了，接下来就要考虑其中的操作了，最起码的 CRUD 要有吧</p><p>来瞅瞅增加一个元素的操作：还是用上面的那个例子吧，如果此时增加一个元素 10，那得到结果就为：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125170533.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125170533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125170532356"></p><p>那此时问题就出现了啊，6 明显要小于 10 啊，这就不符合堆的性质了，那么我们就要进行一个重要的操作了：</p><p><code>heapify (堆化)</code></p><h3 id="2-2-Sift-Up"><a href="#2-2-Sift-Up" class="headerlink" title="2.2 Sift Up"></a>2.2 Sift Up</h3><p>像上面那个例子里面明显要把 10 放到最上方的操作，一般叫做 <code>Sift Up (上浮)</code>，对应的也要下沉操作，在下面进行介绍，那现在面临的问题就是怎么把 10 上浮到最上方的位置，直接与最上方位置进行交换吗？明显不行。</p><ul><li>只需要将这个结点与自己的父结点进行比较，如果符合堆的性质就不交换；如果不符合就交换父子结点</li></ul><p>实现一下上面的例子：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125173348.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125173348.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125173347010"></p><p>这样就可以满足形成一个堆的条件了</p><h3 id="2-3-Sift-Down"><a href="#2-3-Sift-Down" class="headerlink" title="2.3 Sift Down"></a>2.3 Sift Down</h3><p>与  Sift Up 对应的操作就是 Sift Down 操作，下浮操作一般都是处于删除之中，按照常理来说，只需要和上浮操作相反就行，理论上就是：</p><ul><li>直接将该结点删除，随后将子结点中较大的那个放到该位置，后续都进行这样的操作</li></ul><p>但是让我们来看个例子：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125184914.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125184914.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125184913889"></p><p>可以看到这次进行下沉操作后，该堆并不是一个完全二叉树了，并且在数组上有多余的空间了。那么我们应该怎样去避免这种情况的发生了</p><p>我们的目的就是让它进行下沉操作后还是一个堆，只需要将要<code>删除的结点与最后一个结点进行互换，再进行下沉操作即可</code></p><p>让我们来继续看上面这个例子：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125185710.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125185710.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125185709215"></p><ul><li>首先删除 10 ，将 最后一个元素放到该位置</li><li>与子结点进行比较，进行下沉操作，将 4 与 9 互换</li><li>与子结点进行比较，进行下沉操作，将 4 与 6 互换</li></ul><p>接下来就是用代码来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LC0000Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LC0000Heap</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        elements[count] = element;</span><br><span class="line">        siftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; elements[i] &gt; elements[i / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(elements, i, i / <span class="number">2</span>);</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        elements[<span class="number">1</span>] = elements[count];</span><br><span class="line">        count--;</span><br><span class="line">        siftDown(elements, <span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] elements, <span class="keyword">int</span> firstIndex, <span class="keyword">int</span> lastIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = firstIndex;</span><br><span class="line">            <span class="comment">// compare to leftChild</span></span><br><span class="line">            <span class="keyword">if</span> (firstIndex * <span class="number">2</span> &lt;= lastIndex &amp;&amp; elements[firstIndex] &lt; elements[firstIndex * <span class="number">2</span>]) &#123;</span><br><span class="line">                maxIndex = firstIndex * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// compare to rightChild</span></span><br><span class="line">            <span class="keyword">if</span> (firstIndex * <span class="number">2</span> + <span class="number">1</span> &lt;= lastIndex &amp;&amp; elements[maxIndex] &lt; elements[firstIndex * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                maxIndex = firstIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(elements, firstIndex, maxIndex);</span><br><span class="line">            firstIndex = maxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] elements, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = elements[source];</span><br><span class="line">        elements[source] = elements[target];</span><br><span class="line">        elements[target] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;root has not parent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Heapify"><a href="#2-4-Heapify" class="headerlink" title="2.4 Heapify"></a>2.4 Heapify</h3><p>在堆中还有一个操作就是：<strong>Heapify</strong></p><p>该操作是对任意数组整理成堆的形式，我们可以对比一下一般对这种要求操作，和<strong>堆化</strong>操作分别是怎么实现的</p><ul><li>一般操作：将数组从 0 开始，然后逐步建立堆，时间复杂度应该为： O(nlogn)</li><li>堆化操作：直接将该数组看成一个完全二叉树，随后对最后一个非叶结点到第一个结点分别进行 <code>Sift Down</code> 操作</li></ul><p>如何实现堆化操作：</p><p>根据上面的描述，最关键的应该是找到第一个非叶结点，其实最后一个结点的父结点就是第一个非叶结点，下面让我们看一个实例：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125205446.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201125205446.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201125205445164"></p>]]></content>
      
      
      <categories>
          
          <category> 重学算法系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="2020/11/24/Queue/"/>
      <url>2020/11/24/Queue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>在前面已经看过受限的线性序列：<a href="http://wangba.me/2020/10/27/Stack/">栈</a></p><p>在本章中可以看一下另外一个受限的线性序列：队列</p><p>在本章中可以看到：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124152246.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124152246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124152245584"></p><p>🐢 : 首先对比一下栈，并介绍一下队列的特性</p><p>🐷 : 在这一小节中分别用数组和链表实现一下队列，主要是用数组实现</p><p>🐭 : 在这一小节主要介绍一下几个特殊的队列，其中主要是优先队列和双端队列</p><p>🐂 : 由于在 Java 中，队列是一个接口，简单看一下实现类</p><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>首先来回忆一下栈的特性：先进后出，后进先出</p><p>而队列的特性就是：<code>先进先出，后进后出</code></p><p>可以看一下下面的例子：</p><blockquote><p>字符串 “wang” 依次入队，随后再出队（省略部分步骤）</p></blockquote><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124211809.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124211809.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124154741796"></p><h2 id="三、实现队列"><a href="#三、实现队列" class="headerlink" title="三、实现队列"></a>三、实现队列</h2><h3 id="3-1-数组实现"><a href="#3-1-数组实现" class="headerlink" title="3.1 数组实现"></a>3.1 数组实现</h3><p>首先我们要知道有哪些操作：</p><ul><li>只在队尾进行入队的操作：enqueue</li><li>只在队头进行出队的操作：dequeue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LC0000ArrayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LC0000ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> String[n];</span><br><span class="line">        capacity = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enqueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == capacity) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        elements[tail] = element;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String res = elements[front];</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是仔细想想这个是有问题的，就拿上面那个例子来说，它全部入队和全部出队后的结果应该是这样：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124162102.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124162102.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124162100985"></p><p>那么左边的空间就没有再使用了，如何解决这个问题呢？来考虑一下在数组中是如何解决这个问题，数组中删除一个元素，然后移动把这个元素后的所有数据都向前移动一位。</p><p>那么在这里只需要出队一个元素，随后把所有元素向前移动一位即可。但是这个每出队一个元素就移动一位，时间复杂度为 O(n)，稍微优化一下，只在我们需要它的时候才进行移动操作。那么我们什么时候是需要到这些空余的空间呢，是不是只有在元素入队的时候才需要，所以只需要在入队的时候进行数据搬移的操作即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enqueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == capacity) &#123;</span><br><span class="line">        <span class="comment">// queue is full</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; elements.length; i++) &#123;</span><br><span class="line">            elements[i - front] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tail -= front;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[tail] = element;</span><br><span class="line">    tail++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先要判断一下队列是不是真的满了</li><li>如果不是满的，就可以将 <code>front</code> 到 <code>tail</code> 的元素全部搬到 <code>0</code> 到 <code>tail - front</code> 的位置</li></ul><h3 id="3-2-链表实现"><a href="#3-2-链表实现" class="headerlink" title="3.2 链表实现"></a>3.2 链表实现</h3><p>用链表实现的话，就不用考虑 <code>capacity</code> 的问题了，理论上在内存足够的情况下，可以无限入队，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LC0000LinkedListQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enqueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">            front = next;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> Node(element, <span class="keyword">null</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String res = front.val;</span><br><span class="line">        front = front.next;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(String val, Node next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、一些特殊的队列"><a href="#四、一些特殊的队列" class="headerlink" title="四、一些特殊的队列"></a>四、一些特殊的队列</h2><h3 id="4-1-循环队列"><a href="#4-1-循环队列" class="headerlink" title="4.1 循环队列"></a>4.1 循环队列</h3><p>在上面用数组实现队列时，由于队列的特性使得我们已经将其进行了一次优化，在每次进行入队操作时都要有条件的进行一次数据移动操作，时间复杂度为 O(n)，那有没有能将这个时间复杂度也省去的队列操作呢？这就是本小节介绍的一种特殊的队列：<code>循环队列</code></p><p>顾名思义，这种队列最大的特点就在于 <code>循环</code> 二字，那到底要如何实现这个循环呢，让我们来看个例子：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124185122.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124185122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124185121876"></p><p>我们正常情况下，空余的空间就是左边那部分空白，如果我们能实现直接将新加入的元素直接放入左边空白的空间不就行了吗？那么用什么操作才能达到这样的效果呢，使用 <code>取余</code> 这个数学操作即可。</p><p>看起来的确是很 easy ，只要将 <code>tail = (tail + 1) % capacity</code> 即可，但是事实真的如此吗？</p><p>在前面使用数组实现队列时，我们对栈空和栈满的判断是这样的</p><ul><li>栈空：<code>front == tail</code></li><li>栈满：<code>tail  == capacity</code></li></ul><p>那在循环队列中，我们应该如何实现这两个判断呢？还是举个例子，为了更加方便理解，我将数组的首尾相连，本质是还是一个数组：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124192312.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124192312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124192309732"></p><ul><li>栈空：<code>front == tail</code></li><li>栈满：在循环队列中用 <code>tail  == capacity</code> 判断栈满肯定不在合适。在上面右图中，我们可以看到该循环栈还没有满，我们尝试在其中再增加一个元素，那么栈满的判断就变成了 <code>front == tail</code> ，这就和判断栈空一样了，所以在循环队列中，我们总是会浪费一个空间，即 tail 指向的的数据为空，也就是上面右图这样的情况，那么此时判断栈满的条件就变成了： <code>(tail + 1) % capacity == front</code></li></ul><p>上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LC0000CycleQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LC0000CycleQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> String[n];</span><br><span class="line">        capacity = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enqueue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// judging queue is full</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % capacity == front) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        elements[tail] = element;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// judging queue is empty</span></span><br><span class="line">        <span class="keyword">if</span> (front == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String res = elements[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % capacity;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-优先队列"><a href="#4-2-优先队列" class="headerlink" title="4.2 优先队列"></a>4.2 优先队列</h3><p>这一小节介绍一下另一种特殊的队列：优先队列。老规矩，先说一下特性：</p><ul><li>本质上还是队列，所以队列该有的操作它都有</li><li>但是它的 enqueue 和 dequeue 的操作结果可能与正常的队列结果不一样：</li></ul><blockquote><p>enqueue : 插入一个元素</p><p>dequeue : 删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素）</p></blockquote><p><strong>优先队列的主要操作：</strong></p><p>优先队列是元素的容器，每个元素有一个相关的键值；</p><ul><li><p><code>insert(key, data)</code>：插入键值为key的数据到优先队列中，元素以其key进行排序；</p></li><li><p><code>deleteMin/deleteMax</code>：删除并返回最小/最大键值的元素；</p></li><li><p><code>getMinimum/getMaximum</code>：返回最小/最大剑指的元素，但不删除它；</p></li></ul><p><strong>优先队列的辅助操作：</strong></p><ul><li><code>第k最小/第k最大</code>：返回优先队列中键值为第k个最小/最大的元素；</li><li><code>大小（size）</code>：返回优先队列中的元素个数；</li><li><code>堆排序（Heap Sort）</code>：基于键值的优先级将优先队列中的元素进行排序；</li></ul><p>优先队列基于什么实现最好？</p><table><thead><tr><th>实现</th><th>插入</th><th>删除</th><th>寻找最小值</th></tr></thead><tbody><tr><td>无序数组</td><td>1</td><td>n</td><td>n</td></tr><tr><td>无序链表</td><td>1</td><td>n</td><td>n</td></tr><tr><td>有序数组</td><td>n</td><td>1</td><td>1</td></tr><tr><td>有序链表</td><td>n</td><td>1</td><td>1</td></tr><tr><td>二叉搜索树</td><td>logn(平均)</td><td>logn(平均)</td><td>logn(平均)</td></tr><tr><td>平衡二叉搜索树</td><td>logn</td><td>logn</td><td>logn</td></tr><tr><td>二叉堆</td><td>logn</td><td>logn</td><td>1</td></tr></tbody></table><p>可以看到一般的优先队列都是基于 <code>二叉堆</code> 实现，具体如何实现暂时不细讲，等到写到二叉堆的时候提及一下</p><p>在 LeetCode 中关于优先队列的题目也不少，最经典的就是 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">0023. Merge k Sorted Lists</a> ，具体解法可以看下 <a href="http://wangba.me/2020/10/14/0023-Merge-k-Sorted-Lists/">0023. Merge k Sorted Lists</a> 中的解法三，还有比较经典的 0215、0239、0264、0295、0347、0692 等等</p><h2 id="五、Java-中的队列"><a href="#五、Java-中的队列" class="headerlink" title="五、Java 中的队列"></a>五、Java 中的队列</h2><p>在 Java 中，队列只是一个接口，如下：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210441.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124210438755"></p><p>让我们来看看里面的具体实现类吧，这里优先选择上面优先队列，继承和实现类图如下：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210805.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210805.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124210802761"></p><p>在优先队列的 Structure 中可以看到：</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210955.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201124210955.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201124210954420" style="zoom:200%;" /><p>可以看到最关键的两个方法： offer 和 remove，其中 add 是调用 offer 方法的，这两个就是对应着队列中的 enqueue 和 dequeue 方法。</p><p>由于优先队列是基于二叉堆的，所以会有 <code>上浮</code> 和 <code>下沉</code> 操作，在此就不细说了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重学算法系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack--Monotonic Stack</title>
      <link href="2020/11/23/Stack-Monotonic-Stack/"/>
      <url>2020/11/23/Stack-Monotonic-Stack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>在前面已经提及过 <a href="http://wangba.me/2020/10/27/Stack/">栈</a> 这个数据结构，在 LeetCode 中有考察过这样一种栈操作：单调栈。</p><p>顾名思义，这是在栈的基础上达到单调递增或单调递减的效果。</p><p>大概的过程如下：</p><ul><li><p>如果想达到递增的效果：</p><ul><li>进栈：首先要比较与栈顶的大小，如果比栈顶元素大，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较</li><li>出栈：直接出栈即可</li></ul></li><li><p>如果想达到递减的效果：</p><ul><li>进栈：首先要比较与栈顶的大小，如果比栈顶元素小，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较</li><li>出栈：直接出栈即可</li></ul></li></ul><h2 id="二、Example"><a href="#二、Example" class="headerlink" title="二、Example"></a>二、Example</h2><p>假如有下面的例子：</p><p>有一组数为：</p><blockquote><p>1，4，2，5，7，6，8</p></blockquote><p>现在要得到一个单调递增栈，过程如下：</p><table><thead><tr><th>Step</th><th>Op</th><th>Stack</th></tr></thead><tbody><tr><td>1</td><td>1  push</td><td>1</td></tr><tr><td>2</td><td>4  push</td><td>1  4</td></tr><tr><td>3</td><td>4 pop  |  2  push</td><td>1  2</td></tr><tr><td>4</td><td>5  push</td><td>1  2  5</td></tr><tr><td>5</td><td>7 push</td><td>1  2  5  7</td></tr><tr><td>6</td><td>7  pop  |  6  push</td><td>1  2  5  6</td></tr><tr><td>7</td><td>8  push</td><td>1  2  5  6  8</td></tr></tbody></table><h2 id="三、LeetCode-496"><a href="#三、LeetCode-496" class="headerlink" title="三、LeetCode 496"></a>三、LeetCode 496</h2><p>看一个典型例子 <a href="https://leetcode-cn.com/problems/next-greater-element-i/">LeetCode 0496</a> :</p><p>题意：给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br></pre></td></tr></table></figure><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; i) &#123;</span><br><span class="line">            map.put(stack.peek(), i);</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        res[i] = map.get(nums1[i]) != <span class="keyword">null</span> ? map.get(nums1[i]) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重学算法系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0084. Largest Rectangle in Histogram</title>
      <link href="2020/11/02/0084-Largest-Rectangle-in-Histogram/"/>
      <url>2020/11/02/0084-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="84-Largest-Rectangle-in-Histogram-Hard"><a href="#84-Largest-Rectangle-in-Histogram-Hard" class="headerlink" title="84. Largest Rectangle in Histogram Hard"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力破解"><a href="#思路一：暴力破解" class="headerlink" title="思路一：暴力破解"></a>思路一：暴力破解</h3><ul><li>先用 HashSet 存储数组中不重复的值，主要是用来加速的，不用也可以，像在本题里面就可以少算一次 <code>2</code></li><li>然后遍历这个 set，再在 set 中进行数组遍历，找到连续比当前值大于或等于的数组值，并找到最大的宽度，像在上面的🌰中，当值为 <code>1</code> 时，遍历一遍后，最大的的宽度为 <code>6</code> </li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> height : heights) &#123;</span><br><span class="line">        set.add(height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> height : set) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : heights) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= height) &#123;</span><br><span class="line">                width++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, width);</span><br><span class="line">                width = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, width);</span><br><span class="line">        res = Math.max(res, max * (height));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>这个思路有点和 <a href="http://wangba.me/2020/10/28/0042-Trapping-Rain-Water/">42题</a> 有点像，可以看下面的🌰：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201104211959.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201104211959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201104211954756"></p><ul><li>在思路一中，是将每一个不重复的数组元素和整个数组进行对比，求出最大面积</li><li>在 该解法中，仍然是求每个柱子所占的最大面积，最后取最大的即可</li><li>红色是当前柱子，分别找到离该柱子左边最近比该柱子低的柱子 <code>leftMin </code> 和右边最近低于该柱子的柱子    <code>rightMin</code> </li><li>此时的面积可以计算为：<code>heights[cur] * ( rightMin - leftMin -1)</code></li></ul><p>那么如何求出每一个柱子的 <code>leftMin </code> ，下面的代码是时间复杂度为 O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[i] &lt;= heights[temp]) &#123;</span><br><span class="line">        temp--;</span><br><span class="line">    &#125;</span><br><span class="line">    leftMin[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上面的代码是可以降低时间复杂度的，可以看下面这个🌰：</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105213556.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105213556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201105202816731" style="zoom:200%;" /><ul><li>如果我们要求 <code>cur</code> 的 <code>leftMin</code> ，可以放弃一部分比较，具体是哪一部分呢？</li><li>如果当前 <code>cur</code> 高度小于 <code>cur - 1</code> ，那么 <code>leftMin[i - 1] + 1</code> 到 <code>cur - 1</code> 之间所有柱子的高度都是大于 <code>cur</code> 的，因为 <code>leftMin[i - 1]</code> 是第一个比 <code>cur - 1</code> 低的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">        temp = leftMin[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    leftMin[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">    leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">            temp = leftMin[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        leftMin[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] rightMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">    rightMin[heights.length - <span class="number">1</span>] = heights.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt;= heights.length -<span class="number">1</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">            temp = rightMin[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        rightMin[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (rightMin[i] - leftMin[i] - <span class="number">1</span>) * heights[i];</span><br><span class="line">        max = Math.max(max, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三：栈"><a href="#思路三：栈" class="headerlink" title="思路三：栈"></a>思路三：栈</h3><ul><li>当遍历到 <code>cur</code> 时，出现 <code>height[cur] &lt; height[peek]</code> 时，那么 <code>leftMin</code> 一定是 <code>newPeek</code> ，<code>rightMin</code> 就是 <code>cur</code> ，此时面积最大值就是 <code>(cur - leftMin - 1) * height[peek]</code></li></ul><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105212529.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105212529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201105212528335"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; heights.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> peek = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt;= heights[peek]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> leftMin = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="keyword">int</span> area = (i - leftMin - <span class="number">1</span>) * height;</span><br><span class="line">                max = Math.max(area, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> leftMin = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        <span class="keyword">int</span> area = (heights.length - leftMin - <span class="number">1</span>) * height;</span><br><span class="line">        max = Math.max(area, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0071. Simplify Path</title>
      <link href="2020/10/30/0071-Simplify-Path/"/>
      <url>2020/10/30/0071-Simplify-Path/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="71-Simplify-Path-Medium"><a href="#71-Simplify-Path-Medium" class="headerlink" title="71. Simplify Path Medium"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. Simplify Path</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p><p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level.</p><p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 6:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">Output: &quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：栈"><a href="#思路一：栈" class="headerlink" title="思路一：栈"></a>思路一：栈</h3><p>这两个思路是一样的，只是分别使用数组和栈而已</p><ul><li>首先从 <code>/</code> 分开，然后用栈保存，如果栈不为空，且当前字符为 <code>..</code> 说明要进行进入上层目录，此时将栈中的元素弹出</li><li>只要不为空、不为 <code>.</code> 、不为 <code>..</code> ，就把其中的元素放入栈中即可</li><li>最后在最前面和每个字符串中间加上 <code>/</code></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Stack</span></span><br><span class="line">    String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; <span class="string">&quot;..&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">&quot;.&quot;</span>.equals(s) &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(s) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(stack);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + String.join(<span class="string">&quot;/&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：纯数组"><a href="#思路二：纯数组" class="headerlink" title="思路二：纯数组"></a>思路二：纯数组</h3><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    List&lt;String&gt; wordList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || s.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; wordListSim = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wordListSim.isEmpty()) &#123;</span><br><span class="line">                wordListSim.remove(wordListSim.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wordListSim.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + String.join(<span class="string">&quot;/&quot;</span>, wordListSim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>something need to learn or write</title>
      <link href="2020/10/29/something-need-to-learn-or-write/"/>
      <url>2020/10/29/something-need-to-learn-or-write/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><input disabled="" type="checkbox"> 实体类使用 java.x 的 valiation 和 hibernate 的 validator 进行校验</li><li><input disabled="" type="checkbox"> Spring Data JPA 的更深入使用</li><li><input disabled="" type="checkbox"> Shiro 或者 Spring Security 整合 JWT</li><li><input disabled="" type="checkbox"> mapstruct 和 beansUtils 的类自动赋值</li><li><input disabled="" type="checkbox"> Java 8-13 中的一些新特性</li><li><input disabled="" type="checkbox"> 前后端分离中的异常处理</li></ul><hr><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li><input disabled="" type="checkbox"> 哈佛的 CS 50 课程</li><li><input disabled="" type="checkbox"> 从零搭建一个 Hexo 主题</li></ul><hr><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><input checked="" disabled="" type="checkbox"> <a href="http://141.164.52.228/tags/Array/">数组</a></li><li><input checked="" disabled="" type="checkbox"> <a href="http://141.164.52.228/tags/LinkedList/">链表</a></li><li><input disabled="" type="checkbox"> 栈</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0042. Trapping Rain Water</title>
      <link href="2020/10/28/0042-Trapping-Rain-Water/"/>
      <url>2020/10/28/0042-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="42-Trapping-Rain-Water-Hard"><a href="#42-Trapping-Rain-Water-Hard" class="headerlink" title="42. Trapping Rain Water Hard"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. Trapping Rain Water</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：行求解"><a href="#思路一：行求解" class="headerlink" title="思路一：行求解"></a>思路一：行求解</h3><p>每次求一行的所有水：</p><ul><li>首先要标记是否开始，只要第一次出现 height[i] &gt;= 当前层次的值时，才开始计数，因为它左边没有墙</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find the maximum num in the height</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : height) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &amp;&amp; value &lt; i) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value &gt;= i) &#123;</span><br><span class="line">                res += count;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n * m)        其中 n 为数组长度，m 为数组中最大的值</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：列求解"><a href="#思路二：列求解" class="headerlink" title="思路二：列求解"></a>思路二：列求解</h3><ul><li>只要关注于每一列就行，且关注该列的左边最高列和右边最高列</li><li>如何求解该列的水，只需要将这左右高列中较低的那个减去当前的列的高度即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. column</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minColumn = getMinColumn(i, height);</span><br><span class="line">        <span class="keyword">if</span> (minColumn &gt; height[i]) &#123;</span><br><span class="line">            count += (minColumn - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinColumn</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; left) left = height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; right) right = height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)    </p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路三：栈"><a href="#思路三：栈" class="headerlink" title="思路三：栈"></a>思路三：栈</h3><p>可以想象为括号匹配：其中墙可以看作<code>括号</code>，水可以看作括号匹配的中间计算</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. Stack</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; height.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[cur] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = height[stack.peek()];</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> len = cur - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(height[cur], height[stack.peek()]);</span><br><span class="line">            res += (min - temp) * len;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路四：动态规划"><a href="#思路四：动态规划" class="headerlink" title="思路四：动态规划"></a>思路四：动态规划</h3><p>在思路二中，是使用没次找一个数，都要遍历整个数组找到左边和右边的最高列，然后进行计算，在这个基础上，使用一个 dp 数组将这些值维护起来：</p><p>第 i 列的左边最高列和右边最高列应该为：</p><p><code>left[i] = max(left[i - 1], height[i - 1])</code></p><p><code>right[i] = max(right[i + 1], height[i + 1])</code></p><p>这样用两个数组去维护就行了，每次遍历的时候直接在这个 dp 数组中取就行了</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use array to save the maximum left num of every item</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        left[i] = Math.max(left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use array to save the maximum right num of every item</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right[i] = Math.max(right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minColumn = Math.min(left[i], right[i]);</span><br><span class="line">        <span class="keyword">if</span> (minColumn &gt; height[i]) &#123;</span><br><span class="line">            res += minColumn - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n）    </p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路五：动态规划-双指针"><a href="#思路五：动态规划-双指针" class="headerlink" title="思路五：动态规划 + 双指针"></a>思路五：动态规划 + 双指针</h3><p>在思路四中，已经使用 dp 数组去存储左边和右边的最高列，但是仔细思考一下，这个 dp 数组中的值，其实就使用一次，那么可以将这个空间复杂度再降低一点，有点类似于用动态规划求解斐波那契数列</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = Math.min(height[l], height[r]);</span><br><span class="line">        <span class="keyword">if</span> (height[l] == mn) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt; mn) &#123;</span><br><span class="line">                res += mn - height[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt; mn) &#123;</span><br><span class="line">                res += mn - height[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n）    </p><p>空间复杂度：O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0020. Valid Parentheses</title>
      <link href="2020/10/28/0020-Valid-Parentheses/"/>
      <url>2020/10/28/0020-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses Easy"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. Valid Parentheses</a> <font color="#49b666" size=5>Easy</font></h2><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]&#123;&#125;&#39;</code>.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：栈"><a href="#思路一：栈" class="headerlink" title="思路一：栈"></a>思路一：栈</h3><p>在栈的那一节中，就提及到了栈的其中一个应用就是括号匹配，大致思路如下：</p><p>遇到 <code>(</code>、 <code>&#123;</code>、 <code>[</code> 这三种左括号，直接让它入栈，直到出现 <code>）</code>、 <code>&#125;</code>、 <code>]</code> ，首先判断栈是否为空或者栈顶的元素是否对应，如果对应，那么让它出栈，继续上述操作即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="string">&#x27;)&#x27;</span> &amp;&amp; temp != <span class="string">&#x27;]&#x27;</span> &amp;&amp; temp != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;)&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;(&#x27;</span> ||</span><br><span class="line">                temp == <span class="string">&#x27;]&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;[&#x27;</span> ||</span><br><span class="line">                temp == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><p>还看到了一种反向写法</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123; stack.push(<span class="string">&#x27;)&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123; stack.push(<span class="string">&#x27;]&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>) &#123; stack.push(<span class="string">&#x27;&#125;&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != c)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="2020/10/27/Stack/"/>
      <url>2020/10/27/Stack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027195704.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027195704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027195658275"></p><p>快速预览：</p><ul><li>🐷：第一小节看一下栈的特性，为什么会有这种受限的数据结构的出现？</li><li>🐢：第二小节看一下要实现一个栈，最基本需要什么操作？</li><li>🐭：第三小节看一下栈的的应用，是不是这些应用驱动着栈的诞生</li><li>🐦：最后一个小节还是老套路，简单的看一下 Java 中关于栈的 API</li></ul><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>​        在前面已经介绍了数组和链表两种最基本的数据结构，可以说他俩就是整个数据结构与算法的基石。看一下栈的组成：</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027201132.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027201132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027201130766" style="zoom:67%;" /><p>那么它和其他线性表最大的区别在哪呢？毫无疑问：它只允许在<code>一端进行插入和删除</code></p><p>或者说成 <code>先进后出、后进先出</code></p><p>此时，小朋友，你是否有很多问号？为什么要有这种受限的数据结构，我用数组和链表不香吗？当然栈就是基于数组或链表实现的，但是在特定的需求下，栈就应用而生了。具体可以参考下面的栈的应用和 Java 中栈，就可以看到在某些情况下栈的优势、以及由于数组和链表暴露出太多的接口，而栈只需要其中的一小部分就可以了</p><h2 id="三、实现栈"><a href="#三、实现栈" class="headerlink" title="三、实现栈"></a>三、实现栈</h2><p>我们在上面就提到了，栈既可以基于数组实现，也可以基于链表实现。栈最重要的两个操作：<code>入栈</code> 和 <code>出栈</code> </p><h3 id="3-1-定容栈"><a href="#3-1-定容栈" class="headerlink" title="3.1 定容栈"></a>3.1 定容栈</h3><p>这是《算法》中文版中的译名，顾名思义就是容量固定的栈，基于数组并用 Java 代码来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedCapacityStackOfString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedCapacityStackOfString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[count] = item;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String item = items[count - <span class="number">1</span>];</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(1)</p><p>空间复杂度：O(1)   不包含该栈本身，操作时的空间复杂度</p></blockquote><h3 id="3-2-扩容栈"><a href="#3-2-扩容栈" class="headerlink" title="3.2 扩容栈"></a>3.2 扩容栈</h3><p>在上面的定容栈中，是用一个固定大小的数组当成实现栈的结构，那么应该如何实现一个扩容栈呢？</p><p>其实也很好实现，回忆一下动态数组的事项，是将数组进行扩容，然后将原来的数据 copy 进去就行了；那么用同样的方式对基于数组的栈进行扩容 (当然基于链表实现的栈就没有这一概念，理论上只要内存空间足够大，栈可以无限大)</p><ul><li>当栈满的时候，进行扩容：新建一个比现在大的数组</li><li>将原来栈中的数据全部复制到新的数组中</li></ul><p>具体实现可以参考下面的第五小节</p><h2 id="四、栈的应用"><a href="#四、栈的应用" class="headerlink" title="四、栈的应用"></a>四、栈的应用</h2><h3 id="4-1-撤销操作"><a href="#4-1-撤销操作" class="headerlink" title="4.1 撤销操作"></a>4.1 撤销操作</h3><p>​        如果你经常使用 command + Z 或者 ctrl + Z，你可能会非常理解这个操作：当我们复制或者修改了一个文件，我们想把它恢复成复制或修改之前的一样的状态，只需要按上面的快捷键就行了，仔细想一下是否有栈的影子在里面</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027215546.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027215546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027215543027" style="zoom:80%;" /><p>就如同上面这个例子：我们写到了 wangba，随后又不想要 wangba 了，此时进行撤销操作，只需要将栈中的 wangba pop 就可以了，有的还有前进功能，此时只需要将其 push 进来即可</p><h3 id="4-2-函数调用"><a href="#4-2-函数调用" class="headerlink" title="4.2 函数调用"></a>4.2 函数调用</h3><p>​        如果了解过操作系统或者听说过函数调用，那么可以更容易理解下面的内容，在计算机中，操作系统会给每个线程分配一个内存空间，而这个内存空间就是栈式结构，专门为函数调用存储临时变量，就例如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> res = add(a, b);</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段 Java 代码中，可以看见在 main 中调用了 add 函数，在栈帧中应该就是这样：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123155657.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123155657.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123155657021"></p><blockquote><p>当然，真实情况不是这样的，要是这么简单，计算机底层就不会这么劝退了 ～～～</p><p>如果有兴趣了解更深可以参考：《深入理解计算机系统》或者想大概了解一下可以参考 <a href="https://blog.csdn.net/wangyezi19930928/article/details/16921927">这个</a></p></blockquote><h3 id="4-3-表达式求值"><a href="#4-3-表达式求值" class="headerlink" title="4.3 表达式求值"></a>4.3 表达式求值</h3><p>🐢：在编译器中是如何对表达式进行求值的呢？如果是后缀表达式就只需要一个操作栈即可；如果是前缀或中缀表达式则需要一个操作数栈和一个操作符栈，来看一下中缀表达式的求值过程：</p><p><code>a * (b + c)</code></p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123165540.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123165540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123165539976"></p><p>过程大概如下：</p><ul><li>遇到操作数就压到操作数的栈；遇到操作符就压到操作符的栈</li><li>在压到操作符的栈是有条件的：如果操作符<code>栈顶的符号</code>的优先级大于等于要<code>压入的符号</code>，那就取操作数栈顶的两个数进行计算；如果小于则直接把操作符压入操作符的栈</li></ul><h3 id="4-4-括号匹配"><a href="#4-4-括号匹配" class="headerlink" title="4.4 括号匹配"></a>4.4 括号匹配</h3><p>关于括号匹配可以参考 <a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 0020</a>，关于这题的解答可以看 <a href="http://wangba.me/2020/10/28/0020-Valid-Parentheses/">0020. Valid Parentheses</a></p><h2 id="五、Java中的栈"><a href="#五、Java中的栈" class="headerlink" title="五、Java中的栈"></a>五、Java中的栈</h2><p>首先看一下继承与实现的关系：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170705.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170705.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123170704974"></p><p>再看一下该类中的 Structure :</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170836.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123170835999"></p><p>可以看出来很简单，就如同上面在定容栈中的操作差不多，实际上差的很多，要考虑到扩容、并发等等情况，操作大都是在他的父类 Vertor 中完成，如果你看过面经啥的，你应该就听过并发不要使用 Vertor，要多使用 JUC 包下面的类，然后究其原因就是：Vertor 使用 <code>synchronized</code> 关键字，JUC 包下的是使用 <code>ReentrantLock</code>，而可重入锁的底层则是 AQS</p><p>LeetCode 重点关于栈的重点：<code>Monotonic Stack</code></p>]]></content>
      
      
      <categories>
          
          <category> 重学算法系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. SortList</title>
      <link href="2020/10/26/148-SortList/"/>
      <url>2020/10/26/148-SortList/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="148-Sort-List-Medium"><a href="#148-Sort-List-Medium" class="headerlink" title="148. Sort List Medium"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. Sort List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：递归法"><a href="#思路一：递归法" class="headerlink" title="思路一：递归法"></a>思路一：递归法</h3><ul><li>归并排序</li><li>找链表中点</li><li>哨兵</li></ul><p>本题是一个无序链表的排序问题，要求是空间复杂度为 <code>O(nlogn)</code> ，那只能想到快速排序、归并排序、堆排序，快排上通过索引的，不适合用在链表中；堆排序新建结点中；这题可采用归并排序，在 <a href="http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/">21题</a> 中介绍了合并两个有序列表，现在只是一个无序链表，没有条件创造条件：</p><ul><li>两个链表：找到链表中点，切断</li><li>有序：一个无序链表切开后，变成了两个无序链表，再对每一个链表进行递归，当只有一个结点，自然就是有序的了</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode slow = head, fast = head, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(sortList(head), sortList(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) cur.next = l1;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(1)   其实并不是 1 ，由于递归要调用栈</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>147. Insertion Sort List</title>
      <link href="2020/10/23/147-Insertion-Sort-List/"/>
      <url>2020/10/23/147-Insertion-Sort-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="147-Insertion-Sort-List-Medium"><a href="#147-Insertion-Sort-List-Medium" class="headerlink" title="147. Insertion Sort List Medium"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. Insertion Sort List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Sort a linked list using insertion sort.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" class="lazyload" data-srcset="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br>With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</p><p><strong>Algorithm of Insertion Sort:</strong></p><ol><li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li><li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li><li>It repeats until no input elements remain.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：插入排序"><a href="#思路一：插入排序" class="headerlink" title="思路一：插入排序"></a>思路一：插入排序</h3><p>按照插入排序的思想，要注意的点：</p><ul><li>不要断链</li><li>每一次都是从头开始进行比较</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode pre = res;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre.next;</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        pre = res;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="2020/10/22/143-Reorder-List/"/>
      <url>2020/10/22/143-Reorder-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="143-Reorder-List-Medium"><a href="#143-Reorder-List-Medium" class="headerlink" title="143. Reorder List Medium"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. Reorder List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力解法"><a href="#思路一：暴力解法" class="headerlink" title="思路一：暴力解法"></a>思路一：暴力解法</h3><p>直接将链表存在数组中，然后进行操作，不用考虑断链等问题，直接用数组下标解决一切</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="comment">// 1. 暴力解法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        list.get(i).next = list.get(j);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.get(j).next = list.get(i);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    list.get(j).next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h3><p>看到递归还是要想到两个方面的问题：</p><ul><li>出口</li><li>调用递归函数的统一操作</li></ul><p>首先要明确递归传出来的是啥，为什么使用思路一的想法就是，我想找最后一个元素，但是每次都要遍历一遍才能找到那个元素，所以使用了数组，通过下标获取其中的元素。所以，我们应该递归出来的局部链表的尾元素，看下面的🌰：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022204518.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022204518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201022204517106"></p><p>现在递归到出口，那么我们应该将 <code>tail</code> 传出来</p><p>第二，本题的出口要分为两种情况：奇数个和偶数</p><p>奇数：直接传出来</p><p>偶数：将它的 <code>next</code> 传出来</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="comment">// 2. 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode count = head;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count = count.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(head, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">helper</span><span class="params">(ListNode listNode, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode tail = listNode.next;</span><br><span class="line">        listNode.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">        ListNode tail = listNode.next.next;</span><br><span class="line">        listNode.next.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode helper = helper(listNode.next, length - <span class="number">2</span>);</span><br><span class="line">    ListNode cur = listNode.next;</span><br><span class="line">    ListNode next = helper.next;</span><br><span class="line">    listNode.next = helper;</span><br><span class="line">    helper.next = cur;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三：分组解法"><a href="#思路三：分组解法" class="headerlink" title="思路三：分组解法"></a>思路三：分组解法</h3><p>还可以将这个题分为以下几个部分：</p><ul><li>找到中点，分割成两个链表</li><li>对后一个链表进行逆序</li><li>双指针同步进行，将后面链表与前面的链表进行连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br><span class="line"></span><br><span class="line">分割：1 -&gt; 2 -&gt; 3</span><br><span class="line">     4 -&gt; 5 -&gt; 6</span><br><span class="line">     </span><br><span class="line">逆序：6 -&gt; 5 -&gt; 4</span><br><span class="line">     </span><br><span class="line">连接：1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = reverseList(cur);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode l1 = head.next;</span><br><span class="line">        ListNode l2 = next.next;</span><br><span class="line">        head.next = next;</span><br><span class="line">        next.next = l1;</span><br><span class="line">        head = l1;</span><br><span class="line">        next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><blockquote><p>注：在 LeetCode 中，递归法时间复杂度可以 beats 100%，第三种方法不可以，按照分析来说，应该是一样的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II</title>
      <link href="2020/10/22/142-Linked-List-Cycle-II/"/>
      <url>2020/10/22/142-Linked-List-Cycle-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II Medium"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p><p><strong>Follow up:</strong></p><p>Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>大体思路还是和 <a href="">141</a> 一样的，唯一的后续操作就是：让相遇点和开始点一起再向后走，这两个点再次相遇的点就是入口点，具体可以参考下面的图和数学证明：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022155330.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022155330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201022155322951"></p><p><strong>数学证明</strong></p><p>条件：环的结点数 <code>N</code>、开始点到入口点距离 <code>X</code>、入口点到相遇点距离 <code>Y</code> (逆时针的距离，上图中长的那部分)</p><p>假设：<strong>slow</strong> 结点总共走了 <code>T</code> 步到相遇点；则 <strong>fast</strong> 结点共走了 <code>2T</code> 步</p><p>​              <strong>slow</strong> 结点总共走了 <code>K1</code> 圈； <strong>fast</strong> 结点共走了 <code>K2</code> 圈</p><p>则：</p><p><code>T = X + K1 * N + Y </code>                :one:</p><p><code>2T = X + K2 * N + Y</code>             :two:</p><p>化简：</p><p><code>T = (K2 - K1) * N</code></p><p>带到 :one: 中：</p><p><code>X = (K2 - 2K1 -1) * N + (N - Y)</code></p><p>其中：</p><p><code>(N - Y)</code> 表示相遇点到入口点的距离</p><p>这时候就可以说：我相遇点的结点向前走了 <code>(K2 - 2K1 -1)</code> 圈回到了相遇点，再走了 <code>(N - Y)</code> 到了入口点</p><p>简直就是 <code>Amazing</code> 啊！</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            temp = slow;</span><br><span class="line">            <span class="keyword">while</span> (head != temp) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O()</p><p>空间复杂度：O()</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0092. Reverse Linked List II</title>
      <link href="2020/10/21/0092-Reverse-Linked-List-II/"/>
      <url>2020/10/21/0092-Reverse-Linked-List-II/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="92-Reverse-Linked-List-II-Medium"><a href="#92-Reverse-Linked-List-II-Medium" class="headerlink" title="92. Reverse Linked List II Medium"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a> <font color="#fd9016" size=5>Medium</font></h2><p>难度中等551</p><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：利用反转链表"><a href="#思路一：利用反转链表" class="headerlink" title="思路一：利用反转链表"></a>思路一：利用反转链表</h3><p>在 <a href="http://wangba.me/2020/10/09/0206-Reverse-Linked-List/]">206</a> 中已经解决了反转整个链表，现在这种部分的反转链表，只需要将上面的断链，丢到反转整个链表的函数中，再恢复连接就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">断链：1 2-&gt;3-&gt;4 5-&gt;NULL</span><br><span class="line">调用函数：4-&gt;3-&gt;2</span><br><span class="line"></span><br><span class="line">恢复：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode listNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    listNode.next = head;</span><br><span class="line">    ListNode res = listNode;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">            next = listNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == m - <span class="number">1</span>) &#123;</span><br><span class="line">            pre = listNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            cur = listNode;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = cur.next;</span><br><span class="line">    cur.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = reverseList(pre.next);</span><br><span class="line">    pre.next = node;</span><br><span class="line">    next.next = temp;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写的有点复杂了……</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：头插法"><a href="#思路二：头插法" class="headerlink" title="思路二：头插法"></a>思路二：头插法</h3><p>还是要使用哨兵，避免重复操作，哨兵后面结点的操作：找到第一个要进行逆置结点的前一个结点，然后对后每个结点都进行<code>头插法</code>就行了</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = pre.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0086. Partition List</title>
      <link href="2020/10/20/0086-Partition-List/"/>
      <url>2020/10/20/0086-Partition-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List Medium"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. Partition List</a> Medium</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：大小链表"><a href="#思路一：大小链表" class="headerlink" title="思路一：大小链表"></a>思路一：大小链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原链表：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span><br><span class="line"></span><br><span class="line">大链表：4 -&gt; 3 -&gt; 5</span><br><span class="line">小链表：1 -&gt; 2 -&gt; 2</span><br><span class="line"></span><br><span class="line">合并链表：1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">//        Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">        <span class="comment">// 小链表</span></span><br><span class="line">        ListNode min = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode l  = min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大链表</span></span><br><span class="line">        ListNode max = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode h = max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                l.next = head;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next = head;</span><br><span class="line">                h = h.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = <span class="keyword">null</span>;</span><br><span class="line">        l.next = max.next;</span><br><span class="line">        <span class="keyword">return</span> min.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O()</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0083. Remove Duplicates from Sorted List</title>
      <link href="2020/10/19/0083-Remove-Duplicates-from-Sorted-List/"/>
      <url>2020/10/19/0083-Remove-Duplicates-from-Sorted-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List Easy"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a> <font color="#49b666" size=5>Easy</font></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：双指针"><a href="#思路一：双指针" class="headerlink" title="思路一：双指针"></a>思路一：双指针</h3><p>由于都是已经排好序的链表，相同的数都在一起，只要使用双指针：一个指向出现的第一个数，一个一直遍历到这个数结束即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.val == fast.val) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0025. Reverse Nodes in k-Group</title>
      <link href="2020/10/15/0025-Reverse-Nodes-in-k-Group/"/>
      <url>2020/10/15/0025-Reverse-Nodes-in-k-Group/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="25-Reverse-Nodes-in-k-Group-Hard"><a href="#25-Reverse-Nodes-in-k-Group-Hard" class="headerlink" title="25. Reverse Nodes in k-Group Hard"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. Reverse Nodes in k-Group</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes, in the end, should remain as it is.</p><p><strong>Follow up:</strong></p><ul><li>Could you solve the problem in <code>O(1)</code> extra memory space?</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">Output: [2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">Output: [3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：迭代"><a href="#思路一：迭代" class="headerlink" title="思路一：迭代"></a>思路一：迭代</h3><p>可以结合下面的图和代码进行查看：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201015194154.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201015194154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201015193552764"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ans.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode res = ans;</span><br><span class="line">    ListNode end = ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) end = end.next;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        ListNode start = res.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = <span class="keyword">null</span>;</span><br><span class="line">        res.next = reverseList(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        res = start;</span><br><span class="line"></span><br><span class="line">        end = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h3><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode point = head;</span><br><span class="line">    <span class="comment">//找到子链表的尾部</span></span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(i - <span class="number">1</span> &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        point = point.next;</span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = point.next;</span><br><span class="line">    <span class="comment">//将子链表断开</span></span><br><span class="line">    point.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒置子链表，并接受新的头结点</span></span><br><span class="line">    ListNode new_head = reverseList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//head 其实是倒置链表的尾部，然后我们将后边的倒置结果接过来就可以了</span></span><br><span class="line">    <span class="comment">//temp 是链表断开后的头指针，可以参考解法一的图示</span></span><br><span class="line">    head.next = reverseKGroup(temp,k);</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1002. Find Common Characters</title>
      <link href="2020/10/14/1002-Find-Common-Characters/"/>
      <url>2020/10/14/1002-Find-Common-Characters/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1002-Find-Common-Characters-Easy"><a href="#1002-Find-Common-Characters-Easy" class="headerlink" title="1002. Find Common Characters Easy"></a><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. Find Common Characters</a> <font color="#49b666" size=5>Easy</font></h4><p>Given an array <code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>. For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p><p>You may return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">Output: [&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length &lt;= 100</code></li><li><code>1 &lt;= A[i].length &lt;= 100</code></li><li><code>A[i][j]</code> is a lowercase letter</li></ol><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力破解"><a href="#思路一：暴力破解" class="headerlink" title="思路一：暴力破解"></a>思路一：暴力破解</h3><p>仅供参考：</p><ul><li>找到长度最小的字符串，由于是考虑每一个字符串中重复的元素</li><li>将这个字符串放到 map 中，map 中的值可以设为字符串数组长度</li><li>依次遍历，如果重复就 -1 ，最后看 map 中的值是否变为 0</li></ul><h3 id="思路二：哈希"><a href="#思路二：哈希" class="headerlink" title="思路二：哈希"></a>思路二：哈希</h3><p>可以结合下面的图和代码进行理解</p><ul><li>由于都是小写字母，只需要使用容量为 26 的数组表示 26 位字母；</li><li>第一个 26 位数组，将字符串数组的第一个字符串装下，重复的 + 1</li><li>后面和第一个一样操作得到新的数组，比较其中的值，取<code>最小 </code>的即可，因为最小的那个才代表着它在自己的数组中重复了多少次，在所有的字符串中，它最多的字符重复 </li><li>将结果放在第一个数组，继续比较</li></ul><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201014193842.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201014193842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201014193840865"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">        res[A[<span class="number">0</span>].charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].length(); j++) &#123;</span><br><span class="line">            temp[A[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            res[j] = Math.min(res[j], temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (res[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(String.valueOf((<span class="keyword">char</span>)((i) + <span class="string">&#x27;a&#x27;</span>)));</span><br><span class="line">            res[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0023. Merge k Sorted Lists</title>
      <link href="2020/10/14/0023-Merge-k-Sorted-Lists/"/>
      <url>2020/10/14/0023-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists Hard"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a> <font color="#e82f34" size=5>Hard</font></h2><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> won’t exceed <code>10^4</code>.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力解法"><a href="#思路一：暴力解法" class="headerlink" title="思路一：暴力解法"></a>思路一：暴力解法</h3><p>遍历链表数组中的每一个链表，在每一个链表中继续遍历，将所有的结果都存在数组中，再进行一次快速排序，最后再把数组中的每个结点组装成链表即可</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ListNode listNode : lists) &#123;</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(res);</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode ans = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : res) &#123;</span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">        head.next  = listNode;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogn)，n 为所有结点数</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：列比较"><a href="#思路二：列比较" class="headerlink" title="思路二：列比较"></a>思路二：列比较</h3><p>利用每个链表数组中的链表是有序的，则每次拿到最小的结点加入新的链表中，每个链表数组中的链表头的值一定是最小的</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 列比较</span></span><br><span class="line">    <span class="comment">// 最小索引</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isCompleted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 遍历一遍链表数组找到数值最小的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lists[i].val &lt; min) &#123;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                    min = lists[i].val;</span><br><span class="line">                &#125;</span><br><span class="line">                isCompleted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当所有的链表全部遍历完了，while 循环结束</span></span><br><span class="line">        <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span>;</span><br><span class="line">        head.next = lists[minIndex];</span><br><span class="line">        head = head.next;</span><br><span class="line">        lists[minIndex] = lists[minIndex].next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m * n)，m 为最长链表的长度；n 为链表数组长度</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路三：优先队列"><a href="#思路三：优先队列" class="headerlink" title="思路三：优先队列"></a>思路三：优先队列</h3><p>在上面的思路中，每次都是找到链表数组中最小的结点，再加入新链表中，在上面使用的直接遍历的方式，在这里可以采用优先队列的方式，优先队列是基于堆实现的，具体来说就是小/大根(顶)堆，只需要将每个链表的头结点放入，会自动进行大小比较，出队列是就是最小/最大</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列中默认就是小根堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(Comparator.comparing(n -&gt; n.val));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将每个结点的的头结点加入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            priorityQueue.add(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 出队列时就是最小值先出来的</span></span><br><span class="line">        head.next = priorityQueue.poll();</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">// 将出队列的后面那个值加入优先队列</span></span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            priorityQueue.add(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogk)，n 表示所有的结点书数，logk 表示每个结点的入队、出队</p><p>空间复杂度：O(k)，k 表示链表数组的长度；在 Java 中优先队列是有默认值的</p></blockquote><h3 id="思路四：两两合并"><a href="#思路四：两两合并" class="headerlink" title="思路四：两两合并"></a>思路四：两两合并</h3><p>在<a href="http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/">0021. Merge Two Sorted Lists</a>中，已经实现过两个有序链表的合并，本题也可以参考这个思路：首先将链表 0 和链表 1 合并，合并成新的链表 a，在和链表 2 进行合并 ……</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4. 两两合并</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        temp = mergeTwoLists(temp, lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路五：二分法两两合并"><a href="#思路五：二分法两两合并" class="headerlink" title="思路五：二分法两两合并"></a>思路五：二分法两两合并</h3><p>在上面思路五中，合并的思路是：先是合并第一个和第二个，合并为新的后，再和第三个进行合并，这样的效率有点低</p><p>这个思路也是可以优化的，使用二分法：</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span> , lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    ListNode l = merge(lists, left, mid);</span><br><span class="line">    ListNode r = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(l , r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0021. Merge Two Sorted Lists</title>
      <link href="2020/10/13/0021-Merge-Two-Sorted-Lists/"/>
      <url>2020/10/13/0021-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists Easy"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a> <font color="#49b666" size=5>Easy</font></h2><p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>l1</code> and <code>l2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：迭代法"><a href="#思路一：迭代法" class="headerlink" title="思路一：迭代法"></a>思路一：迭代法</h3><p>设置一个头结点，随后开始比较两个链表的结点值大小，具体逻辑可以将下面的图和代码逻辑联系起来：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013173857.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013173857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013173854931"></p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="comment">// 1 2 4     1 3 4</span></span><br><span class="line">    <span class="comment">// 1 1 2 3 4 4</span></span><br><span class="line">    ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) temp.next = l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) temp.next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m + n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：递归法"><a href="#思路二：递归法" class="headerlink" title="思路二：递归法"></a>思路二：递归法</h3><p>递归最重要的两个点：</p><ul><li>递归的出口，在本题里面就是当其中的一个链表为空，直接返回另外一个链表即可</li><li>要进行递归，传入参数后的结果应该是已经确定的了，在这里就是链表已经排好序了</li></ul><p>举个例子：如果现在是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表la：1 -&gt; 3 -&gt; 5</span><br><span class="line"></span><br><span class="line">链表lb：2 -&gt; 4 -&gt; 6</span><br></pre></td></tr></table></figure><p>进行第一次递归时：要比较 1 和 2 的大小，发现 1 &lt; 2，此时只需要将 1.next =  <strong>mergeTwoLists(3, 2)</strong> 就行了，不要去想 <strong>mergeTwoLists(3, 2)</strong> 怎么来的，要把它当作已经确定的值就行，而 <strong>mergeTwoLists(3, 2)</strong> 的值可以看作是下面这两个链表的进行 <strong>mergeTwoLists</strong> 的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表la：3 -&gt; 5</span><br><span class="line"></span><br><span class="line">链表lb：2 -&gt; 4 -&gt; 6</span><br></pre></td></tr></table></figure><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="comment">// 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m + n)</p><p>空间复杂度：O(m + n)</p><ul><li>由于递归是调用栈的，每递归一次需要一个栈帧</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode真的难系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Spring Security(七)</title>
      <link href="2020/10/13/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%83/"/>
      <url>2020/10/13/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>​        这一小节整理一下前面几节的内容，主要完整的捋一遍 Spring Security 的登录过程。为了有一个 Architecture First  的印象，先将其中关键的类和接口列出，如果看到后面发现有印象，就可以跳到前面来看一下：</p><ul><li><p><strong>SecurityContextHolder</strong></p></li><li><p><strong>Authentication</strong></p></li><li><p>Token 类</p><ul><li><strong>UsernamePasswordAuthenticationToken</strong></li><li><strong>AbstractAuthenticationToken</strong></li></ul></li><li><p>Provider 和 Manger 类</p><ul><li><strong>AuthenticationManager</strong></li><li><strong>ProviderManager</strong></li><li><strong>AuthenticationProvider</strong></li><li><strong>DaoAuthenticationProvider</strong></li></ul></li><li><p><strong>UserDetails</strong> 与 <strong>UserDetailsService</strong></p></li></ul><p>主要可以参考一下这张图：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013133116.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013133116.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013133113040"></p><p>图源：<a href="https://lexburner.github.io/spring-security-1/">Spring Security(一)–Architecture Overview</a></p><h2 id="二、DeepLearning"><a href="#二、DeepLearning" class="headerlink" title="二、DeepLearning"></a>二、DeepLearning</h2><h3 id="2-1-Authentication"><a href="#2-1-Authentication" class="headerlink" title="2.1 Authentication"></a>2.1 Authentication</h3><p>先看一下 <strong>Authentication</strong> 的相关实现类</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013084521.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013084521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013084517460"></p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getAuthorities()：权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。</li><li>getCredentials()：密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li><li>getDetails()：细节信息，web 应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。</li><li>getPrincipal()：最重要的身份信息，大部分情况下返回的是 UserDetails 接口的实现类，也是框架中的常用接口之一。UserDetails 接口将会在下面的小节重点介绍。</li></ul></blockquote><p>在实现类中非常重要的就是 <strong>UsernamePasswordAuthenticationToken</strong> ，再看一下其中的属性和方法</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013090503.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013090503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013090502537"></p><p>以及它的父类：<strong>AbstractAuthenticationToken</strong> </p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013092222.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013092222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013092219226"></p><h3 id="2-2-UsernamePasswordAuthenticationFilter"><a href="#2-2-UsernamePasswordAuthenticationFilter" class="headerlink" title="2.2 UsernamePasswordAuthenticationFilter"></a>2.2 UsernamePasswordAuthenticationFilter</h3><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 UsernamePasswordAuthenticationFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</span><br><span class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">                username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            username = username.trim();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainPassword</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.passwordParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainUsername</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.usernameParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：<strong>UsernamePasswordAuthenticationFilter</strong> 是继承 <strong>AbstractAuthenticationProcessingFilter</strong></p><blockquote><ul><li>通过 obtainUsername 和 obtainPassword 方法提取出请求里边的用户名/密码出来，提取方式就是 request.getParameter</li><li>获取到请求里传递来的用户名/密码之后，接下来就构造一个 UsernamePasswordAuthenticationToken 对象，传入 username 和 password，username 对应了 UsernamePasswordAuthenticationToken 中的 principal 属性，而 password 则对应了它的 credentials 属性</li><li>接下来 setDetails 方法给 details 属性赋值，UsernamePasswordAuthenticationToken 本身是没有 details 属性的，这个属性在它的父类 AbstractAuthenticationToken 中。details 是一个对象，这个对象里边放的是 WebAuthenticationDetails 实例，该实例主要描述了两个信息，请求的 remoteAddress 以及请求的 sessionId</li><li>最后调用 authenticate 方法去做校验了</li></ul></blockquote><p>仔细来细说一下上面代码中的最后一个方法中的校验：<strong>authenticate</strong> </p><p>校验操作首先要获取到一个 AuthenticationManager：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013100829.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013100829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013100826654"></p><p>这里拿到的是 ProviderManager ，所以接下来我们就进入到 ProviderManager 的 authenticate 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">   Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">   AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">   AuthenticationException parentException = <span class="keyword">null</span>;</span><br><span class="line">   Authentication result = <span class="keyword">null</span>;</span><br><span class="line">   Authentication parentResult = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span></span><br><span class="line">               + provider.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;</span><br><span class="line">         prepareException(e, authentication);</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">         lastException = e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         result = parentResult = parent.authenticate(authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">         lastException = parentException = e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">            &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">         ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parentResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">         eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先获取 authentication 的 Class，判断当前 provider 是否支持该 authentication</li><li>如果支持，则调用 provider 的 authenticate 方法开始做校验，校验完成后，会返回一个新的 Authentication</li><li>这里的 provider 可能有多个，如果 provider 的 authenticate 方法没能正常返回一个 Authentication，则调用 provider 的 parent 的 authenticate 方法继续校验</li><li>copyDetails 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来</li><li>接下来会调用 eraseCredentials 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 credentials 属性置空</li><li>最后通过 publishAuthenticationSuccess 方法将登录成功的事件广播出去</li></ul></blockquote><p>在具体说一下调用 provider 的 authenticate 方法的过程：</p><ul><li>在 for 循环中，第一次拿到的 provider 是一个 AnonymousAuthenticationProvider，这个 provider 压根就不支持 UsernamePasswordAuthenticationToken，也就是会直接在 provider.supports 方法中返回 false，结束 for 循环</li><li>然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。而 parent 就是 ProviderManager，所以会再次回到这个 authenticate 方法中。再次回到 authenticate 方法中，provider 也变成了 DaoAuthenticationProvider，这个 provider 是支持 UsernamePasswordAuthenticationToken 的</li><li>所以会顺利进入到该类的 authenticate 方法去执行，而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider 并且没有重写 authenticate 方法，所以 我们最终来到 AbstractUserDetailsAuthenticationProvider#authenticate 方法中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">   Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,</span><br><span class="line">         () -&gt; messages.getMessage(</span><br><span class="line">               <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Determine username</span></span><br><span class="line">   String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">&quot;NONE_PROVIDED&quot;</span></span><br><span class="line">         : authentication.getName();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">   UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         user = retrieveUser(username,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                  <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> notFound;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Assert.notNull(user,</span><br><span class="line">            <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      preAuthenticationChecks.check(user);</span><br><span class="line">      additionalAuthenticationChecks(user,</span><br><span class="line">            (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">         cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">         user = retrieveUser(username,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">         preAuthenticationChecks.check(user);</span><br><span class="line">         additionalAuthenticationChecks(user,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> exception;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">      principalToReturn = user.getUsername();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先从 Authentication 提取出登录用户名</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等</li><li>additionalAuthenticationChecks 方法则是做密码比对的</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken</li></ul></blockquote><p>整体流程大概如下：</p><img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/Spring%20Security/core-service-Sequence.png" class="lazyload" data-srcset="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/Spring%20Security/core-service-Sequence.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img1" style="zoom:200%;" /><p>图源：<a href="https://niocoder.com/2018/01/02/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80-Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/#%E6%A6%82%E8%BF%B0">Spring Security认证过程</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot真的香系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0019.Remove Nth Node From End of List</title>
      <link href="2020/10/12/0019-Remove-Nth-Node-From-End-of-List/"/>
      <url>2020/10/12/0019-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="19-删除链表的倒数第N个节点-Medium"><a href="#19-删除链表的倒数第N个节点-Medium" class="headerlink" title="19. 删除链表的倒数第N个节点 Medium"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a> <font color="#fd9016" size=5>Medium</font></h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先回忆一下如何删除一个结点，可