{"meta":{"title":"wangba's blogs","subtitle":"","description":"辞去已无年少日,羁绊永结少年心","author":"wangba","url":"http://wangba.me","root":"/"},"pages":[{"title":"about","date":"2020-08-12T01:50:42.000Z","updated":"2020-09-11T12:03:23.090Z","comments":true,"path":"about/index.html","permalink":"http://wangba.me/about/index.html","excerpt":"","text":"👋 &nbsp;Hey there! I’m Wangba😯 About meI’m a student of USTC, I’m a Javaer (Java NO.1 !!!)Welcome to my website: wangba’s blogs or wangba’s blog"},{"title":"categories","date":"2020-08-12T00:57:07.000Z","updated":"2020-09-29T06:10:59.525Z","comments":true,"path":"categories/index.html","permalink":"http://wangba.me/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2020-08-12T00:57:15.000Z","updated":"2020-09-29T06:14:20.312Z","comments":true,"path":"friends/index.html","permalink":"http://wangba.me/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-12T00:56:53.000Z","updated":"2020-09-29T06:11:31.657Z","comments":true,"path":"tags/index.html","permalink":"http://wangba.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Queue","slug":"Queue","date":"2020-11-24T12:38:44.000Z","updated":"2020-11-24T13:20:13.680Z","comments":true,"path":"2020/11/24/Queue/","link":"","permalink":"http://wangba.me/2020/11/24/Queue/","excerpt":"","text":"一、OverView在前面已经看过受限的线性序列：栈 在本章中可以看一下另外一个受限的线性序列：队列 在本章中可以看到： 🐢 : 首先对比一下栈，并介绍一下队列的特性 🐷 : 在这一小节中分别用数组和链表实现一下队列，主要是用数组实现 🐭 : 在这一小节主要介绍一下几个特殊的队列，其中主要是优先队列和双端队列 🐂 : 由于在 Java 中，队列是一个接口，简单看一下实现类 二、特性首先来回忆一下栈的特性：先进后出，后进先出 而队列的特性就是：先进先出，后进后出 可以看一下下面的例子： 字符串 “wang” 依次入队，随后再出队（省略部分步骤） 三、实现队列3.1 数组实现首先我们要知道有哪些操作： 只在队尾进行入队的操作：enqueue 只在队头进行出队的操作：dequeue 1234567891011121314151617181920212223242526272829303132public class LC0000ArrayQueue &#123; private String[] elements; private int capacity = 0; private int front = 0; private int tail = 0; public LC0000ArrayQueue(int n) &#123; elements = new String[n]; capacity = n; &#125; // enqueue public boolean enqueue(String element) &#123; if (tail == capacity) return false; elements[tail] = element; tail++; return true; &#125; // dequeue public String dequeue() &#123; if (front == tail) return null; String res = elements[front]; front++; return res; &#125;&#125; 但是仔细想想这个是有问题的，就拿上面那个例子来说，它全部入队和全部出队后的结果应该是这样： 那么左边的空间就没有再使用了，如何解决这个问题呢？来考虑一下在数组中是如何解决这个问题，数组中删除一个元素，然后移动把这个元素后的所有数据都向前移动一位。 那么在这里只需要出队一个元素，随后把所有元素向前移动一位即可。但是这个每出队一个元素就移动一位，时间复杂度为 O(n)，稍微优化一下，只在我们需要它的时候才进行移动操作。那么我们什么时候是需要到这些空余的空间呢，是不是只有在元素入队的时候才需要，所以只需要在入队的时候进行数据搬移的操作即可，代码如下： 123456789101112131415// enqueuepublic boolean enqueue(String element) &#123; if (tail == capacity) &#123; // queue is full if (front == 0) return false; for (int i = front; i &lt; elements.length; i++) &#123; elements[i - front] = elements[i]; &#125; tail -= front; front = 0; &#125; elements[tail] = element; tail++; return true;&#125; 首先要判断一下队列是不是真的满了 如果不是满的，就可以将 front 到 tail 的元素全部搬到 0 到 tail - front 的位置 3.2 链表实现用链表实现的话，就不用考虑 capacity 的问题了，理论上在内存足够的情况下，可以无限入队， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LC0000LinkedListQueue &#123; private Node front; private Node tail; // enqueue public void enqueue(String element) &#123; if (tail == null) &#123; Node next = new Node(element, null); front = next; tail = next; &#125; else &#123; tail.next = new Node(element, null); tail = tail.next; &#125; &#125; // dequeue public String dequeue() &#123; if (front == tail) return null; String res = front.val; front = front.next; if (front == null) &#123; tail = null; &#125; return res; &#125;&#125;class Node &#123; public String val; public Node next; public Node(String val) &#123; this.val = val; &#125; Node(String val, Node next) &#123; this.val = val; this.next = next; &#125;&#125; 四、一些特殊的队列4.1 循环队列在上面用数组实现队列时，由于队列的特性使得我们已经将其进行了一次优化，在每次进行入队操作时都要有条件的进行一次数据移动操作，时间复杂度为 O(n)，那有没有能将这个时间复杂度也省去的队列操作呢？这就是本小节介绍的一种特殊的队列：循环队列 顾名思义，这种队列最大的特点就在于 循环 二字，那到底要如何实现这个循环呢，让我们来看个例子： 我们正常情况下，空余的空间就是左边那部分空白，如果我们能实现直接将新加入的元素直接放入左边空白的空间不就行了吗？那么用什么操作才能达到这样的效果呢，使用 取余 这个数学操作即可。 看起来的确是很 easy ，只要将 tail = (tail + 1) % capacity 即可，但是事实真的如此吗？ 在前面使用数组实现队列时，我们对栈空和栈满的判断是这样的 栈空：front == tail 栈满：tail == capacity 那在循环队列中，我们应该如何实现这两个判断呢？还是举个例子，为了更加方便理解，我将数组的首尾相连，本质是还是一个数组： 栈空：front == tail 栈满：在循环队列中用 tail == capacity 判断栈满肯定不在合适。在上面右图中，我们可以看到该循环栈还没有满，我们尝试在其中再增加一个元素，那么栈满的判断就变成了 front == tail ，这就和判断栈空一样了，所以在循环队列中，我们总是会浪费一个空间，即 tail 指向的的数据为空，也就是上面右图这样的情况，那么此时判断栈满的条件就变成了： (tail + 1) % capacity == front 上代码： 123456789101112131415161718192021222324252627282930313233public class LC0000CycleQueue &#123; private String[] elements; private int capacity = 0; private int front = 0; private int tail = 0; public LC0000CycleQueue(int n) &#123; elements = new String[n]; capacity = n; &#125; // enqueue public boolean enqueue(String element) &#123; // judging queue is full if ((tail + 1) % capacity == front) return false; elements[tail] = element; tail = (tail + 1) % capacity; return true; &#125; // dequeue public String dequeue() &#123; // judging queue is empty if (front == tail) return null; String res = elements[front]; front = (front + 1) % capacity; return res; &#125;&#125; 4.2 优先队列这一小节介绍一下另一种特殊的队列：优先队列。老规矩，先说一下特性： 本质上还是队列，所以队列该有的操作它都有 但是它的 enqueue 和 dequeue 的操作结果可能与正常的队列结果不一样： enqueue : 插入一个元素 dequeue : 删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素） 优先队列的主要操作： 优先队列是元素的容器，每个元素有一个相关的键值； insert(key, data)：插入键值为key的数据到优先队列中，元素以其key进行排序； deleteMin/deleteMax：删除并返回最小/最大键值的元素； getMinimum/getMaximum：返回最小/最大剑指的元素，但不删除它； 优先队列的辅助操作： 第k最小/第k最大：返回优先队列中键值为第k个最小/最大的元素； 大小（size）：返回优先队列中的元素个数； 堆排序（Heap Sort）：基于键值的优先级将优先队列中的元素进行排序； 优先队列基于什么实现最好？ 实现 插入 删除 寻找最小值 无序数组 1 n n 无序链表 1 n n 有序数组 n 1 1 有序链表 n 1 1 二叉搜索树 logn(平均) logn(平均) logn(平均) 平衡二叉搜索树 logn logn logn 二叉堆 logn logn 1 可以看到一般的优先队列都是基于 二叉堆 实现，具体如何实现暂时不细讲，等到写到二叉堆的时候提及一下 在 LeetCode 中关于优先队列的题目也不少，最经典的就是 0023. Merge k Sorted Lists ，具体解法可以看下 0023. Merge k Sorted Lists 中的解法三，还有比较经典的 0215、0239、0264、0295、0347、0692 等等 五、Java 中的队列在 Java 中，队列只是一个接口，如下： 让我们来看看里面的具体实现类吧，这里优先选择上面优先队列，继承和实现类图如下： 在优先队列的 Structure 中可以看到： 可以看到最关键的两个方法： offer 和 remove，其中 add 是调用 offer 方法的，这两个就是对应着队列中的 enqueue 和 dequeue 方法。 由于优先队列是基于二叉堆的，所以会有 上浮 和 下沉 操作，在此就不细说了 1234567891011121314public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true;&#125; 123456789public boolean remove(Object o) &#123; int i = indexOf(o); if (i == -1) return false; else &#123; removeAt(i); return true; &#125;&#125; 123456789101112131415161718private E removeAt(int i) &#123; // assert i &gt;= 0 &amp;&amp; i &lt; size; modCount++; int s = --size; if (s == i) // removed last element queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved); if (queue[i] == moved) &#123; siftUp(i, moved); if (queue[i] != moved) return moved; &#125; &#125; return null;&#125;","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"},{"name":"Queue","slug":"Queue","permalink":"http://wangba.me/tags/Queue/"}]},{"title":"Stack--Monotonic Stack","slug":"Stack-Monotonic-Stack","date":"2020-11-23T13:03:24.000Z","updated":"2020-11-23T13:05:11.287Z","comments":true,"path":"2020/11/23/Stack-Monotonic-Stack/","link":"","permalink":"http://wangba.me/2020/11/23/Stack-Monotonic-Stack/","excerpt":"","text":"一、OverView在前面已经提及过 栈 这个数据结构，在 LeetCode 中有考察过这样一种栈操作：单调栈。 顾名思义，这是在栈的基础上达到单调递增或单调递减的效果。 大概的过程如下： 如果想达到递增的效果： 进栈：首先要比较与栈顶的大小，如果比栈顶元素大，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较 出栈：直接出栈即可 如果想达到递减的效果： 进栈：首先要比较与栈顶的大小，如果比栈顶元素小，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较 出栈：直接出栈即可 二、Example假如有下面的例子： 有一组数为： 1，4，2，5，7，6，8 现在要得到一个单调递增栈，过程如下： Step Op Stack 1 1 push 1 2 4 push 1 4 3 4 pop | 2 push 1 2 4 5 push 1 2 5 5 7 push 1 2 5 7 6 7 pop | 6 push 1 2 5 6 7 8 push 1 2 5 6 8 三、LeetCode 496看一个典型例子 LeetCode 0496 : 题意：给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 12Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].Output: [-1,3,-1] 分析： 123456789101112131415161718192021public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; int[] res = new int[nums1.length]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i : nums2) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; i) &#123; map.put(stack.peek(), i); stack.pop(); &#125; stack.push(i); &#125; for (int i = 0; i &lt; nums1.length; i++) &#123; res[i] = map.get(nums1[i]) != null ? map.get(nums1[i]) : -1; &#125; return res;&#125;","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"}]},{"title":"0084. Largest Rectangle in Histogram","slug":"0084-Largest-Rectangle-in-Histogram","date":"2020-11-02T11:46:08.000Z","updated":"2020-11-05T13:41:39.555Z","comments":true,"path":"2020/11/02/0084-Largest-Rectangle-in-Histogram/","link":"","permalink":"http://wangba.me/2020/11/02/0084-Largest-Rectangle-in-Histogram/","excerpt":"","text":"84. Largest Rectangle in Histogram HardGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 12Input: [2,1,5,6,2,3]Output: 10 思路：思路一：暴力破解 先用 HashSet 存储数组中不重复的值，主要是用来加速的，不用也可以，像在本题里面就可以少算一次 2 然后遍历这个 set，再在 set 中进行数组遍历，找到连续比当前值大于或等于的数组值，并找到最大的宽度，像在上面的🌰中，当值为 1 时，遍历一遍后，最大的的宽度为 6 代码： 12345678910111213141516171819202122public int largestRectangleArea(int[] heights) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int height : heights) &#123; set.add(height); &#125; int res = 0; for (int height : set) &#123; int width = 0; int max = 1; for (int value : heights) &#123; if (value &gt;= height) &#123; width++; &#125; else &#123; max = Math.max(max, width); width = 0; &#125; &#125; max = Math.max(max, width); res = Math.max(res, max * (height)); &#125; return res;&#125; 时间复杂度：O(n^2) 空间复杂度：O(n) 思路二：这个思路有点和 42题 有点像，可以看下面的🌰： 在思路一中，是将每一个不重复的数组元素和整个数组进行对比，求出最大面积 在 该解法中，仍然是求每个柱子所占的最大面积，最后取最大的即可 红色是当前柱子，分别找到离该柱子左边最近比该柱子低的柱子 leftMin 和右边最近低于该柱子的柱子 rightMin 此时的面积可以计算为：heights[cur] * ( rightMin - leftMin -1) 那么如何求出每一个柱子的 leftMin ，下面的代码是时间复杂度为 O(n) 123456789int[] leftMin = new int[heights.length];leftMin[0] = -1;for (int i = 1; i &lt; heights.length; i++) &#123; int temp = i - 1; while (temp &gt;= 0 &amp;&amp; heights[i] &lt;= heights[temp]) &#123; temp--; &#125; leftMin[i] = temp;&#125; 当然上面的代码是可以降低时间复杂度的，可以看下面这个🌰： 如果我们要求 cur 的 leftMin ，可以放弃一部分比较，具体是哪一部分呢？ 如果当前 cur 高度小于 cur - 1 ，那么 leftMin[i - 1] + 1 到 cur - 1 之间所有柱子的高度都是大于 cur 的，因为 leftMin[i - 1] 是第一个比 cur - 1 低的 123456789int[] leftMin = new int[heights.length];leftMin[0] = -1;for (int i = 1; i &lt; heights.length; i++) &#123; int temp = i - 1; while (temp &gt;= 0 &amp;&amp; heights[temp] &gt;= heights[i]) &#123; temp = leftMin[temp]; &#125; leftMin[i] = temp;&#125; 代码： 12345678910111213141516171819202122232425262728293031public int largestRectangleArea(int[] heights) &#123; if (heights.length == 0) return 0; int[] leftMin = new int[heights.length]; leftMin[0] = -1; for (int i = 1; i &lt; heights.length; i++) &#123; int temp = i - 1; while (temp &gt;= 0 &amp;&amp; heights[temp] &gt;= heights[i]) &#123; temp = leftMin[temp]; &#125; leftMin[i] = temp; &#125; int[] rightMin = new int[heights.length]; rightMin[heights.length - 1] = heights.length; for (int i = heights.length - 2; i &gt;= 0; i--) &#123; int temp = i + 1; while (temp &lt;= heights.length -1 &amp;&amp; heights[temp] &gt;= heights[i]) &#123; temp = rightMin[temp]; &#125; rightMin[i] = temp; &#125; int max = 0; for (int i = 0; i &lt; heights.length; i++) &#123; int temp = (rightMin[i] - leftMin[i] - 1) * heights[i]; max = Math.max(max, temp); &#125; return max;&#125; 思路三：栈 当遍历到 cur 时，出现 height[cur] &lt; height[peek] 时，那么 leftMin 一定是 newPeek ，rightMin 就是 cur ，此时面积最大值就是 (cur - leftMin - 1) * height[peek] 代码： 1234567891011121314151617181920212223242526272829303132public int largestRectangleArea(int[] heights) &#123; int max = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int i = 0; while (i &lt; heights.length) &#123; if (stack.isEmpty()) &#123; stack.push(i); i++; &#125; else &#123; int peek = stack.peek(); if (heights[i] &gt;= heights[peek]) &#123; stack.push(i); i++; &#125; else &#123; int height = heights[stack.pop()]; int leftMin = stack.isEmpty() ? -1 : stack.peek(); int area = (i - leftMin - 1) * height; max = Math.max(area, max); &#125; &#125; &#125; while (!stack.isEmpty()) &#123; int height = heights[stack.pop()]; int leftMin = stack.isEmpty() ? -1 : stack.peek(); int area = (heights.length - leftMin - 1) * height; max = Math.max(area, max); &#125; return max;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"}]},{"title":"0071. Simplify Path","slug":"0071-Simplify-Path","date":"2020-10-30T12:51:58.000Z","updated":"2020-10-30T12:54:07.707Z","comments":true,"path":"2020/10/30/0071-Simplify-Path/","link":"","permalink":"http://wangba.me/2020/10/30/0071-Simplify-Path/","excerpt":"","text":"71. Simplify Path MediumGiven an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path. Example 1: 123Input: &quot;&#x2F;home&#x2F;&quot;Output: &quot;&#x2F;home&quot;Explanation: Note that there is no trailing slash after the last directory name. Example 2: 123Input: &quot;&#x2F;..&#x2F;&quot;Output: &quot;&#x2F;&quot;Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: 123Input: &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;Output: &quot;&#x2F;home&#x2F;foo&quot;Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: 12Input: &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;Output: &quot;&#x2F;c&quot; Example 5: 12Input: &quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;Output: &quot;&#x2F;c&quot; Example 6: 12Input: &quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;Output: &quot;&#x2F;a&#x2F;b&#x2F;c&quot; 思路：思路一：栈这两个思路是一样的，只是分别使用数组和栈而已 首先从 / 分开，然后用栈保存，如果栈不为空，且当前字符为 .. 说明要进行进入上层目录，此时将栈中的元素弹出 只要不为空、不为 . 、不为 .. ，就把其中的元素放入栈中即可 最后在最前面和每个字符串中间加上 / 代码： 123456789101112131415public String simplifyPath(String path) &#123; // 1. Stack String[] split = path.split(&quot;/&quot;); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String s : split) &#123; if (!stack.isEmpty() &amp;&amp; &quot;..&quot;.equals(s)) &#123; stack.pop(); &#125; else if (!&quot;.&quot;.equals(s) &amp;&amp; !&quot;&quot;.equals(s) &amp;&amp; !&quot;..&quot;.equals(s)) &#123; stack.push(s); &#125; &#125; List&lt;String&gt; res = new ArrayList&lt;&gt;(stack); return &quot;/&quot; + String.join(&quot;/&quot;, res);&#125; 时间复杂度：O(n) 空间复杂度：O(n) 思路二：纯数组代码： 123456789101112131415161718192021public String simplifyPath(String path) &#123; String[] split = path.split(&quot;/&quot;); List&lt;String&gt; wordList = new ArrayList&lt;&gt;(); for (String s : split) &#123; if (s.isEmpty() || s.equals(&quot;.&quot;)) &#123; continue; &#125; wordList.add(s); &#125; List&lt;String&gt; wordListSim = new ArrayList&lt;&gt;(); for (String s : wordList) &#123; if (s.equals(&quot;..&quot;)) &#123; if (!wordListSim.isEmpty()) &#123; wordListSim.remove(wordListSim.size() - 1); &#125; &#125; else &#123; wordListSim.add(s); &#125; &#125; return &quot;/&quot; + String.join(&quot;/&quot;, wordListSim);&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"}]},{"title":"something need to learn or write","slug":"something-need-to-learn-or-write","date":"2020-10-29T12:52:01.000Z","updated":"2020-10-29T12:57:05.570Z","comments":true,"path":"2020/10/29/something-need-to-learn-or-write/","link":"","permalink":"http://wangba.me/2020/10/29/something-need-to-learn-or-write/","excerpt":"","text":"Java 实体类使用 java.x 的 valiation 和 hibernate 的 validator 进行校验 Spring Data JPA 的更深入使用 Shiro 或者 Spring Security 整合 JWT mapstruct 和 beansUtils 的类自动赋值 Java 8-13 中的一些新特性 前后端分离中的异常处理 前端 哈佛的 CS 50 课程 从零搭建一个 Hexo 主题 Leetcode 数组 链表 栈","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://wangba.me/tags/Life/"}]},{"title":"0042. Trapping Rain Water","slug":"0042-Trapping-Rain-Water","date":"2020-10-28T13:42:11.000Z","updated":"2020-10-30T12:52:56.056Z","comments":true,"path":"2020/10/28/0042-Trapping-Rain-Water/","link":"","permalink":"http://wangba.me/2020/10/28/0042-Trapping-Rain-Water/","excerpt":"","text":"42. Trapping Rain Water HardGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1: 123Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: 12Input: height &#x3D; [4,2,0,3,2,5]Output: 9 Constraints: n == height.length 0 &lt;= n &lt;= 3 * 104 0 &lt;= height[i] &lt;= 105 思路：思路一：行求解每次求一行的所有水： 首先要标记是否开始，只要第一次出现 height[i] &gt;= 当前层次的值时，才开始计数，因为它左边没有墙 代码： 123456789101112131415161718192021222324public int trap(int[] height) &#123; // find the maximum num in the height int max = Integer.MIN_VALUE; for (int i : height) &#123; if (i &gt; max) max = i; &#125; int res = 0; for (int i = 1; i &lt;= max; i++) &#123; int count = 0; boolean start = false; for (int value : height) &#123; if (start &amp;&amp; value &lt; i) &#123; count++; &#125; if (value &gt;= i) &#123; res += count; count = 0; start = true; &#125; &#125; &#125; return res;&#125; 时间复杂度：O(n * m) 其中 n 为数组长度，m 为数组中最大的值 空间复杂度：O(1) 思路二：列求解 只要关注于每一列就行，且关注该列的左边最高列和右边最高列 如何求解该列的水，只需要将这左右高列中较低的那个减去当前的列的高度即可 代码： 12345678910111213141516171819202122public int trap(int[] height) &#123; // 2. column int count = 0; for (int i = 0; i &lt; height.length; i++) &#123; int minColumn = getMinColumn(i, height); if (minColumn &gt; height[i]) &#123; count += (minColumn - height[i]); &#125; &#125; return count;&#125;private int getMinColumn(int index, int[] height) &#123; int left = 0, right = 0; for (int i = 0; i &lt; index; i++) &#123; if (height[i] &gt; left) left = height[i]; &#125; for (int i = index + 1; i &lt; height.length; i++) &#123; if (height[i] &gt; right) right = height[i]; &#125; return Math.min(left, right);&#125; 时间复杂度：O(n^2) 空间复杂度：O(1) 思路三：栈可以想象为括号匹配：其中墙可以看作括号，水可以看作括号匹配的中间计算 代码： 12345678910111213141516171819public int trap(int[] height) &#123; // 3. Stack Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; int cur = 0; while (cur &lt; height.length) &#123; while (!stack.isEmpty() &amp;&amp; height[cur] &gt; height[stack.peek()]) &#123; int temp = height[stack.peek()]; stack.pop(); if (stack.isEmpty()) break; int len = cur - stack.peek() - 1; int min = Math.min(height[cur], height[stack.peek()]); res += (min - temp) * len; &#125; stack.push(cur); cur++; &#125; return res;&#125; 思路四：动态规划在思路二中，是使用没次找一个数，都要遍历整个数组找到左边和右边的最高列，然后进行计算，在这个基础上，使用一个 dp 数组将这些值维护起来： 第 i 列的左边最高列和右边最高列应该为： left[i] = max(left[i - 1], height[i - 1]) right[i] = max(right[i + 1], height[i + 1]) 这样用两个数组去维护就行了，每次遍历的时候直接在这个 dp 数组中取就行了 代码： 1234567891011121314151617181920212223public int trap(int[] height) &#123; int res = 0; int[] left = new int[height.length]; int[] right = new int[height.length]; // use array to save the maximum left num of every item for (int i = 1; i &lt; height.length - 1; i++) &#123; left[i] = Math.max(left[i - 1], height[i - 1]); &#125; // use array to save the maximum right num of every item for (int i = height.length - 2; i &gt;= 0; i--) &#123; right[i] = Math.max(right[i + 1], height[i + 1]); &#125; for (int i = 0; i &lt; height.length; i++) &#123; int minColumn = Math.min(left[i], right[i]); if (minColumn &gt; height[i]) &#123; res += minColumn - height[i]; &#125; &#125; return res;&#125; 时间复杂度：O(n） 空间复杂度：O(n) 思路五：动态规划 + 双指针在思路四中，已经使用 dp 数组去存储左边和右边的最高列，但是仔细思考一下，这个 dp 数组中的值，其实就使用一次，那么可以将这个空间复杂度再降低一点，有点类似于用动态规划求解斐波那契数列 代码： 123456789101112131415161718public int trap(int[] height) &#123; int res = 0, l = 0, r = height.length - 1; while (l &lt; r) &#123; int mn = Math.min(height[l], height[r]); if (height[l] == mn) &#123; ++l; while (l &lt; r &amp;&amp; height[l] &lt; mn) &#123; res += mn - height[l++]; &#125; &#125; else &#123; --r; while (l &lt; r &amp;&amp; height[r] &lt; mn) &#123; res += mn - height[r--]; &#125; &#125; &#125; return res;&#125; 时间复杂度：O(n） 空间复杂度：O(1)","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"}]},{"title":"0020. Valid Parentheses","slug":"0020-Valid-Parentheses","date":"2020-10-28T13:41:57.000Z","updated":"2020-10-30T12:53:03.967Z","comments":true,"path":"2020/10/28/0020-Valid-Parentheses/","link":"","permalink":"http://wangba.me/2020/10/28/0020-Valid-Parentheses/","excerpt":"","text":"20. Valid Parentheses EasyGiven a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: 12Input: s &#x3D; &quot;()&quot;Output: true Example 2: 12Input: s &#x3D; &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: s &#x3D; &quot;(]&quot;Output: false Example 4: 12Input: s &#x3D; &quot;([)]&quot;Output: false Example 5: 12Input: s &#x3D; &quot;&#123;[]&#125;&quot;Output: true Constraints: 1 &lt;= s.length &lt;= 104 s consists of parentheses only &#39;()[]&#123;&#125;&#39;. 思路：思路一：栈在栈的那一节中，就提及到了栈的其中一个应用就是括号匹配，大致思路如下： 遇到 (、 &#123;、 [ 这三种左括号，直接让它入栈，直到出现 ）、 &#125;、 ] ，首先判断栈是否为空或者栈顶的元素是否对应，如果对应，那么让它出栈，继续上述操作即可 代码： 1234567891011121314151617public boolean isValid(String s) &#123; if (s == null || s.length() == 0) return true; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char temp = s.charAt(i); if (temp != &#x27;)&#x27; &amp;&amp; temp != &#x27;]&#x27; &amp;&amp; temp != &#x27;&#125;&#x27;) &#123; stack.push(s.charAt(i)); &#125; else if (temp == &#x27;)&#x27; &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == &#x27;(&#x27; || temp == &#x27;]&#x27; &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == &#x27;[&#x27; || temp == &#x27;&#125;&#x27; &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == &#x27;&#123;&#x27;) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; return stack.isEmpty();&#125; 时间复杂度：O(n) 空间复杂度：O(n) 还看到了一种反向写法 代码： 12345678910111213public boolean isValid(String s) &#123; if(s.isEmpty()) &#123; return true; &#125; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(char c:s.toCharArray())&#123; if(c == &#x27;(&#x27;) &#123; stack.push(&#x27;)&#x27;); &#125; else if(c == &#x27;[&#x27;) &#123; stack.push(&#x27;]&#x27;); &#125; else if(c == &#x27;&#123;&#x27;) &#123; stack.push(&#x27;&#125;&#x27;); &#125; else if(stack.isEmpty() || stack.pop() != c)&#123; return false; &#125; &#125; return stack.isEmpty();&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"}]},{"title":"Stack","slug":"Stack","date":"2020-10-27T14:01:27.000Z","updated":"2020-11-23T10:57:46.252Z","comments":true,"path":"2020/10/27/Stack/","link":"","permalink":"http://wangba.me/2020/10/27/Stack/","excerpt":"","text":"一、OverView 快速预览： 🐷：第一小节看一下栈的特性，为什么会有这种受限的数据结构的出现？ 🐢：第二小节看一下要实现一个栈，最基本需要什么操作？ 🐭：第三小节看一下栈的的应用，是不是这些应用驱动着栈的诞生 🐦：最后一个小节还是老套路，简单的看一下 Java 中关于栈的 API 二、特性​ 在前面已经介绍了数组和链表两种最基本的数据结构，可以说他俩就是整个数据结构与算法的基石。看一下栈的组成： 那么它和其他线性表最大的区别在哪呢？毫无疑问：它只允许在一端进行插入和删除 或者说成 先进后出、后进先出 此时，小朋友，你是否有很多问号？为什么要有这种受限的数据结构，我用数组和链表不香吗？当然栈就是基于数组或链表实现的，但是在特定的需求下，栈就应用而生了。具体可以参考下面的栈的应用和 Java 中栈，就可以看到在某些情况下栈的优势、以及由于数组和链表暴露出太多的接口，而栈只需要其中的一小部分就可以了 三、实现栈我们在上面就提到了，栈既可以基于数组实现，也可以基于链表实现。栈最重要的两个操作：入栈 和 出栈 3.1 定容栈这是《算法》中文版中的译名，顾名思义就是容量固定的栈，基于数组并用 Java 代码来实现一下： 12345678910111213141516171819202122232425262728public class FixedCapacityStackOfString &#123; private String[] items; private int count; private int n; public FixedCapacityStackOfString(int n) &#123; this.items = new String[n]; this.count = 0; this.n = n; &#125; // 入栈 private boolean push(String item) &#123; if (count == n) return false; items[count] = item; count++; return true; &#125; // 出栈 private String pop() &#123; if (count == 0) return null; String item = items[count - 1]; count--; return item; &#125;&#125; 时间复杂度：O(1) 空间复杂度：O(1) 不包含该栈本身，操作时的空间复杂度 3.2 扩容栈在上面的定容栈中，是用一个固定大小的数组当成实现栈的结构，那么应该如何实现一个扩容栈呢？ 其实也很好实现，回忆一下动态数组的事项，是将数组进行扩容，然后将原来的数据 copy 进去就行了；那么用同样的方式对基于数组的栈进行扩容 (当然基于链表实现的栈就没有这一概念，理论上只要内存空间足够大，栈可以无限大) 当栈满的时候，进行扩容：新建一个比现在大的数组 将原来栈中的数据全部复制到新的数组中 具体实现可以参考下面的第五小节 四、栈的应用4.1 撤销操作​ 如果你经常使用 command + Z 或者 ctrl + Z，你可能会非常理解这个操作：当我们复制或者修改了一个文件，我们想把它恢复成复制或修改之前的一样的状态，只需要按上面的快捷键就行了，仔细想一下是否有栈的影子在里面 就如同上面这个例子：我们写到了 wangba，随后又不想要 wangba 了，此时进行撤销操作，只需要将栈中的 wangba pop 就可以了，有的还有前进功能，此时只需要将其 push 进来即可 4.2 函数调用​ 如果了解过操作系统或者听说过函数调用，那么可以更容易理解下面的内容，在计算机中，操作系统会给每个线程分配一个内存空间，而这个内存空间就是栈式结构，专门为函数调用存储临时变量，就例如下面的例子： 123456789public static void main(String[] args)&#123; int a = 1, b = 2; int res = add(a, b); System.out.println(res);&#125;private static Integer add(int x, int y) &#123; return x + y;&#125; 在上面这段 Java 代码中，可以看见在 main 中调用了 add 函数，在栈帧中应该就是这样： 当然，真实情况不是这样的，要是这么简单，计算机底层就不会这么劝退了 ～～～ 如果有兴趣了解更深可以参考：《深入理解计算机系统》或者想大概了解一下可以参考 这个 4.3 表达式求值🐢：在编译器中是如何对表达式进行求值的呢？如果是后缀表达式就只需要一个操作栈即可；如果是前缀或中缀表达式则需要一个操作数栈和一个操作符栈，来看一下中缀表达式的求值过程： a * (b + c) 过程大概如下： 遇到操作数就压到操作数的栈；遇到操作符就压到操作符的栈 在压到操作符的栈是有条件的：如果操作符栈顶的符号的优先级大于等于要压入的符号，那就取操作数栈顶的两个数进行计算；如果小于则直接把操作符压入操作符的栈 4.4 括号匹配关于括号匹配可以参考 LeetCode 0020，关于这题的解答可以看 0020. Valid Parentheses 五、Java中的栈首先看一下继承与实现的关系： 再看一下该类中的 Structure : 可以看出来很简单，就如同上面在定容栈中的操作差不多，实际上差的很多，要考虑到扩容、并发等等情况，操作大都是在他的父类 Vertor 中完成，如果你看过面经啥的，你应该就听过并发不要使用 Vertor，要多使用 JUC 包下面的类，然后究其原因就是：Vertor 使用 synchronized 关键字，JUC 包下的是使用 ReentrantLock，而可重入锁的底层则是 AQS LeetCode 重点关于栈的重点：Monotonic Stack","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"}]},{"title":"148. SortList","slug":"148-SortList","date":"2020-10-26T11:16:05.000Z","updated":"2020-10-26T11:17:39.094Z","comments":true,"path":"2020/10/26/148-SortList/","link":"","permalink":"http://wangba.me/2020/10/26/148-SortList/","excerpt":"","text":"148. Sort List MediumGiven the head of a linked list, return the list after sorting it in ascending order. Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)? Example 1: 12Input: head &#x3D; [4,2,1,3]Output: [1,2,3,4] Example 2: 12Input: head &#x3D; [-1,5,3,4,0]Output: [-1,0,3,4,5] Example 3: 12Input: head &#x3D; []Output: [] Constraints: The number of nodes in the list is in the range [0, 5 * 104]. -105 &lt;= Node.val &lt;= 105 思路：思路一：递归法 归并排序 找链表中点 哨兵 本题是一个无序链表的排序问题，要求是空间复杂度为 O(nlogn) ，那只能想到快速排序、归并排序、堆排序，快排上通过索引的，不适合用在链表中；堆排序新建结点中；这题可采用归并排序，在 21题 中介绍了合并两个有序列表，现在只是一个无序链表，没有条件创造条件： 两个链表：找到链表中点，切断 有序：一个无序链表切开后，变成了两个无序链表，再对每一个链表进行递归，当只有一个结点，自然就是有序的了 代码： 1234567891011121314151617181920212223242526272829public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode slow = head, fast = head, pre = head; while (fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return mergeTwoLists(sortList(head), sortList(slow));&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; cur.next = l1; l1 = l1.next; &#125; else &#123; cur.next = l2; l2 = l2.next; &#125; cur = cur.next; &#125; if (l1 != null) cur.next = l1; if (l2 != null) cur.next = l2; return dummy.next;&#125; 时间复杂度：O(nlogn) 空间复杂度：O(1) 其实并不是 1 ，由于递归要调用栈","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"147. Insertion Sort List","slug":"147-Insertion-Sort-List","date":"2020-10-23T13:28:07.000Z","updated":"2020-10-23T13:29:30.064Z","comments":true,"path":"2020/10/23/147-Insertion-Sort-List/","link":"","permalink":"http://wangba.me/2020/10/23/147-Insertion-Sort-List/","excerpt":"","text":"147. Insertion Sort List MediumSort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 思路：思路一：插入排序按照插入排序的思想，要注意的点： 不要断链 每一次都是从头开始进行比较 代码： 12345678910111213141516171819202122public ListNode insertionSortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode res = new ListNode(0); ListNode pre = res; ListNode cur = head; ListNode next = null; while (cur != null) &#123; next = cur.next; while (pre.next != null &amp;&amp; pre.next.val &lt; cur.val) &#123; pre = pre.next; &#125; cur.next = pre.next; pre.next = cur; // 从头开始 pre = res; cur = next; &#125; return res.next;&#125; 时间复杂度：O(n^2) 空间复杂度：O(1)","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"143. Reorder List","slug":"143-Reorder-List","date":"2020-10-22T13:26:16.000Z","updated":"2020-10-22T13:30:43.420Z","comments":true,"path":"2020/10/22/143-Reorder-List/","link":"","permalink":"http://wangba.me/2020/10/22/143-Reorder-List/","excerpt":"","text":"143. Reorder List MediumGiven a singly linked list L: L0→L1→…→L**n-1→Ln,reorder it to: L0→L**n→L1→L**n-1→L2→L**n-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 1Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: 1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 思路：思路一：暴力解法直接将链表存在数组中，然后进行操作，不用考虑断链等问题，直接用数组下标解决一切 代码： 1234567891011121314151617181920212223public void reorderList(ListNode head) &#123; // Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. // 1. 暴力解法 if (head == null) return; List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); while (head != null) &#123; list.add(head); head = head.next; &#125; int i = 0, j = list.size() - 1; while (i &lt; j) &#123; list.get(i).next = list.get(j); i++; if (i == j) &#123; break; &#125; list.get(j).next = list.get(i); j--; &#125; list.get(j).next = null;&#125; 时间复杂度：O(n) 空间复杂度：O(n) 思路二：递归看到递归还是要想到两个方面的问题： 出口 调用递归函数的统一操作 首先要明确递归传出来的是啥，为什么使用思路一的想法就是，我想找最后一个元素，但是每次都要遍历一遍才能找到那个元素，所以使用了数组，通过下标获取其中的元素。所以，我们应该递归出来的局部链表的尾元素，看下面的🌰： 现在递归到出口，那么我们应该将 tail 传出来 第二，本题的出口要分为两种情况：奇数个和偶数 奇数：直接传出来 偶数：将它的 next 传出来 代码： 12345678910111213141516171819202122232425262728293031public void reorderList(ListNode head) &#123; // Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. // 2. 递归法 if (head == null || head.next == null) return; int len = 0; ListNode count = head; while (count != null) &#123; count = count.next; len++; &#125; helper(head, len);&#125;private ListNode helper(ListNode listNode, int length) &#123; if (length == 1) &#123; ListNode tail = listNode.next; listNode.next = null; return tail; &#125; if (length == 2) &#123; ListNode tail = listNode.next.next; listNode.next.next = null; return tail; &#125; ListNode helper = helper(listNode.next, length - 2); ListNode cur = listNode.next; ListNode next = helper.next; listNode.next = helper; helper.next = cur; return next;&#125; 思路三：分组解法还可以将这个题分为以下几个部分： 找到中点，分割成两个链表 对后一个链表进行逆序 双指针同步进行，将后面链表与前面的链表进行连接 123456781 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6分割：1 -&gt; 2 -&gt; 3 4 -&gt; 5 -&gt; 6 逆序：6 -&gt; 5 -&gt; 4 连接：1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 代码： 12345678910111213141516171819202122232425262728293031public void reorderList(ListNode head) &#123; // Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. if (head == null || head.next == null) return; ListNode slow = head, fast = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; ListNode cur = slow.next; slow.next = null; ListNode next = reverseList(cur); while (head != null &amp;&amp; next != null) &#123; ListNode l1 = head.next; ListNode l2 = next.next; head.next = next; next.next = l1; head = l1; next = l2; &#125;&#125;private ListNode reverseList(ListNode head) &#123; // 递归法 if (head == null || head.next == null) &#123; return head; &#125; ListNode listNode = reverseList(head.next); head.next.next = head; head.next = null; return listNode;&#125; 时间复杂度：O(n) 空间复杂度：O(1) 注：在 LeetCode 中，递归法时间复杂度可以 beats 100%，第三种方法不可以，按照分析来说，应该是一样的","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"142. Linked List Cycle II","slug":"142-Linked-List-Cycle-II","date":"2020-10-22T13:25:28.000Z","updated":"2020-10-22T13:29:22.519Z","comments":true,"path":"2020/10/22/142-Linked-List-Cycle-II/","link":"","permalink":"http://wangba.me/2020/10/22/142-Linked-List-Cycle-II/","excerpt":"","text":"142. Linked List Cycle II MediumGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Notice that you should not modify the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Example 1: 123Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head &#x3D; [1,2], pos &#x3D; 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head &#x3D; [1], pos &#x3D; -1Output: no cycleExplanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 104]. -105 &lt;= Node.val &lt;= 105 pos is -1 or a valid index in the linked-list. 思路：思路一：大体思路还是和 141 一样的，唯一的后续操作就是：让相遇点和开始点一起再向后走，这两个点再次相遇的点就是入口点，具体可以参考下面的图和数学证明： 数学证明 条件：环的结点数 N、开始点到入口点距离 X、入口点到相遇点距离 Y (逆时针的距离，上图中长的那部分) 假设：slow 结点总共走了 T 步到相遇点；则 fast 结点共走了 2T 步 ​ slow 结点总共走了 K1 圈； fast 结点共走了 K2 圈 则： T = X + K1 * N + Y :one: 2T = X + K2 * N + Y :two: 化简： T = (K2 - K1) * N 带到 :one: 中： X = (K2 - 2K1 -1) * N + (N - Y) 其中： (N - Y) 表示相遇点到入口点的距离 这时候就可以说：我相遇点的结点向前走了 (K2 - 2K1 -1) 圈回到了相遇点，再走了 (N - Y) 到了入口点 简直就是 Amazing 啊！ 代码： 1234567891011121314151617public ListNode detectCycle(ListNode head) &#123; ListNode slow = head, fast = head; ListNode temp = null; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; temp = slow; while (head != temp) &#123; head = head.next; temp = temp.next; &#125; return head; &#125; &#125; return null;&#125; 时间复杂度：O() 空间复杂度：O()","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0092. Reverse Linked List II","slug":"0092-Reverse-Linked-List-II","date":"2020-10-21T12:14:42.000Z","updated":"2020-10-21T12:17:23.402Z","comments":true,"path":"2020/10/21/0092-Reverse-Linked-List-II/","link":"","permalink":"http://wangba.me/2020/10/21/0092-Reverse-Linked-List-II/","excerpt":"","text":"92. Reverse Linked List II Medium难度中等551 Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 思路：思路一：利用反转链表在 206 中已经解决了反转整个链表，现在这种部分的反转链表，只需要将上面的断链，丢到反转整个链表的函数中，再恢复连接就行了 123456原链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL断链：1 2-&gt;3-&gt;4 5-&gt;NULL调用函数：4-&gt;3-&gt;2恢复：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode listNode = new ListNode(-1); listNode.next = head; ListNode res = listNode; ListNode pre = null; ListNode cur = null; ListNode next = null; int count = 0; while (listNode != null) &#123; if (count == m) &#123; next = listNode; &#125; if (count == m - 1) &#123; pre = listNode; &#125; if (count == n) &#123; cur = listNode; break; &#125; listNode = listNode.next; count++; &#125; ListNode temp = cur.next; cur.next = null; ListNode node = reverseList(pre.next); pre.next = node; next.next = temp; return res.next;&#125;private ListNode reverseList(ListNode head) &#123; // 迭代法 ListNode pre = null; while (head != null) &#123; ListNode next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125; 写的有点复杂了…… 时间复杂度：O(n) 空间复杂度：O(1) 思路二：头插法还是要使用哨兵，避免重复操作，哨兵后面结点的操作：找到第一个要进行逆置结点的前一个结点，然后对后每个结点都进行头插法就行了 代码： 1234567891011121314151617public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for (int i = 0; i &lt; m - 1; i++) &#123; pre = pre.next; &#125; ListNode cur = pre.next; for (int i = m; i &lt; n; i++) &#123; ListNode next = cur.next; cur.next = next.next; next.next = pre.next; pre.next = next; &#125; return dummy.next;&#125; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0086. Partition List","slug":"0086-Partition-List","date":"2020-10-20T13:35:39.000Z","updated":"2020-10-20T13:37:46.940Z","comments":true,"path":"2020/10/20/0086-Partition-List/","link":"","permalink":"http://wangba.me/2020/10/20/0086-Partition-List/","excerpt":"","text":"86. Partition List MediumGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 思路：思路一：大小链表123456原链表：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2大链表：4 -&gt; 3 -&gt; 5小链表：1 -&gt; 2 -&gt; 2合并链表：1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 代码： 1234567891011121314151617181920212223242526 public ListNode partition(ListNode head, int x) &#123;// Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3// Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 // 小链表 ListNode min = new ListNode(-1); ListNode l = min; // 大链表 ListNode max = new ListNode(-1); ListNode h = max; while (head != null) &#123; if (head.val &lt; x) &#123; l.next = head; l = l.next; &#125; else &#123; h.next = head; h = h.next; &#125; head = head.next; &#125; h.next = null; l.next = max.next; return min.next; &#125; 时间复杂度：O(n) 空间复杂度：O()","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0083. Remove Duplicates from Sorted List","slug":"0083-Remove-Duplicates-from-Sorted-List","date":"2020-10-19T13:28:17.000Z","updated":"2020-10-20T13:34:21.281Z","comments":true,"path":"2020/10/19/0083-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"http://wangba.me/2020/10/19/0083-Remove-Duplicates-from-Sorted-List/","excerpt":"","text":"83. Remove Duplicates from Sorted List EasyGiven a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 思路：思路一：双指针由于都是已经排好序的链表，相同的数都在一起，只要使用双指针：一个指向出现的第一个数，一个一直遍历到这个数结束即可 代码： 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode slow = head; ListNode fast = head.next; while (fast != null) &#123; if (slow.val == fast.val) &#123; fast = fast.next; slow.next = fast; &#125; else &#123; slow = slow.next; fast = fast.next; &#125; &#125; return head;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0025. Reverse Nodes in k-Group","slug":"0025-Reverse-Nodes-in-k-Group","date":"2020-10-15T11:56:31.000Z","updated":"2020-10-15T12:01:22.813Z","comments":true,"path":"2020/10/15/0025-Reverse-Nodes-in-k-Group/","link":"","permalink":"http://wangba.me/2020/10/15/0025-Reverse-Nodes-in-k-Group/","excerpt":"","text":"25. Reverse Nodes in k-Group HardGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. Follow up: Could you solve the problem in O(1) extra memory space? You may not alter the values in the list’s nodes, only nodes itself may be changed. Example 1: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [2,1,4,3,5] Example 2: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 3Output: [3,2,1,4,5] Example 3: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 1Output: [1,2,3,4,5] Example 4: 12Input: head &#x3D; [1], k &#x3D; 1Output: [1] Constraints: The number of nodes in the list is in the range sz. 1 &lt;= sz &lt;= 5000 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= sz 思路：思路一：迭代可以结合下面的图和代码进行查看： 代码： 1234567891011121314151617181920212223242526272829303132public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode ans = new ListNode(0); ans.next = head; ListNode res = ans; ListNode end = ans; while (end.next != null) &#123; for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next; if (end == null) break; ListNode start = res.next; ListNode next = end.next; end.next = null; res.next = reverseList(start); start.next = next; res = start; end = res; &#125; return ans.next;&#125;private ListNode reverseList(ListNode head) &#123; // 递归法 if (head == null || head.next == null) &#123; return head; &#125; ListNode listNode = reverseList(head.next); head.next.next = head; head.next = null; return listNode;&#125; 时间复杂度：O(n) 空间复杂度：O(1) 思路二：递归代码： 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null) return null; ListNode point = head; //找到子链表的尾部 int i = k; while(i - 1 &gt;0)&#123; point = point.next; if (point == null) &#123; return head; &#125; i--; &#125; ListNode temp = point.next; //将子链表断开 point.next = null; //倒置子链表，并接受新的头结点 ListNode new_head = reverseList(head); //head 其实是倒置链表的尾部，然后我们将后边的倒置结果接过来就可以了 //temp 是链表断开后的头指针，可以参考解法一的图示 head.next = reverseKGroup(temp,k); return new_head;&#125;private ListNode reverseList(ListNode head) &#123; // 递归法 if (head == null || head.next == null) &#123; return head; &#125; ListNode listNode = reverseList(head.next); head.next.next = head; head.next = null; return listNode;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"1002. Find Common Characters","slug":"1002-Find-Common-Characters","date":"2020-10-14T11:46:04.000Z","updated":"2020-10-14T11:51:39.832Z","comments":true,"path":"2020/10/14/1002-Find-Common-Characters/","link":"","permalink":"http://wangba.me/2020/10/14/1002-Find-Common-Characters/","excerpt":"","text":"1002. Find Common Characters EasyGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order. Example 1: 12Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] Example 2: 12Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]Output: [&quot;c&quot;,&quot;o&quot;] Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] is a lowercase letter 思路：思路一：暴力破解仅供参考： 找到长度最小的字符串，由于是考虑每一个字符串中重复的元素 将这个字符串放到 map 中，map 中的值可以设为字符串数组长度 依次遍历，如果重复就 -1 ，最后看 map 中的值是否变为 0 思路二：哈希可以结合下面的图和代码进行理解 由于都是小写字母，只需要使用容量为 26 的数组表示 26 位字母； 第一个 26 位数组，将字符串数组的第一个字符串装下，重复的 + 1 后面和第一个一样操作得到新的数组，比较其中的值，取最小 的即可，因为最小的那个才代表着它在自己的数组中重复了多少次，在所有的字符串中，它最多的字符重复 将结果放在第一个数组，继续比较 代码： 12345678910111213141516171819202122232425public List&lt;String&gt; commonChars(String[] A) &#123; // 哈希表 int[] res = new int[26]; for (int i = 0; i &lt; A[0].length(); i++) &#123; res[A[0].charAt(i) - &#x27;a&#x27;]++; &#125; for (int i = 1; i &lt; A.length; i++) &#123; int[] temp = new int[26]; for (int j = 0; j &lt; A[i].length(); j++) &#123; temp[A[i].charAt(j) - &#x27;a&#x27;]++; &#125; for (int j = 0; j &lt; 26; j++) &#123; res[j] = Math.min(res[j], temp[j]); &#125; &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 26; i++) &#123; while (res[i] != 0) &#123; ans.add(String.valueOf((char)((i) + &#x27;a&#x27;))); res[i]--; &#125; &#125; return ans;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0023. Merge k Sorted Lists","slug":"0023-Merge-k-Sorted-Lists","date":"2020-10-14T06:39:51.000Z","updated":"2020-10-14T07:00:54.331Z","comments":true,"path":"2020/10/14/0023-Merge-k-Sorted-Lists/","link":"","permalink":"http://wangba.me/2020/10/14/0023-Merge-k-Sorted-Lists/","excerpt":"","text":"23. Merge k Sorted Lists HardYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: 12345678910Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Example 2: 12Input: lists &#x3D; []Output: [] Example 3: 12Input: lists &#x3D; [[]]Output: [] Constraints: k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] is sorted in ascending order. The sum of lists[i].length won’t exceed 10^4. 思路：思路一：暴力解法遍历链表数组中的每一个链表，在每一个链表中继续遍历，将所有的结果都存在数组中，再进行一次快速排序，最后再把数组中的每个结点组装成链表即可 代码： 12345678910111213141516171819public ListNode mergeKLists(ListNode[] lists) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (ListNode listNode : lists) &#123; while (listNode != null) &#123; res.add(listNode.val); listNode = listNode.next; &#125; &#125; Collections.sort(res); ListNode head = new ListNode(-1); ListNode ans = head; for (int i : res) &#123; ListNode listNode = new ListNode(i); head.next = listNode; head = head.next; &#125; head.next = null; return ans.next;&#125; 时间复杂度：O(nlogn)，n 为所有结点数 空间复杂度：O(n) 思路二：列比较利用每个链表数组中的链表是有序的，则每次拿到最小的结点加入新的链表中，每个链表数组中的链表头的值一定是最小的 代码： 123456789101112131415161718192021222324252627282930public ListNode mergeKLists(ListNode[] lists) &#123; // 2. 列比较 // 最小索引 int minIndex = 0; ListNode head = new ListNode(-1); ListNode res = head; while (true) &#123; boolean isCompleted = true; int min = Integer.MAX_VALUE; // 遍历一遍链表数组找到数值最小的结点 for (int i = 0; i &lt; lists.length; i++) &#123; if (lists[i] != null) &#123; if (lists[i].val &lt; min) &#123; minIndex = i; min = lists[i].val; &#125; isCompleted = false; &#125; &#125; // 当所有的链表全部遍历完了，while 循环结束 if (isCompleted) break; head.next = lists[minIndex]; head = head.next; lists[minIndex] = lists[minIndex].next; &#125; head.next = null; return res.next;&#125; 时间复杂度：O(m * n)，m 为最长链表的长度；n 为链表数组长度 空间复杂度：O(1) 思路三：优先队列在上面的思路中，每次都是找到链表数组中最小的结点，再加入新链表中，在上面使用的直接遍历的方式，在这里可以采用优先队列的方式，优先队列是基于堆实现的，具体来说就是小/大根(顶)堆，只需要将每个链表的头结点放入，会自动进行大小比较，出队列是就是最小/最大 代码： 12345678910111213141516171819202122232425public ListNode mergeKLists(ListNode[] lists) &#123; // 优先队列中默认就是小根堆 PriorityQueue&lt;ListNode&gt; priorityQueue = new PriorityQueue&lt;ListNode&gt;(Comparator.comparing(n -&gt; n.val)); // 将每个结点的的头结点加入优先队列 for (int i = 0; i &lt; lists.length; i++) &#123; if (lists[i] != null) &#123; priorityQueue.add(lists[i]); &#125; &#125; ListNode head = new ListNode(-1); ListNode res = head; while (!priorityQueue.isEmpty()) &#123; // 出队列时就是最小值先出来的 head.next = priorityQueue.poll(); head = head.next; // 将出队列的后面那个值加入优先队列 if (head.next != null) &#123; priorityQueue.add(head.next); &#125; &#125; return res.next;&#125; 时间复杂度：O(nlogk)，n 表示所有的结点书数，logk 表示每个结点的入队、出队 空间复杂度：O(k)，k 表示链表数组的长度；在 Java 中优先队列是有默认值的 思路四：两两合并在0021. Merge Two Sorted Lists中，已经实现过两个有序链表的合并，本题也可以参考这个思路：首先将链表 0 和链表 1 合并，合并成新的链表 a，在和链表 2 进行合并 …… 代码： 123456789101112131415161718192021public ListNode mergeKLists(ListNode[] lists) &#123; // 4. 两两合并 ListNode temp = null; for (int i = 0; i &lt; lists.length; i++) &#123; temp = mergeTwoLists(temp, lists[i]); &#125; return temp;&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &gt; l2.val) &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; else &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;&#125; 思路五：二分法两两合并在上面思路五中，合并的思路是：先是合并第一个和第二个，合并为新的后，再和第三个进行合并，这样的效率有点低 这个思路也是可以优化的，使用二分法： 代码： 123456789101112131415161718192021222324public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) return null; return merge(lists, 0 , lists.length - 1);&#125;private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l = merge(lists, left, mid); ListNode r = merge(lists, mid + 1, right); return mergeTwoLists(l , r);&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &gt; l2.val) &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; else &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0021. Merge Two Sorted Lists","slug":"0021-Merge-Two-Sorted-Lists","date":"2020-10-13T12:28:27.000Z","updated":"2020-10-14T07:00:19.534Z","comments":true,"path":"2020/10/13/0021-Merge-Two-Sorted-Lists/","link":"","permalink":"http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/","excerpt":"","text":"21. Merge Two Sorted Lists EasyMerge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Example 1: 12Input: l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]Output: [1,1,2,3,4,4] Example 2: 12Input: l1 &#x3D; [], l2 &#x3D; []Output: [] Example 3: 12Input: l1 &#x3D; [], l2 &#x3D; [0]Output: [0] Constraints: The number of nodes in both lists is in the range [0, 50]. -100 &lt;= Node.val &lt;= 100 Both l1 and l2 are sorted in non-decreasing order. 思路：思路一：迭代法设置一个头结点，随后开始比较两个链表的结点值大小，具体逻辑可以将下面的图和代码逻辑联系起来： 代码： 1234567891011121314151617181920212223242526public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 迭代法 // 1 2 4 1 3 4 // 1 1 2 3 4 4 ListNode temp = new ListNode(-1); ListNode res = temp; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &gt; l2.val) &#123; temp.next = l2; temp = temp.next; l2 = l2.next; &#125; else &#123; temp.next = l1; temp = temp.next; l1 = l1.next; &#125; &#125; if (l1 == null) temp.next = l2; if (l2 == null) temp.next = l1; return res.next;&#125; 时间复杂度：O(m + n) 空间复杂度：O(1) 思路二：递归法递归最重要的两个点： 递归的出口，在本题里面就是当其中的一个链表为空，直接返回另外一个链表即可 要进行递归，传入参数后的结果应该是已经确定的了，在这里就是链表已经排好序了 举个例子：如果现在是 123链表la：1 -&gt; 3 -&gt; 5链表lb：2 -&gt; 4 -&gt; 6 进行第一次递归时：要比较 1 和 2 的大小，发现 1 &lt; 2，此时只需要将 1.next = mergeTwoLists(3, 2) 就行了，不要去想 mergeTwoLists(3, 2) 怎么来的，要把它当作已经确定的值就行，而 mergeTwoLists(3, 2) 的值可以看作是下面这两个链表的进行 mergeTwoLists 的结果 123链表la：3 -&gt; 5链表lb：2 -&gt; 4 -&gt; 6 代码： 12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 递归法 // 递归的出口 if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &gt; l2.val) &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; else &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;&#125; 时间复杂度：O(m + n) 空间复杂度：O(m + n) 由于递归是调用栈的，每递归一次需要一个栈帧","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"SpringBoot整合Spring Security(七)","slug":"SpringBoot整合Spring-Security-七","date":"2020-10-13T05:38:58.000Z","updated":"2020-10-13T05:40:08.522Z","comments":true,"path":"2020/10/13/SpringBoot整合Spring-Security-七/","link":"","permalink":"http://wangba.me/2020/10/13/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%83/","excerpt":"","text":"一、OverView​ 这一小节整理一下前面几节的内容，主要完整的捋一遍 Spring Security 的登录过程。为了有一个 Architecture First 的印象，先将其中关键的类和接口列出，如果看到后面发现有印象，就可以跳到前面来看一下： SecurityContextHolder Authentication Token 类 UsernamePasswordAuthenticationToken AbstractAuthenticationToken Provider 和 Manger 类 AuthenticationManager ProviderManager AuthenticationProvider DaoAuthenticationProvider UserDetails 与 UserDetailsService 主要可以参考一下这张图： 图源：Spring Security(一)–Architecture Overview 二、DeepLearning2.1 Authentication先看一下 Authentication 的相关实现类 源码： 12345678910111213public interface Authentication extends Principal, Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); Object getCredentials(); Object getDetails(); Object getPrincipal(); boolean isAuthenticated(); void setAuthenticated(boolean var1) throws IllegalArgumentException;&#125; getAuthorities()：权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。 getCredentials()：密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。 getDetails()：细节信息，web 应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。 getPrincipal()：最重要的身份信息，大部分情况下返回的是 UserDetails 接口的实现类，也是框架中的常用接口之一。UserDetails 接口将会在下面的小节重点介绍。 在实现类中非常重要的就是 UsernamePasswordAuthenticationToken ，再看一下其中的属性和方法 以及它的父类：AbstractAuthenticationToken 2.2 UsernamePasswordAuthenticationFilter在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 UsernamePasswordAuthenticationFilter： 123456789101112131415161718192021222324252627282930313233343536public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; public UsernamePasswordAuthenticationFilter() &#123; super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;)); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; else &#123; String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = &quot;&quot;; &#125; if (password == null) &#123; password = &quot;&quot;; &#125; username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; @Nullable protected String obtainPassword(HttpServletRequest request) &#123; return request.getParameter(this.passwordParameter); &#125; @Nullable protected String obtainUsername(HttpServletRequest request) &#123; return request.getParameter(this.usernameParameter); &#125;&#125; 其中：UsernamePasswordAuthenticationFilter 是继承 AbstractAuthenticationProcessingFilter 通过 obtainUsername 和 obtainPassword 方法提取出请求里边的用户名/密码出来，提取方式就是 request.getParameter 获取到请求里传递来的用户名/密码之后，接下来就构造一个 UsernamePasswordAuthenticationToken 对象，传入 username 和 password，username 对应了 UsernamePasswordAuthenticationToken 中的 principal 属性，而 password 则对应了它的 credentials 属性 接下来 setDetails 方法给 details 属性赋值，UsernamePasswordAuthenticationToken 本身是没有 details 属性的，这个属性在它的父类 AbstractAuthenticationToken 中。details 是一个对象，这个对象里边放的是 WebAuthenticationDetails 实例，该实例主要描述了两个信息，请求的 remoteAddress 以及请求的 sessionId 最后调用 authenticate 方法去做校验了 仔细来细说一下上面代码中的最后一个方法中的校验：authenticate 校验操作首先要获取到一个 AuthenticationManager： 这里拿到的是 ProviderManager ，所以接下来我们就进入到 ProviderManager 的 authenticate 方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; AuthenticationException parentException = null; Authentication result = null; Authentication parentResult = null; boolean debug = logger.isDebugEnabled(); for (AuthenticationProvider provider : getProviders()) &#123; if (!provider.supports(toTest)) &#123; continue; &#125; if (debug) &#123; logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException | InternalAuthenticationServiceException e) &#123; prepareException(e, authentication); throw e; &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125; if (result == null &amp;&amp; parent != null) &#123; try &#123; result = parentResult = parent.authenticate(authentication); &#125; catch (ProviderNotFoundException e) &#123; &#125; catch (AuthenticationException e) &#123; lastException = parentException = e; &#125; &#125; if (result != null) &#123; if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123; ((CredentialsContainer) result).eraseCredentials(); &#125; if (parentResult == null) &#123; eventPublisher.publishAuthenticationSuccess(result); &#125; return result; &#125; ...... throw lastException;&#125; 首先获取 authentication 的 Class，判断当前 provider 是否支持该 authentication 如果支持，则调用 provider 的 authenticate 方法开始做校验，校验完成后，会返回一个新的 Authentication 这里的 provider 可能有多个，如果 provider 的 authenticate 方法没能正常返回一个 Authentication，则调用 provider 的 parent 的 authenticate 方法继续校验 copyDetails 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来 接下来会调用 eraseCredentials 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 credentials 属性置空 最后通过 publishAuthenticationSuccess 方法将登录成功的事件广播出去 在具体说一下调用 provider 的 authenticate 方法的过程： 在 for 循环中，第一次拿到的 provider 是一个 AnonymousAuthenticationProvider，这个 provider 压根就不支持 UsernamePasswordAuthenticationToken，也就是会直接在 provider.supports 方法中返回 false，结束 for 循环 然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。而 parent 就是 ProviderManager，所以会再次回到这个 authenticate 方法中。再次回到 authenticate 方法中，provider 也变成了 DaoAuthenticationProvider，这个 provider 是支持 UsernamePasswordAuthenticationToken 的 所以会顺利进入到该类的 authenticate 方法去执行，而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider 并且没有重写 authenticate 方法，所以 我们最终来到 AbstractUserDetailsAuthenticationProvider#authenticate 方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;)); // Determine username String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot; : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException notFound) &#123; logger.debug(&quot;User &#x27;&quot; + username + &quot;&#x27; not found&quot;); if (hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; else &#123; throw notFound; &#125; &#125; Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;); &#125; try &#123; preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException exception) &#123; if (cacheWasUsed) &#123; cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; else &#123; throw exception; &#125; &#125; postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return createSuccessAuthentication(principalToReturn, authentication, user);&#125; 首先从 Authentication 提取出登录用户名 然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象 接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等 additionalAuthenticationChecks 方法则是做密码比对的 最后在 postAuthenticationChecks.check 方法中检查密码是否过期 接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多 最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken 整体流程大概如下： 图源：Spring Security认证过程","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"0019.Remove Nth Node From End of List","slug":"0019-Remove-Nth-Node-From-End-of-List","date":"2020-10-12T12:06:55.000Z","updated":"2020-10-12T12:10:23.037Z","comments":true,"path":"2020/10/12/0019-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"http://wangba.me/2020/10/12/0019-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"19. 删除链表的倒数第N个节点 Medium给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路：首先回忆一下如何删除一个结点，可以参考这个，主要就是找到要删除前面的那个结点 思路一：暴力法直接两次遍历即可，第一遍找到这个链表的长度，第二遍只需要走链表长度减去这个**n**就行了 代码：123456789101112131415161718192021222324public ListNode removeNthFromEnd(ListNode head, int n) &#123; int length = 0; ListNode l = head; while (l != null) &#123; length++; l = l.next; &#125; if (length == 1) &#123; return null; &#125; l = head; int sub = length - n; if (sub == 0) &#123; return head.next; &#125; while (sub &gt; 1) &#123; l = l.next; sub--; &#125; l.next = l.next.next; return head;&#125; 虽然遍历了两次，但是时间复杂度还是 O(n)，线性长度 空间复杂度为 O(1) 思路二：相对位移法这个思路也很简单，对比上面的思路好处是：只需要遍历一遍就行了 双指针，让 A 指针先走 n步，随后再让 B 指针和 A 指针一起走，这样就会有长度为 n 的相对位移，直到让 A 指针走到终点，此时 B 指针也就距终点 n 的长度了 代码：12345678910111213public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode fast = head, slow = head; for (int i=0; i&lt;n; i++)&#123; fast = fast.next; &#125; if (fast == null) return head.next; while (fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return head;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"0160. Intersection of Two Linked Lists","slug":"0160-Intersection-of-Two-Linked-Lists","date":"2020-10-12T02:09:45.000Z","updated":"2020-10-12T02:32:26.613Z","comments":true,"path":"2020/10/12/0160-Intersection-of-Two-Linked-Lists/","link":"","permalink":"http://wangba.me/2020/10/12/0160-Intersection-of-Two-Linked-Lists/","excerpt":"","text":"160. 相交链表 Easy编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Reference of the node with value &#x3D; 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Reference of the node with value &#x3D; 2输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 思路分析思路一：暴力法遍历链表 A 的时候，每遍历一个结点都完整遍历一下链表 B，判断指向的结点是否为同一个，这样时间复杂度为 O(mn) 思路二：+ HashMap在思路一的基础上，先将链表 A 的所有结点先放入 HashMap 中，遍历链表 B 的时候比较每个节点是否存在 HashMap 中，此时时间复杂度为 O(n)，但是空间复杂度为 O(n) 思路三：在上面的图中可以看见，在有交点的情况下，无非就三种情况：由于在交点后(包括交点)的所有结点都相同 链表 A 的长度 &gt; 链表 B 的长度 链表 A 的长度 = 链表 B 的长度 链表 A 的长度 &lt; 链表 B 的长度 如果我们能算出这个长度差，然后让长的那个链表先走这个长度差，再让两个链表一起走，直到走到相交点 举个例子，如下： 链表 A 长度 = 6；链表 B 长度 = 4；链表差 = 2 让长度长的链表(A)先走链表差，即 pointerA 先走 2 个结点 pointerA 与 pointerB 一起遍历，直到遍历到相同结点 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) &#123; return null; &#125; ListNode a = headA; ListNode b = headB; // 链表A 和 链表B 的长度 int la = 0, lb = 0; while (a.next != null) &#123; la++; a = a.next; &#125; while (b.next != null) &#123; lb++; b = b.next; &#125; // 此时说明直到 链表A 和 链表B 的最后一个结点都还没相交 if (a != b) &#123; return null; &#125; // 链表A 的长度大于 链表B if (la &gt; lb) &#123; int sub = la - lb; while (sub &gt; 0)&#123; headA = headA.next; sub--; &#125; &#125; // 链表A 的长度小于 链表B else &#123; int sub = lb - la; while (sub &gt; 0)&#123; headB = headB.next; sub--; &#125; &#125; while (headA != headB) &#123; headA = headA.next; headB = headB.next; &#125; return headA;&#125; 另外一种简洁的写法，思路一样 12345678910111213public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode a = headA; ListNode b = headB; while( a != b)&#123; a = a == null? headB : a.next; b = b == null? headA : b.next; &#125; return a;&#125; 如果没有重合部分，那么 a 和 b 在某一时间点 一定会同时走到 null，从而结束循环； 如果有重合部分，分两种情况： 长度相同的话， a 和 b 一定是同时到达相遇点，然后返回； 长度不同的话，较短的链表先到达结尾，然后指针转向较长的链表。此刻，较长的链表继续向末尾走，多走的距离刚好就是最开始介绍的解法，链表的长度差，走完之后指针转向较短的链表。然后继续走的话，相遇的位置就刚好是相遇点了。","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"SpringBoot整合Spring Security(六)","slug":"SpringBoot整合Spring-Security-六","date":"2020-10-10T09:32:56.000Z","updated":"2020-10-10T09:34:50.900Z","comments":true,"path":"2020/10/10/SpringBoot整合Spring-Security-六/","link":"","permalink":"http://wangba.me/2020/10/10/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E5%85%AD/","excerpt":"","text":"一、OverView​ 在上一节中，使用了第一种方式：JDBC 连接数据库。这一节中将使用 Spring Data JPA 进行数据库操作。如果对 JPA 的环境和操作没了解过的，可以适当参考这个。 在上一节也提到 Spring Security 支持多种数据源，这些不同来源的数据被共同封装成了一个 UserDetailService 接口 ​ 在这一节中，还是这个思路，这一次不用 Spring Security 提供的类, 可以自定义一个类去实现 UserDetailService 二、环境搭建思路清晰，先看依赖 application.properties 123456789spring.datasource.username=rootspring.datasource.password=spring.datasource.url=jdbc:mysql://127.0.0.1:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.jpa.database=mysqlspring.jpa.database-platform=mysqlspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect 实体类 User 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Entity(name = &quot;t_user&quot;)public class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username; private String password; private boolean accountNonExpired; private boolean accountNonLocked; private boolean credentialsNonExpired; private boolean enabled; // User 和 Role 是多对多关系 @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST) private List&lt;Role&gt; roles; // 返回用户权限 @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : getRoles()) &#123; authorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; // 用户是否过期 @Override public boolean isAccountNonExpired() &#123; return accountNonExpired; &#125; // 用户是否被锁 @Override public boolean isAccountNonLocked() &#123; return accountNonLocked; &#125; // 密码是否过期 @Override public boolean isCredentialsNonExpired() &#123; return credentialsNonExpired; &#125; // 账户是否可用 @Override public boolean isEnabled() &#123; return enabled; &#125; // set get 省略&#125; 注：这里为什么 User 要实现 UserDetails ? 主要是由于在自定义类实现 UserDetailService，其中只有唯一的抽象方法loadUserByUsername，而该方法就是返回的 UserDetails Role 12345678@Entity(name = &quot;t_role&quot;)public class Role &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String nameZh;&#125; UserDao 12345678910public interface UserDao extends JpaRepository&lt;User, Long&gt; &#123; /** * 通过用户名找到用户 * * @param username 用户名 * @return &#123;@link User&#125; */ User findAllByUsername(String username);&#125; 不懂为啥这么写的可以参考一下 JPA 的 CRUD 操作 UserService 1234567891011121314151617181920212223242526272829@Servicepublic class UserService implements UserDetailsService&#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; User user = userDao.findAllByUsername(s); if (StringUtils.isEmpty(user)) &#123; throw new UsernameNotFoundException(&quot;用户不存在&quot;); &#125; return user; &#125; /** * 保存用户 * * @param user 用户 * @return &#123;@link User&#125; */ User save(User user) &#123; return userDao.save(user); &#125;&#125; 注： 实现了 UserDetailsService，重写其中的 loadUserByUsername 方法：通过传入的用户名查找用户信息 save 方法是为了后面写入不同角色用户 UserController 123456789101112131415@RestControllerpublic class UserController &#123; private UserService userService; @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; @PutMapping(&quot;/save&quot;) public User save(@RequestBody User user) &#123; return userService.save(user); &#125;&#125; 将 SecurityConfig 中 configure 方法改为： 1234567891011private UserService userService;@Autowiredpublic void setUserService(UserService userService) &#123; this.userService = userService;&#125;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService);&#125; 三、TestPostman 由于在未登录的情况下，直接调用 localhost:8080/save 接口会失败，所以先在数据库中手动添加一个数据： user 表： role 表： user_role 关系表： 使用上述增加的用户登录： 增加不同角色用户： user 用户 admin用户 看下数据库： user表 role表 ![image-20201010160613255](/Users/wangdechao/Library/Application Support/typora-user-images/image-20201010160613255.png) user_role 关系表 此时在分别使用 user 用户和 admin 用户登录，看一下不同用户的权限： user用户 user权限接口 admin权限接口","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security(五)","slug":"SpringBoot整合Spring-Security-五","date":"2020-10-10T08:35:48.000Z","updated":"2020-10-10T09:37:21.525Z","comments":true,"path":"2020/10/10/SpringBoot整合Spring-Security-五/","link":"","permalink":"http://wangba.me/2020/10/10/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%BA%94/","excerpt":"","text":"一、OverView​ 在前面几节中都使用的是内存数据，并没有连接数据库，这一章将介绍 Spring Security 整合 JDBC ​ 在上一节中先是使用下面这种方式将信息放在内存中： 1234567891011@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;wangba&quot;) .password(&quot;guigui&quot;) .roles(&quot;admin&quot;) .and() .withUser(&quot;wangyi&quot;) .password(&quot;1111&quot;) .roles(&quot;user&quot;);&#125; 另外方式： 12345678@Override@Beanprotected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;wangba&quot;).password(&quot;guigui&quot;).roles(&quot;admin&quot;).build()); manager.createUser(User.withUsername(&quot;wangyi&quot;).password(&quot;1111&quot;).roles(&quot;user&quot;).build()); return manager;&#125; 由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。 首先看一下类继承和实现情况： 这时候就能看出来为什么上面第二种方式中，使用的是 InMemoryUserDetailsManager 实例了，这个就是基于内存的。还可以发现 JdbcUserDetailsManager 应该就是基于数据库的实例了。 二、环境搭建2.1 准备数据库在 org/springframework/security/core/userdetails/jdbc 中应该存储着 JdbcUserDetailsManager 自己提供的数据库脚本，内容如下： users.ddl 123create table users(username varchar_ignorecase(50) not null primary key,password varchar_ignorecase(500) not null,enabled boolean not null);create table authorities (username varchar_ignorecase(50) not null,authority varchar_ignorecase(50) not null,constraint fk_authorities_users foreign key(username) references users(username));create unique index ix_auth_username on authorities (username,authority); 这个数据库脚本适用于 HSQLDB 为了让他适用于 Mysql ，将其改为： 123create table users(username varchar(50) not null primary key,password varchar(500) not null,enabled boolean not null);create table authorities (username varchar(50) not null,authority varchar(50) not null,constraint fk_authorities_users foreign key(username) references users(username));create unique index ix_auth_username on authorities (username,authority); 执行完脚本可以看见：users 表和 authorities 表 user表 authorities表 两张表是通过 username 关联起来 2.2 增加不同角色用户将上述的第二种基于内存的方式修改为基于数据库方式 1234567891011121314151617181920private DataSource dataSource;@Autowiredpublic void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource;&#125;@Override@Beanprotected UserDetailsService userDetailsService() &#123; JdbcUserDetailsManager manager = new JdbcUserDetailsManager(); manager.setDataSource(dataSource); if (!manager.userExists(&quot;wangba&quot;)) &#123; manager.createUser(User.withUsername(&quot;wangba&quot;).password(&quot;guigui&quot;).roles(&quot;admin&quot;).build()); &#125; if (!manager.userExists(&quot;wangyi&quot;)) &#123; manager.createUser(User.withUsername(&quot;wangyi&quot;).password(&quot;1111&quot;).roles(&quot;user&quot;).build()); &#125; return manager;&#125; 运行项目可以看见已经将用户写入数据库了 进入 JdbcUserDetailsManager 的 createUser 方法中看看 可以看到 createUserSql 属性，具体看一下： 可以看到实际上就是一条 Sql 语句，然后把我们的用户数据写到数据库中 三、Test登录 user 访问 user 访问 admin","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security (四)","slug":"SpringBoot整合Spring-Security-四","date":"2020-10-09T10:33:41.000Z","updated":"2020-10-09T10:36:07.175Z","comments":true,"path":"2020/10/09/SpringBoot整合Spring-Security-四/","link":"","permalink":"http://wangba.me/2020/10/09/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E5%9B%9B/","excerpt":"","text":"一、OverView在本节中主要实现一下授权功能，即需求时： admin: 能访问所有的页面，不仅仅是 /admin/ 下的页面，也可以访问 /user/ 下的页面 user: 只能访问 /user/ 下所有页面 hello: /hello 所有用户都可以访问 可以理解为：admin 权限比 user 高 二、环境搭建环境参考前面几节，由于目前并没有连接数据库，所以就基于内存进行测试 SecurityConfig 在重写的 configure 方法中增加一个 user 用户： 1234567891011@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;wangba&quot;) .password(&quot;guigui&quot;) .roles(&quot;admin&quot;) .and() .withUser(&quot;wangyi&quot;) .password(&quot;1111&quot;) .roles(&quot;user&quot;);&#125; 在重写的 configure 方法中增加拦截规则： 123456789protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() .and() // 省略 ;&#125; 注：规则是有顺序的，即链式操作 如果把 anyRequest() 放在前面，首先就会让所有请求通过，然后再进行拦截，这样拦截规则就没有什么用了 SecurityController 在视图层增加一些请求方法 1234567891011121314@GetMapping(&quot;/hello&quot;)public String hello0() &#123; return &quot;hello&quot;;&#125;@GetMapping(&quot;/user/hello&quot;)public String hello1() &#123; return &quot;user&quot;;&#125;@GetMapping(&quot;/admin/hello&quot;)public String hello2() &#123; return &quot;admin&quot;;&#125; 其中： /hello 请求：允许登录后的任何人访问 /user/hello 请求：允许拥有 user 角色的用户登录；允许拥有 admin 角色的用户登录 /admin/hello 请求：只允许拥有 admin 角色的用户登录 123456789protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() .and() // 省略 ;&#125; 三、测试Postman 首先登录 user 用户：wangyi 按照上面的理论来说：user 可以访问 /hello 和 /user/hello ，不能访问 /admin/hello /hello /user/hello /admin/hello 可以看见，访问该接口被静止了 同样，登录 admin 用户：wangba /hello /admin/hello /user/hello 但是，我们前面要求实现的是 admin 可以访问所有页面，所以进行改进，即进行角色继承 SecurityConfig 123456@BeanRoleHierarchy roleHierarchy() &#123; RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); roleHierarchy.setHierarchy(&quot;ROLE_admin &gt; ROLE_user&quot;); return roleHierarchy;&#125; 注：上述配置表达ROLE_admin 自动具备 ROLE_user 的权限。 此时重启项目，再次登录 wangba，并访问 /user/hello 可以看见此时 admin 角色可以访问任何页面了","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"0206. Reverse Linked List","slug":"0206-Reverse-Linked-List","date":"2020-10-09T01:58:41.000Z","updated":"2020-10-09T02:00:28.470Z","comments":true,"path":"2020/10/09/0206-Reverse-Linked-List/","link":"","permalink":"http://wangba.me/2020/10/09/0206-Reverse-Linked-List/","excerpt":"","text":"206. 反转链表 Easy反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解析写链表的代码题，一定要考虑周全，可以从以下几个方面考虑： 是否为空链表 是否只剩一个结点 剩余两个结点怎么样 在处理头结点和尾结点时，逻辑上是否可以通过 迭代解法：1234567891011public ListNode reverseList(ListNode head) &#123; // 迭代法 ListNode pre = null; while (head != null) &#123; ListNode next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125; 这就是在链表中说到的哨兵，这样最大的目的就是为了让对整个链表的操作进行统一化 递归解法：12345678910public ListNode reverseList(ListNode head) &#123; // 递归法 if (head == null || head.next == null) &#123; return head; &#125; ListNode listNode = reverseList(head.next); head.next.next = head; head.next = null; return listNode;&#125; 在进行递归操作中，一定要注意的点：出口 也就是说一定要有最小条件，而这个条件是可以跳出最后一个递归调用的，然后将结果放到倒数第二个递归调用中 在这里面出口就是： 123if (head == null || head.next == null) &#123; return head;&#125; 一旦满足这个条件，就可以触发所有递归调用的结束","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"}]},{"title":"LinkedList","slug":"LinkedList","date":"2020-10-03T14:04:52.000Z","updated":"2020-10-12T02:10:28.109Z","comments":true,"path":"2020/10/03/LinkedList/","link":"","permalink":"http://wangba.me/2020/10/03/LinkedList/","excerpt":"","text":"一、OverView 快速预览： 首先要和上一节的数组进行横向对比，来看一下链表独有的特性 第二小节会介绍一下常见的几种链表，以及为什么要衍生出这些链表 第三小节主要关注于链表的基操，(勿6) 以及在链表中的一些注意事项，如何保持链表不断链，为什么要引入哨兵 最后一个小节主要结合 Java 中的链表 LinkedList 来加深对链表的理解 二、特性在上一节中已经介绍过数组了，可以将数组和链表在结构上进行对比： 在数组中，是需要一块连续且足够存储所有数据的内存空间。如果你的数据大小是 1MB，但是你的内存空间中可能只有两个大内存块，且大小分别为 512 KB，还有若干小内存块，那么这块数据是不能存储在内存中的 在链表中，是通过 next 指针将离散的内存空间全部利用起来，例如上面的情况中，就可以将这 1MB 大小的数据全部装入内存中 注：在实际的应用层开发中，是不用在乎那一点的空间换时间；但是在底层开发中，这种对空间要求非常高的开发中，就要考虑到多方面了 对比： 时间复杂度 数组 链表 查询 O(1) O(n) 插入、删除 O(n) O(1) 三、几种常规链表3.1 单链表 指向 w 的结点的结点称为头结点 指向 NULL 的结点 g 称为尾结点 每一个结点需要额外的空间存储下一个结点的地址 3.2 循环链表 不仅具有单链表的特点，且加上它的尾结点指向的不是 NULL，而是指向了头结点 相比单链表的优点：可以通过尾结点找到头结点 3.3 双向链表 每一个结点除了需要额外的空间存储下一个结点的地址，还需要额外的空间指向前一个结点的地址 相比单链表的优点：可以通过任一结点可以找到上一个结点和下一个结点 3.4 双向循环链表 不仅具有双向链表的特点，且加上头结点的 pre 指针指向尾结点，尾结点的 next 指针指向头结点 相比双向链表的优点：可以通过头结点找到尾结点，也可以通过尾结点找到头结点 四、链表的基操和注意事项这里对于链表的操作只在单链表中进行，其余的链表同理： 增 前提：在 a 结点后面增加一个 x 结点，p 指向 a 结点 第一步：x –&gt; next = p –&gt; next 第二步：p –&gt; next = x 注： 此时就要注意 “链不断” 理论：在上面的例子中就是，第一步和第二步的顺序不能颠倒，不然就会出现下面这种情况： 第一步：p –&gt; next = x 第二步：x –&gt; next = p –&gt; next 如果 p –&gt; next 指向了 x，那么在第二步中，x –&gt; next 指向了自己 删 删除操作的话，就只需要：p –&gt; next = p –&gt; next –&gt; next 即可 注：删除结点要记得释放内存，除了一些自带垃圾回收的语言外，例如 Java、python、Go等 哨兵模式 既然在链表中出现了这个模式，那必然是有运用的场景的，看个例子： 在上面单链表中增加一个结点时 12x --&gt; next = p --&gt; nextp --&gt; next = x 如果出现下面几种情况： 空链表，插入第一个结点 删除最后一个结点 又或是 p 指针指向的是两个结点的前一个结点 (在上面的例子中是 a)，但是如果出现要插入的是头结点前面 (也就是说没有前面那个结点了) 呢？ 此时就可以发现，p 指针无处可指，这时候就可以引入”哨兵”了。(虽然在双向链表中可以轻易解决这个问题) 也就是说不管在什么情况下，都有一个哨兵的存在，其主要目的就是简化代码，不需要考虑带很多情况，可以看一下下面的例子： 首先需要的前提就是：head 指针是永远指向哨兵的 空链表中插入第一个结点，就可以： 123if (head -&gt; next == null) &#123; p = head;&#125; 只需要判断哨兵指针的 next 是否为空，如果为空的的话，只需要将 p = head，就可以进行和上面一样的插入代码了 四、Java中的链表​ 首先来回忆一下在 Java 中对数组的操作，直接分配一块连续的内存给数组，这种情况的不好之处就是需要连续且内存足够的空间；随后又提出了 Java 中动态数组 ArrayList ，这个类的确可以进行动态的自动扩容，但是它不能进行自动缩容 (注：ArrayList 是支持手动扩容、缩容)，而且它的扩容是将原来所有的数据复制一份到已经进行扩容到原来 1.5 倍的新数组中，当数据量过大时，这种操作可能就需要大量时间来进行了 ​ 而在这一小节中，可以看一下，在 Java 中链表类：LinkedList，它的底层是基于双向链表的，日常开发很少使用 首先看一下，继承关系： 可以和上一节 ArrayList 类的继承图进行对比，可以发现： 少了：LinkedList 少实现了 RandomAccess 接口，具体看参考RandomAccess 这个空架子有何用？ 改了：ArrayList 是继承了 AbstractList，而 LinkedList 继承了 AbstractSequentialList (它是 AbstractList 的子类) 多了：LinkedList 还实现了 Deque 接口 ====&gt; 因为实现 Deque 即可以作为队列使用，也可以作为栈使用。当然，作为双端队列，也是可以的。 由于源码过多，此内容将放在 JDK 源码分析系列中。","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"}]},{"title":"Array","slug":"Array","date":"2020-10-02T14:35:15.000Z","updated":"2020-10-02T14:29:22.797Z","comments":true,"path":"2020/10/02/Array/","link":"","permalink":"http://wangba.me/2020/10/02/Array/","excerpt":"","text":"一、OverView思维导图： 二、特性数组应该是所有程序员中最熟悉的数据结构了，如果你简单的回忆一下数组的具体含义，你可以得到已经几个重要的结论： 🐷 线性结构 🐢 连续内存 🐭 存储相同类型 2.1 线性结构顾名思义，线性结构就是这个结构像线性一样，而非是其它结构，这样说的确有点抽象，可以从下面几个例子来看一下： 注： 这里的 Array 是使用 Java 中的内存模型，即 char 为 2 个字节 链表没有使用哨兵模式 (后面会提到) 2.2 连续内存和相同数据类型正如上面例子中的数组一样，在这个数组中，它们的地址是连续的，且数组中每一个元素都是 char 类型，正是由于这两个特性，让数组实现了这一生中最重要的操作：快速查询，它可以达到 O(1) 的速度，当然要对这里进行限制条件，即准确的表达应该是按照下标进行查询，它的时间复杂度可以达到 O(1) ，而不是我们经常说的根据某个值来确定它的位置等，这样的查询方式 (已经排好序) 最快也是 O(logn) 先来看一下是如何实现根据下标来进行时间复杂度为 O(1) 的操作： 我们很容易就发现这样的规律： 前提：char[] charList = new char[6] 结论：address = baseAddress + i * charSize 也就是说，我们只需要知道以下条件就行： 该数组的起始地址 baseAddress，也就是图中的 1000 该数组是什么类型，这里是 Java 的 char 类型，字节数为 2 就这样，可以通过上面条件求出这里任意一个元素的地址。 假知识：如果，起始地址从 1 开始的话，来计算一下会发生什么情况？ 计算公式是不是要变为：address = baseAddress + (i - 1) * charSize 你想，你细想，是不是每次都要多进行一次减法操作，这样 加法器 (在计组中是没有减法器存在的，通过转换为加法来计算)是不是就要多进行一次计算 这会不会就是当年定义数组从 0 开始的那位程序员的 idea 呢？(强者如斯) 当然不是，这仅仅是一种规定而已，上面的一系列猜测，仅仅是为了猜而猜 2.3 插入和删除One coin has two sides，有利自然有弊。在上面已经说过了数组的查询，也是数组的最大优点；当然数组在插入和删除的时间复杂度比较高，但是也有一些优化的小 tips。 插入 为什么说数组中插入，会是时间复杂度变高呢？主要是数组是连续存储的，如果只是在最后一个元素插入一个新的元素，那么没什么大不了；但是你要是在第一个元素后面插入一个新的元素，那就要把原本的第二个元素到最后一个元素全部向后移动一个 typeSize，如下： 由上面的图，可以轻易看出插入新的元素在最后：前面元素的位置都未变；插入在第二个位置：第二个元素到最后一个元素的位置都 + 1 了 平均的时间复杂度就为：O(n) 当然这样做是有前提的：就是是要有序的。如果对排序没有要求的，可以如下操作： 此时只需要把原本在 1 位置的元素复制到新扩展的位置，把 1 中的元素换成新的元素，在上述的例子中对应的就是：将 n 复制到位置 5 上，然后将位置 1 的元素覆盖为新元素 a 删除 删除数组中的元素与插入操作类似：主要是为了保证内存的连续性，如果删除最后一个元素，那没什么问题；如果是删除第一个元素，那么第一个元素后面的所有元素都要向前移动一个位置。 则平均的时间复杂度就为：O(n) 一些特殊情况下的删除：如果对没有立马对删除元素进行垃圾回收的操作，有什么比较好的方式？ 在 JVM 进行垃圾回收时，有以下几种算法： 标记 - 清除算法 复制算法 标记 - 整理算法 分代收集算法 在这里主要介绍一下 标记 - 清除算法，简单来说： 在 JVM 进行垃圾回收时，不立马进行回收，只是对要进行回收的元素进行标记，等到积累到一定量再进行一次批处理，例子如下： 可以看见，只需要对要删除的元素进行标记，随后到最后一次性进行回收 但是这样也会带来很多问题，如效率问题和空间问题，如下： 如果是删除的元素是一段一段的，那么就会产生大量的空间碎片，所以 JVM 后面还有很多其余的回收算法 2.4 关于数组越界的问题我们尝试在 Ubuntu 18.04 64bit 中运行下面这段 C 代码： OverFlow.c 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for(; i&lt;=3; i++)&#123; arr[i] = 0; printf(&quot;hello world\\n&quot;); &#125; return 0;&#125; 按照正常想法走下去：会打印三行 hello world，就会运行完毕 让我们进行测试吧： 你就会看到控制台开始无限打印 hello world 了： ![image-20201002172557103](/Users/wangdechao/Library/Application Support/typora-user-images/image-20201002172557103.png) 只要在内存足够的情况下，这个程序就会一直运行下去，这就是典型的 StackOverFlow 问题 简单的就可以理解成如下结构： 这个栈的结构具体可以参考《深入理解计算机系统》，这里出现上述情况的主要原因： C 语言中是所有的内存都是可以访问 (除了受限内存以外) 在上述代码中 i &lt;=3，说明 a[3] = 0 在内存的某个地址上 而这个地址本身是 原来的 i 的地址 ，所以就相当于 i = 3 又被赋值为 i = 0，然后继续不断循环 如果想知道这个栈溢出是如何具体实现的话，可以是用 objdump 命令进行反编译，再进行分析，其中主要的汇编代码如下：其中关键行应该为 65f、67e、682、661 123456789101112131415161718192021222324000000000000063a &lt;main&gt;: 63a: 55 push %rbp 63b: 48 89 e5 mov %rsp,%rbp 63e: 48 83 ec 20 sub $0x20,%rsp 642: 89 7d ec mov %edi,-0x14(%rbp) 645: 48 89 75 e0 mov %rsi,-0x20(%rbp) 649: c7 45 fc 00 00 00 00 movl $0x0,-0x4(%rbp) 650: 48 c7 45 f0 00 00 00 movq $0x0,-0x10(%rbp) 657: 00 658: c7 45 f8 00 00 00 00 movl $0x0,-0x8(%rbp) 65f: eb 1d jmp 67e &lt;main+0x44&gt; 661: 8b 45 fc mov -0x4(%rbp),%eax 664: 48 98 cltq 666: c7 44 85 f0 00 00 00 movl $0x0,-0x10(%rbp,%rax,4) 66d: 00 66e: 48 8d 3d 9f 00 00 00 lea 0x9f(%rip),%rdi # 714 &lt;_IO_stdin_used+0x4&gt; 675: e8 96 fe ff ff callq 510 &lt;puts@plt&gt; 67a: 83 45 fc 01 addl $0x1,-0x4(%rbp) 67e: 83 7d fc 03 cmpl $0x3,-0x4(%rbp) 682: 7e dd jle 661 &lt;main+0x27&gt; 684: b8 00 00 00 00 mov $0x0,%eax 689: c9 leaveq 68a: c3 retq 68b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 其实，在这个巨大漏洞出来后，现在的内存已经加了金丝雀保护 (canary) 了，为了让这个漏洞复现，在上面编译的过程中，已经使用 -fno-stack-protector 将保护关闭了 而如果该程序在 Java 中复现，在编译时就会抛出 ArrayIndexOutOfBoundsException 的异常了 三、Java 中的数组在 Java 中，对于数组没有什么好了解的，顶多就一个基本语法；但是在 Java 中有一个集合类，是每个 Java 程序员应该每天都会用到的，它就是 ArrayList 先看一下它的继承和实现关系 它继承了 AbstractList ，实现了 List ====&gt; 它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能 它实现了RandomAccess 接口 ====&gt; 实现这个这个接口的 List 集合是支持快速随机访问 它实现 java.io.Serializable 接口 ====&gt; ArrayList 支持序列化，能通过序列化去传输 并且要注意，在单线程中使用它，在多线程使用 Vector(少) 或者 CopyOnWriteArrayList(多)**，尽量还是使用后者较多，前者主要是基于 **synchronized 关键字，后者是基于 ReentrantLock 操作的 它与 Java 自带的普通数组最大的区别就是：它是动态的 这里主要基于源码分析一下动态扩容： 12345678910111213141516171819202122232425262728293031public void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; this.elementData.length &amp;&amp; (this.elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA || minCapacity &gt; 10)) &#123; ++this.modCount; this.grow(minCapacity); &#125;&#125;private Object[] grow(int minCapacity) &#123; return this.elementData = Arrays.copyOf(this.elementData, this.newCapacity(minCapacity));&#125;private Object[] grow() &#123; return this.grow(this.size + 1);&#125;private int newCapacity(int minCapacity) &#123; int oldCapacity = this.elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (this.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(10, minCapacity); &#125; else if (minCapacity &lt; 0) &#123; throw new OutOfMemoryError(); &#125; else &#123; return minCapacity; &#125; &#125; else &#123; return newCapacity - 2147483639 &lt;= 0 ? newCapacity : hugeCapacity(minCapacity); &#125;&#125; 注： 对于变长数据结构，当结构中没有空余空间可供使用时，就需要进行扩容。在 ArrayList 中，当空间用完，其会按照原数组空间的1.5倍进行扩容。","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"}]},{"title":"Algorithm","slug":"Algorithm","date":"2020-10-01T14:42:29.000Z","updated":"2020-11-23T06:13:28.521Z","comments":true,"path":"2020/10/01/Algorithm/","link":"","permalink":"http://wangba.me/2020/10/01/Algorithm/","excerpt":"","text":"​ 最近实习后发现自己的算法能力急剧下降，CRUD 只是下限，算法才是上限，决定重新开一个系列，将数据结构与算法重新学一遍。这次主要参考的课程是《数据结构与算法之美》和《算法面试通关40讲》。这里就不像《算法导论》那样比较理论化，应该会更偏向于《算法》这本书的类型。 可以看到下面这些有趣的点： 🐷 尽量利用图 + 文字，清晰的表达意思 🐢 一定要结合 Leetcode 上的题目 🐭 尽量介绍一些没用有趣的小 Tips 🐦 使用 Java 来实现所有的算法","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"}]},{"title":"SpringBoot整合Spring Security (三)","slug":"SpringBoot整合Spring-Security-三","date":"2020-09-30T06:47:27.000Z","updated":"2020-09-30T08:49:43.318Z","comments":true,"path":"2020/09/30/SpringBoot整合Spring-Security-三/","link":"","permalink":"http://wangba.me/2020/09/30/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%89/","excerpt":"","text":"一、OverView​ 在前后端不分离时代，可能使用的就是上一节中这种方法；在现在这种前后端分离遍地走的情况下，已经不再推荐使用传统的 session ，而是使用现在比较流行的 JWT 这种 token 的方式解决 ​ 对比分析一下： 有状态登录 无状态登录 定义 服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理 服务端不保存任何客户端请求者信息；客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 优点 比较方便，不需要做多余的处理 使用 token 很灵活；服务端不需要存数据；客户端也可以发送给多个服务器 缺点 只能是网页端，在 IOS、Android不行；服务端保存大量数据；集群化不太行 配置稍微复杂(其实在框架的加成下，不复杂) 有状态登录 🌰：在 Tomcat 中，用户登录后，需要把用户的信息保存在服务器的 session 中，然后发送给用户一个 Cookie 值，记录对应的 session 值，等用户下一次再次访问该服务器时，浏览器会自动带上这个 Cookie 值，服务端再识别其中的 session 值，进行判断 无状态登录 🌰：客户端发送账户密码到服务端进行验证；认证后服务端发送一个 token 给客户端；以后客户端每次发送请求都将 token 携带上进行认证，进行判断 二、Test​ 在前后端分离的基础上，现在前端和后端只是通过 JSON 进行交互，所以现在的页面跳转全部由前端进行控制，后端只是返回不同的 JSON 罢了 重写SecurityConfig中的 configure 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() // 登出页面 + 登出成功后页面 .logout() .logoutUrl(&quot;/logout&quot;) .logoutSuccessUrl(&quot;/login.html&quot;) .logoutSuccessHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123; httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close(); &#125;) .and() // 登录页面 + 登录接口 .formLogin().loginPage(&quot;/login.html&quot;) .loginProcessingUrl(&quot;/securityLogin&quot;) .permitAll() // 登录失败处理器 .failureHandler((httpServletRequest, httpServletResponse, e) -&gt; &#123; httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(e.getMessage()); out.flush(); out.close(); &#125;) // 登录成功处理器 .successHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123; Object principal = authentication.getPrincipal(); httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close(); &#125;) .and() .csrf().disable() ;&#125; 登录接口 注： 可以看到使用前后端分离，就不需要后端来控制跳转页面等，只需要将 JSON 发给前端就行 这里面的 password 为空，是框架做的，具体可以看这里 登录失败 注： 无论是用户名和密码其中一个错误，就会返回 Bad credentials 提示，主要也是为了安全着想，具体流程可以看下面的 3.1 小节 注销登录 三、Deep Learning3.1 深入了解登录失败​ 在上面我们提到了无论是用户名和密码其中一个错误，就会返回 Bad credentials，实则在其中还有很多种错误，而且用户名是有用户名错误，只是最终被 Bad credentials 覆盖了，稍微分析一下： AbstractUserDetailsAuthenticationProvider 12345678910111213141516171819public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123; return this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;); &#125;); String username = authentication.getPrincipal() == null ? &quot;NONE_PROVIDED&quot; : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (UsernameNotFoundException var6) &#123; this.logger.debug(&quot;User &#x27;&quot; + username + &quot;&#x27; not found&quot;); if (this.hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; // 省略&#125; 在上面这段代码中，进行调试可以看见： 会先在缓存中查询一下是否有过 再调用 retrieveUser 来进行判断 一旦抛出 UsernameNotFoundException ，就看 hideUserNotFoundExceptions 的值了，如果为 true，就会抛出 Bad credentials 进行断点调试：输错用户名，并打上断点： 通过上图就能看出，hideUserNotFoundExceptions 默认值是 true 的 3.2 未认证处理在前后端分离，如果出现未认证的状态，不可能控制前端来跳转页面等，只能给前端返回相应的信息即可： 在 AuthenticationEntryPoint 接口中有一个方法：commence 在 LoginUrlAuthenticationEntryPoint 中实现方式为： 1234567891011121314151617181920212223public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; String redirectUrl = null; if (this.useForward) &#123; if (this.forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) &#123; redirectUrl = this.buildHttpsRedirectUrlForRequest(request); &#125; if (redirectUrl == null) &#123; String loginForm = this.determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Server side forward to: &quot; + loginForm); &#125; RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); dispatcher.forward(request, response); return; &#125; &#125; else &#123; redirectUrl = this.buildRedirectUrlToLoginPage(request, response, authException); &#125; this.redirectStrategy.sendRedirect(request, response, redirectUrl);&#125; 这段代码中最主要的是看一下 useForward 的默认值，如果是 true，那么默认就是走转发；如果是 false，那么默认走的就是重定向 使出断点调试大法： 在 Postman 中直接使用 GET 方式请求：localhost:8080/security 此方法在第一节中已经写过了，就是输出一个 Spring Security 在方法内打上断点 从上面的图就可以看见，useForward 的默认值是 false，那么就可以确定是走的重定向 只需要重写该方法覆盖它就行： 12345678.exceptionHandling().authenticationEntryPoint((req, resp, authException) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close();&#125;)","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security (二)","slug":"SpringBoot整合Spring-Security-二","date":"2020-09-28T10:13:07.000Z","updated":"2020-09-30T07:09:26.232Z","comments":true,"path":"2020/09/28/SpringBoot整合Spring-Security-二/","link":"","permalink":"http://wangba.me/2020/09/28/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%BA%8C/","excerpt":"","text":"一、Test环境与上一节的环境一致，这一节主要来进行自定义操作 在 SecurityConfig 中重写这两个方法： 12345678910111213141516@Overridepublic void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;);&#125;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() ;&#125; 自行写一个登录页面： login.html 中的核心代码 123456789101112131415161718&lt;form action=&quot;/login.html&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;input&quot; style=&quot;text-align: center&quot;&gt; &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;name&quot;&gt; &lt;span class=&quot;spin&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;input&quot; style=&quot;text-align: center&quot;&gt; &lt;label for=&quot;pass&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;pass&quot;&gt; &lt;span class=&quot;spin&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;button login&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot;&gt; &lt;span&gt;登录&lt;/span&gt; &lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 主要注意以下几个方面： form 的请求地址是 /login.html，方法是 post 用户名和密码的属性值分别是 username 和 password 二、Deep Learning 🐢之疑问一：为啥默认的登录页面和登录接口是一样的？自定义页面又是如何覆盖默认页面的呢？ 默认登录页面 关于页面的登录的配置都在：FormLoginConfigurer 其中这个类又是继承 AbstractAuthenticationFilterConfigurer 类的 则在 FormLoginConfigurer 初始化的时候，AbstractAuthenticationFilterConfigurer 的构造方法中： 123protected AbstractAuthenticationFilterConfigurer() &#123; setLoginPage(&quot;/login&quot;);&#125; 此时如果没有自定义登录页面，就会是 项目地址/login 这个地址 再看一下 FormLoginConfigurer 中的 init 方法： 1234public void init(H http) throws Exception &#123; super.init(http); initDefaultLoginFilter(http);&#125; 这个方法是调用了父类的 init 方法： 12345public void init(B http) throws Exception &#123; updateAuthenticationDefaults(); updateAccessDefaults(http); registerDefaultAuthenticationEntryPoint(http);&#125; 在父类的 init 方法中调用了 updateAuthenticationDefaults() 方法： 123456789101112131415protected final void updateAuthenticationDefaults() &#123; // 未自定义页面，就会和 loginPage 地址一样 if (loginProcessingUrl == null) &#123; loginProcessingUrl(loginPage); &#125; if (failureHandler == null) &#123; failureUrl(loginPage + &quot;?error&quot;); &#125; final LogoutConfigurer&lt;B&gt; logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null &amp;&amp; !logoutConfigurer.isCustomLogoutSuccess()) &#123; logoutConfigurer.logoutSuccessUrl(loginPage + &quot;?logout&quot;); &#125;&#125; 此时就能看到：如果我们没有自定义登录接口，那么登录接口的地址就会被设置为和登录页面一致 自定义登录页面 如果自定义了页面地址，首先会到 FormLoginConfigurer 中 123public FormLoginConfigurer&lt;H&gt; loginPage(String loginPage) &#123; return super.loginPage(loginPage);&#125; 在这里面调用了父类的 loginPage 方法： 123456protected T loginPage(String loginPage) &#123; setLoginPage(loginPage); updateAuthenticationDefaults(); this.customLoginPage = true; return getSelf();&#125; 可以看到，在这里面 set 完 loginPage 后，又双调用了 updateAuthenticationDefaults() 方法，这个方法在 ☝️ 有 如果自定义了登录接口 loginProcessingUrl ，那么就会进入这个方法： 123456public T loginProcessingUrl(String loginProcessingUrl) &#123; this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf();&#125; 🐢之疑问二：在提交的表单中，参数分别为 username 和 password，可不可以自定义呢？ 首先还是去 FormLoginConfigurer 类中看看构造方法： 12345public FormLoginConfigurer() &#123; super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;);&#125; 这里的 super 根据 👆 的继承关系，就可以知道是 AbstractAuthenticationFilterConfigurer 中的构造： 123456789protected AbstractAuthenticationFilterConfigurer(F authenticationFilter, String defaultLoginProcessingUrl) &#123; this(); // 将传进来的参数赋值给这个类的 authFilter this.authFilter = authenticationFilter; if (defaultLoginProcessingUrl != null) &#123; loginProcessingUrl(defaultLoginProcessingUrl); &#125;&#125; 注：这里为什么能传参，是由于 UsernamePasswordAuthenticationFilter 继承 AbstractAuthenticationProcessingFilter 且 F extends AbstractAuthenticationProcessingFilter 此时已经有了 UsernamePasswordAuthenticationFilter 的实例了，接着执行 usernameParameter 和 passwordParameter 方法： 123456789public FormLoginConfigurer&lt;H&gt; usernameParameter(String usernameParameter) &#123; getAuthenticationFilter().setUsernameParameter(usernameParameter); return this;&#125;public FormLoginConfigurer&lt;H&gt; passwordParameter(String passwordParameter) &#123; getAuthenticationFilter().setPasswordParameter(passwordParameter); return this;&#125; 这里的 getAuthenticationFilter 是父类的方法： 123protected final F getAuthenticationFilter() &#123; return authFilter;&#125; 到这里就很明确了，就是将刚才的 new UsernamePasswordAuthenticationFilter() 放到这里面分别调用 setUsernameParameter 和 setPasswordParameter 方法： 123456789public void setUsernameParameter(String usernameParameter) &#123; Assert.hasText(usernameParameter, &quot;Username parameter must not be empty or null&quot;); this.usernameParameter = usernameParameter;&#125;public void setPasswordParameter(String passwordParameter) &#123; Assert.hasText(passwordParameter, &quot;Password parameter must not be empty or null&quot;); this.passwordParameter = passwordParameter;&#125; 到这里，usernameParameter 和 passwordParameter 就已经被赋好值了 再通过这个类 (UsernamePasswordAuthenticationFilter) 中的这两个方法从登录请求中拿到这两个值： 123456789@Nullableprotected String obtainPassword(HttpServletRequest request) &#123; return request.getParameter(this.passwordParameter);&#125;@Nullableprotected String obtainUsername(HttpServletRequest request) &#123; return request.getParameter(this.usernameParameter);&#125; 那么自定义就很简单了： 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginPage(&quot;/login.html&quot;) // 只需要设置以下两项就行 .usernameParameter(&quot;user&quot;) .passwordParameter(&quot;pwd&quot;) .permitAll() .and() .csrf().disable() ;&#125; 🐢之疑问三：登录成功 or 失败后的重定向的地址，注销登录的地址如何自定义？ 登录成功 登录失败 defaultSuccessUrl failureForwardUrl successForwardUrl failureUrl 区别简单来说就是： defaultSuccessUrl 可能你访问的地址是 http://localhost:8080/security 但是你没登录，所以你就跳转到 http://localhost:8080/login 页面下，如果你登录成功，那么就会回到 /security 页面 successForwardUrl 不管是什么页面，登录成功一律是你设置的页面 登录失败同理 注销登录 看下面的代码 logoutUrl：用来注销的地址，默认为 “/logout” logoutRequestMatcher：改变注销地址，还有请求方式 logoutSuccessUrl：注销登录成功后，要跳转的地址 12345678910111213141516171819202122232425262728293031@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() // 注销登录设置 .logout() .logoutUrl(&quot;&quot;) .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) .logoutSuccessUrl(&quot;&quot;) // 登录设置 .and() .formLogin().loginPage(&quot;/login.html&quot;) .usernameParameter(&quot;user&quot;) .passwordParameter(&quot;pwd&quot;) // 下面两个只需要一个 .defaultSuccessUrl(&quot;&quot;) .successForwardUrl(&quot;&quot;) // 下面两个只需要一个 .failureForwardUrl(&quot;&quot;) .failureUrl(&quot;&quot;) .permitAll() .and() .csrf().disable() ;&#125;","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security (一)","slug":"SpringBoot整合Spring-Security-一","date":"2020-09-27T10:52:23.000Z","updated":"2020-09-30T07:09:23.777Z","comments":true,"path":"2020/09/27/SpringBoot整合Spring-Security-一/","link":"","permalink":"http://wangba.me/2020/09/27/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%80/","excerpt":"","text":"一、OverViewJava 中权限管理最常用的技术应该就是：Spring Security 和 Shiro。 虽然 Shiro 用它轻量、简单、易于集成占据一席之地，但随着 SpringBoot 的流行，Spring Security 也跟着鸡犬升天，就目前的趋势来看，Spring Security 结合 Oauth2、JWT 等更加方便。 这次先小试牛刀一下，快速入门…… 二、Environment不想 error ，先看依赖 没看错，就只需要这两个依赖就行 pom.xml 12345678910&lt;!--security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SecurityController 12345678@RestControllerpublic class SecurityController &#123; @GetMapping(&quot;/security&quot;) public String hello() &#123; return &quot;spring security&quot;; &#125;&#125; 三、Test启动项目可以看见，在控制台多了一行： Postman 可以看见报错：401，没有进行认证 加上认证 可以看见，加上 Basic Auth： 其中用户名为 user，密码为刚才控制台显示的即可 四、Deep Learning🐢之疑问：为啥用户名是 user，密码就是控制台显示的那个？ 分析思路： 用户名和密码肯定在一起，这个密码又是 UUID 形式，某个地方肯定用了 UUID.randomUUID().toString() 按照我们对 SpringBoot 的特性，肯定在 XXXAutoConfiguration 和 XXXProperties 中存在，果然在 SecurityProperties 中看到了： 接下来，我们要去找一找，在哪里有调用 getPassword 的这个方法的类： 看名字应该就是：UserDetailsServiceAutoConfiguration 12345678910private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) &#123; String password = user.getPassword(); if (user.isPasswordGenerated()) &#123; logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword())); &#125; if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123; return password; &#125; return NOOP_PASSWORD_PREFIX + password;&#125; 其中： user.isPasswordGenerated() 如果为 true，则打印该信息 再去 ==user.isPasswordGenerated()== 方法中探究一下，回到了==SecurityProperties== 类中了： 1234567private boolean passwordGenerated = true; .......public boolean isPasswordGenerated() &#123; return this.passwordGenerated;&#125; 默认情况下：passwordGenerated 就是为 true 🐢之疑问：每次启动都要输入新的的密码，太麻烦了，我需要自定义 第一种方法： 按照 SpringBoot 的特性，必然已经给你安排好了，肯定有一种方法是在 properties 文件中直接进行： idea 已经通过提示显示出来了, idea yyds ! 直接点进去看一下，回跳到哪个类中，不出🐢🐢的所料，应该就是 ==SecurityProperties== 类中： 果不其然，分别跳到了 setName 123public void setName(String name) &#123; this.name = name;&#125; setPassword 1234567public void setPassword(String password) &#123; if (!StringUtils.hasLength(password)) &#123; return; &#125; this.passwordGenerated = false; this.password = password;&#125; 注：如果在这里自定义了密码，就会将 ==passwordGenerated== 设置为 false，那么在 ==isPasswordGenerated== 就是 false 了，在 ==UserDetailsServiceAutoConfiguration== 中就不会自动生成密码了 application.properties 12spring.security.user.name=wangbaspring.security.user.password=8888 第二种方法： 123456789101112131415161718@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean PasswordEncoder passwordEncoder() &#123; // 不对密码进行任何编码方式 return NoOpPasswordEncoder.getInstance(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;wangba&quot;) .password(&quot;guigui&quot;) .roles(&quot;admin&quot;) ; &#125;&#125;","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Session","slug":"SpringBoot整合Session","date":"2020-09-22T13:43:13.000Z","updated":"2020-09-30T07:09:20.959Z","comments":true,"path":"2020/09/22/SpringBoot整合Session/","link":"","permalink":"http://wangba.me/2020/09/22/SpringBoot%E6%95%B4%E5%90%88Session/","excerpt":"","text":"一、OverView Spring Session has the simple goal of free up session management from the limitations of the HTTP session stored in the server. The solution makes it easy to share session data between services in the cloud without being tied to a single container (i.e. Tomcat). Additionally, it supports multiple sessions in the same browser and sending sessions in a header. 简单地来说：由架构导致了这种情况的发生 present 最早的架构就是很简单的单服务器状态，如果我们要保存用户状态，那么只需要一个 session 就行了 now 现在的架构都是集群式了：可以假设这样的情景，如果我在已经登录的状态，我首先要看视频 (这个服务假如在 A 服务器上)，然后我又浏览图片 (这个服务假如在 B 服务器上)，如果不共享 session 的话，那么我选择的服务不在一个服务器上就要重新登录了，这对用户也太不友好了。 解决方案 主流的解决方案：将 seesion 存到 redis 中，每次 server 要向 session 中写数据，或者要读 session 的数据时，都是对 redis 中的 session 进行操作。 二、环境搭建不想 error ，先看依赖 pom.xml 123456789101112131415&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--spring session--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 1234567891011# redis 基本配置# 地址spring.redis.host=10.2.10.115# 端口号 默认就是 6379spring.redis.port=6379# 密码spring.redis.password=123456# 第几个数据库 默认就是第0号数据库spring.redis.database=0server.port=8080 SessionController 1234567891011121314151617@RestControllerpublic class SessionController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) Integer port; @GetMapping(&quot;/set&quot;) public String set(HttpSession session) &#123; session.setAttribute(&quot;wangba&quot;, &quot;8888&quot;); return String.valueOf(port); &#125; @GetMapping(&quot;/get&quot;) public String get(HttpSession session) &#123; return session.getAttribute(&quot;user&quot;) + &quot;:&quot; + port; &#125;&#125; 三、测试访问：http://localhost:8080/set 此时打开 redis 看一下： 再访问：http://localhost:8081/get 可以看到此时，在不同的服务上可以通过共享 session 注：这边可以通过 nginx 进行负载均衡","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Session","slug":"Session","permalink":"http://wangba.me/tags/Session/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2020-09-16T13:34:57.000Z","updated":"2020-09-30T07:09:18.512Z","comments":true,"path":"2020/09/16/SpringBoot整合Redis/","link":"","permalink":"http://wangba.me/2020/09/16/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"","text":"一、OverView面试官：redis 知道吗 🐢：不知道 面试官：你回去等通知吧 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。在2013年5月之前，其开发由VMware赞助。https://zh.wikipedia.org/wiki/Redis#cite_note-5)根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。 ——–维基百科 我记得我看过一篇讲的非常好的 NoSQL 的文章，下次找到加进来。 增加：关系型数据库与非关系型数据库 二、环境搭建Redis 首先准备好 redis 的环境，此次 redis 是安装在 Ubuntu 18.04 上的，主要配置如下： 可以使用 sudo vi /etc/redis/redis.conf 命令： 123456789101112131415# 该指令允许您声明一个init系统来管理Redis作为服务，从而为您提供对其操作的更多控制supervised systemd# 为了局域网能连接上bind 127.0.0.1 ::1 改为bind 0.0.0.0# 为了局域网能连接上protected-mode yes 改为protected-mode no# 修改密码，非必须requirepass 123456 常用命令： 1234567891011121314151617181920# 修改 redis 配置sudo vi /etc/redis/redis.conf# 重启 redis 服务sudo service redis restart# 启动 redis 服务sudo service redis start# 关闭 redis 服务sudo service redis stop# 启动 redis 客户端，其中 -p 指定端口，-a 表示认证即密码redis-cli -p 6379 -a 123456# 在 redis 里面的一些命令127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; keys *127.0.0.1:6379&gt; get key的名字 pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 123456789# redis 基本配置# 地址spring.redis.host=10.2.10.108# 端口号 默认就是 6379spring.redis.port=6379# 密码spring.redis.password=123456# 第几个数据库 默认就是第0号数据库spring.redis.database=0 三、测试RedisController 12345678910111213141516171819202122@RestControllerpublic class RedisController &#123; private StringRedisTemplate stringRedisTemplate; @Autowired public void setStringRedisTemplate(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @GetMapping(&quot;/put&quot;) public void test1(String key, String value) &#123; ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(key, value); &#125; @GetMapping(&quot;/get&quot;) public String test2(String key) &#123; ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); return ops.get(key); &#125;&#125; Postman 首先将 redis 清空： 插入： 看下 redis 中： 查询：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://wangba.me/tags/NoSQL/"}]},{"title":"铁氏王朝满汉全席 919","slug":"铁氏王朝满汉全席-919","date":"2020-09-15T13:23:00.000Z","updated":"2020-09-30T07:09:13.230Z","comments":true,"path":"2020/09/15/铁氏王朝满汉全席-919/","link":"","permalink":"http://wangba.me/2020/09/15/%E9%93%81%E6%B0%8F%E7%8E%8B%E6%9C%9D%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD-919/","excerpt":"","text":"919 铁氏王朝满汉全席 v1.3 清蒸大闸蟹 5只 材料： 阳澄湖大闸蟹 生姜 蒜瓣 香葱 紫苏 生抽 香醋 料酒 香油 鸡精 糖 可乐鸡翅 材料： 鸡翅10个 可乐300毫升 老抽1勺 盐，鸡精适量 葱姜，八角适量 糖醋排骨 材料： 猪肋排500克 葱适量 姜适量 八角2个 老抽2勺 生抽2勺 白糖3勺 香醋4勺 料酒5勺 熟白芝麻适量 麻辣小龙虾 材料： 小龙虾30斤 香葱适量 姜适量 蒜适量 大葱适量 桂皮适量 八角适量 香叶适量 紫苏适量 小米椒适量 冰糖适量 藕条适量 青椒适量 红油火锅底料适量 豆瓣酱适量 淀粉适量 白芝麻适量 芝士培根泡菜卷 材料： 蒜蓉金针菇 材料： 金针菇1把 蒜一头 食用油适量 酱油4勺 蚝油2勺 小葱4根 鸡精适量 糖 盐 酒酿小汤圆冲鸡蛋 材料： 姜撞奶 材料： 老姜1大块 纯牛奶200毫升 细砂糖适量 蔓越莓干少许","categories":[{"name":"WangBa's CookBook","slug":"WangBa-s-CookBook","permalink":"http://wangba.me/categories/WangBa-s-CookBook/"}],"tags":[{"name":"CookBook","slug":"CookBook","permalink":"http://wangba.me/tags/CookBook/"},{"name":"Life","slug":"Life","permalink":"http://wangba.me/tags/Life/"}]},{"title":"SpringBoot整合Spring Data JPA 之多条件搜索工具类","slug":"SpringBoot整合Spring-Data-JPA-之多条件搜索工具类","date":"2020-09-14T12:21:20.000Z","updated":"2020-09-30T07:08:37.925Z","comments":true,"path":"2020/09/14/SpringBoot整合Spring-Data-JPA-之多条件搜索工具类/","link":"","permalink":"http://wangba.me/2020/09/14/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%B9%8B%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"一、OverView​ 在前面已经介绍过了 SpringBoot 整合 JPA 了，但是一般在公司业务中，如果出现很多次多条件搜索查询的情况，那么就会用大量冗余代码了；再结合注解的思想。本次将公共部分提取出来，并用注解的方式进行操作，可以参考前面使用注解进行 AOP 处理日志，也符合了 SpringBoot 的思想。 二、BaseQueryQueryWord 12345678910111213141516171819@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface QueryWord &#123; // 数据库中字段名,默认为空字符串,则Query类中的字段要与数据库中字段一致 String column() default &quot;&quot;; // equal, like, gt, lt... MatchType func() default MatchType.equal; // object是否可以为null boolean nullable() default false; // 字符串是否可为空 boolean empty() default false; // between...and... 查询语句标识， 0时间 1数字类型 BetweenType type() default BetweenType.datetime;&#125; 注：注解类，只要在要查询的属性上加上相应的注解即可 MatchType 12345678910111213141516171819202122public enum MatchType &#123; equal, // filed = value // 下面四个用于Number类型的比较 gt, // filed &gt; value ge, // field &gt;= value lt, // field &lt; value le, // field &lt;= value notEqual, // field != value like, // field like value notLike, // field not like value between, // between value1 and value2 ,Type is Date // 下面四个用于可比较类型(Comparable)的比较 greaterThan, // field &gt; value greaterThanOrEqualTo, // field &gt;= value lessThan, // field &lt; value lessThanOrEqualTo // field &lt;= value&#125; 注：枚举类，可以对比注释进行理解 BetweenType 1234567public enum BetweenType &#123; datetime, number_long, number_integer&#125; 注：对应上面 QueryWord中的 BetweenType ，可以对时间或数字之间的属性进行注解 BaseQuery 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public abstract class BaseQuery&lt;T&gt; &#123; // 第多少页 + 页大小 private int pageNum = 0; private int pageSize = 10; // private static Map&lt;Class, List&lt;Field&gt;&gt; fieldCache = new HashMap&lt;&gt;(); // 动态查询 public abstract Specification&lt;T&gt; toSpec(); // 分页 public Pageable toPageable() &#123; return PageRequest.of(pageNum, pageSize); &#125; // 分页 + 排序 public Pageable toPageable(Sort sort) &#123; return PageRequest.of(pageNum, pageSize, sort); &#125; // 动态查询 and 连接 protected Specification&lt;T&gt; toSpecWithAnd() &#123; return this.toSpecWithLogicType(&quot;and&quot;); &#125; // 动态查询 or 连接 protected Specification&lt;T&gt; toSpecWithOr() &#123; return this.toSpecWithLogicType(&quot;or&quot;); &#125; // logicType = or ｜ and @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;) private Specification&lt;T&gt; toSpecWithLogicType(final String logicType) &#123; final BaseQuery outerThis = this; // 封装条件查询对象 Specification Specification&lt;T&gt; specification = new Specification&lt;T&gt;() &#123; @Override // Root 用于获取属性字段，CriteriaQuery可以用于简单条件查询，CriteriaBuilder 用于构造复杂条件查询 public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Class clazz = outerThis.getClass(); // 判断缓存中是否已经存在，存在不需要再次生成，不存在需要重新生成 List&lt;Field&gt; fields = fieldCache.get(clazz); if (fields == null) &#123; // 获取查询类Query的所有字段,包括父类字段 fields = getAllFieldsWithRoot(clazz); fieldCache.put(clazz, fields); &#125; List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(fields.size()); for (Field field : fields) &#123; // 获取字段上的 @QueryWord 注解 QueryWord qw = field.getAnnotation(QueryWord.class); if (qw == null) &#123; continue; &#125; // 获取字段名 String column = qw.column(); //如果主注解上 column 为默认值&quot;&quot;,则以 field 为准 if (column.equals(&quot;&quot;)) &#123; column = field.getName(); &#125; field.setAccessible(true); try &#123; // nullable Object value = field.get(outerThis); // 如果值为 null,注解未标注 nullable,跳过 if (value == null &amp;&amp; !qw.nullable()) &#123; continue; &#125; // can be empty if (value != null &amp;&amp; String.class.isAssignableFrom(value.getClass())) &#123; String s = (String) value; //如果值为&quot;&quot;,且注解未标注 empty ,跳过 if (s.equals(&quot;&quot;) &amp;&amp; !qw.empty()) &#123; continue; &#125; &#125; //通过注解上 func 属性,构建路径表达式 Path path = root.get(column); switch (qw.func()) &#123; case equal: predicates.add(cb.equal(path, value)); break; case like: predicates.add(cb.like(path, &quot;%&quot; + value + &quot;%&quot;)); break; case gt: predicates.add(cb.gt(path, (Number) value)); break; case lt: predicates.add(cb.lt(path, (Number) value)); break; case ge: predicates.add(cb.ge(path, (Number) value)); break; case le: predicates.add(cb.le(path, (Number) value)); break; case notEqual: predicates.add(cb.notEqual(path, value)); break; case notLike: predicates.add(cb.notLike(path, &quot;%&quot; + value + &quot;%&quot;)); break; case greaterThan: predicates.add(cb.greaterThan(path, (Comparable) value)); break; case greaterThanOrEqualTo: predicates.add(cb.greaterThanOrEqualTo(path, (Comparable) value)); break; case lessThan: predicates.add(cb.lessThan(path, (Comparable) value)); break; case lessThanOrEqualTo: predicates.add(cb.lessThanOrEqualTo(path, (Comparable) value)); break; case between: switch (qw.type()) &#123; case datetime: List&lt;Date&gt; dateList = (List&lt;Date&gt;) value; predicates.add(cb.between(path, dateList.get(0), dateList.get(1))); break; case number_long: List&lt;Long&gt; longList = (List&lt;Long&gt;) value; predicates.add(cb.between(path, longList.get(0), longList.get(1))); break; case number_integer: List&lt;Integer&gt; integerList = (List&lt;Integer&gt;) value; predicates.add(cb.between(path, integerList.get(0), integerList.get(1))); break; &#125; &#125; &#125; catch (Exception e) &#123; continue; &#125; &#125; Predicate p = null; if (logicType == null || logicType.equals(&quot;&quot;) || logicType.equals(&quot;and&quot;)) &#123; p = cb.and(predicates.toArray(new Predicate[predicates.size()])); // and 连接 &#125; else if (logicType.equals(&quot;or&quot;)) &#123; p = cb.or(predicates.toArray(new Predicate[predicates.size()])); // or 连接 &#125; return p; &#125; &#125;; return specification; &#125; //获取类 clazz 的所有 Field，包括其父类的 Field private List&lt;Field&gt; getAllFieldsWithRoot(Class&lt;?&gt; clazz) &#123; List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;(); Field[] dFields = clazz.getDeclaredFields(); //获取本类所有字段 if (null != dFields &amp;&amp; dFields.length &gt; 0) &#123; fieldList.addAll(Arrays.asList(dFields)); &#125; // 若父类是 Object，则直接返回当前 Field 列表 Class&lt;?&gt; superClass = clazz.getSuperclass(); if (superClass == Object.class) &#123; return Arrays.asList(dFields); &#125; // 递归查询父类的 Field 列表 List&lt;Field&gt; superFields = getAllFieldsWithRoot(superClass); if (null != superFields &amp;&amp; !superFields.isEmpty()) &#123; for (Field field : superFields) &#123; if (!fieldList.contains(field)) &#123; fieldList.add(field); &#125; &#125; &#125; return fieldList; &#125; public int getPageIndex() &#123; return pageNum; &#125; public void setPageIndex(int pageIndex) &#123; this.pageNum = pageIndex; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 注：最关键的类 所有后面要查询的类都要继承它 简单的理解：通过反射获取注解上的字段信息，构造相应的搜索条件 三、TestStudentQuery 123456789101112131415public class StudentQuery extends BaseQuery&#123; @QueryWord(column = &quot;id&quot;, func = MatchType.equal) private Long id; @QueryWord(func = MatchType.like) private String name; // 省略 set / get @Override public Specification toSpec() &#123; return super.toSpecWithOr(); &#125;&#125; 在这个查询中，使用的是 or 查询，测试类如下： Test 123456789101112@Testpublic void find8() &#123; StudentQuery studentQuery = new StudentQuery(); studentQuery.setId(1L); studentQuery.setName(&quot;er&quot;); studentQuery.setPageIndex(0); studentQuery.setPageSize(10); Page page = studentRepository.findAll(studentQuery.toSpec(), studentQuery.toPageable()); for (Object o : page.getContent()) &#123; System.out.println(o); &#125;&#125; 注：构造的条件是 id = 1的，或者 name = ? er ? 的 student 结果 通过这个例子简单捋一下整个过程： 通过 studentQuery.toSpec() 调用父类 BaseQuery； 在 BaseQuery 中，通过反射获得打了相应注解上的字段信息； 将字段信息加到搜索条件中，进行 or 或者 and 连接 注：如果你的业务中只用了很少的条件或者只用极个别的多条件查询，可以不用这个工具类","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合Spring Data JPA(二)","slug":"SpringBoot整合Spring-Data-JPA-二","date":"2020-09-10T10:38:46.000Z","updated":"2020-09-30T07:08:31.365Z","comments":true,"path":"2020/09/10/SpringBoot整合Spring-Data-JPA-二/","link":"","permalink":"http://wangba.me/2020/09/10/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%BA%8C/","excerpt":"","text":"一、OverView​ 在上一篇文章中介绍了一下 Spring Data JPA 的一下简单的 CRUD，但是在公司业务中，不可能这么简单；且在业务中大部分都是查询业务，具体点就是动态查询，什么单表多条件查询、多表多条件查询等等…… 注：使用环境还是和上一篇一样 二、自定义SQL查询如果想和这里面写原生的 SQL 语句，只要在 repository 中这样写就行： 123@Query(nativeQuery = true, value = &quot;select * from Student where id = ?1&quot;)Student catchAllById(Long id); 注： 如果要写原生 SQL，@Query 注解中的 nativeQuery 要设置为 true，默认为 false 函数名设置的不能与自带的冲突，例如：findById，如果设置了一样，就会导致使用的自带的 API 进行查询，而不是自定义的，如果真的想使用自定义覆盖自带的，可以在实体类上使用 @NamedQueries 注解 在这里我们就使用 @Test 进行测试： 还有一种使用 JPQL 语法的查询方式： repository: 12@Query(value = &quot;select s from Student s where s.name = ?1&quot;)List&lt;Student&gt; catchByName(String name); Test: 关于 JPQL：和在 SQL 中一样，JPQL 中的 select 语句用于执行查询。其语法可表示为：select_clause form_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause] 其中： from 子句是查询语句的必选子句。 select 用来指定查询返回的结果实体或实体的某些属性。 from 子句声明查询源实体类，并指定标识符变量（相当于SQL表的别名）。 如果不希望返回重复实体，可使用关键字 distinct 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。 在 JPQL 中，查询所有实体的 JPQL 查询语句很简单，如下：select o from Order o 或 select o from Order as o这里关键字 as 可以省去，标识符变量的命名规范与 Java 标识符相同，且区分大小写 更多参考：官网文档 三、自定义简单查询在 Spring Data JPA 的官网也介绍了这种方式，一般这种方式在一些小项目中也经常使用： Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname,findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection&lt;Age&gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&lt;Age&gt; ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 原理大概如下： 假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 从右往左截取第一个大写字母开头的字符串此处为Uuid），然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设user为查询实体的一个属性； 接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 Doc.user.depUuid 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 Doc.user.dep.uuid 的值进行查询。 可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 findByUser_DepUuid() 或者 findByUserDep_uuid() repository: 1234567891011List&lt;Student&gt; findByName(String name);List&lt;Student&gt; findByNameAndPwd(String name, String pwd);List&lt;Student&gt; findByNameStartingWith(String name);List&lt;Student&gt; findByNameEndingWith(String name);List&lt;Student&gt; findByNameContaining(String name);List&lt;Student&gt; findByNameContainingOrderByIdDesc(String name); test: findByName findByNameAndPwd findByNameStartingWith findByNameEndingWith findByNameContaining findByNameContainingOrderByIdDesc 四、分页查询12345678910// 分页 + 排序@Testpublic void find6() &#123; Sort sort = Sort.by(Sort.Direction.DESC, &quot;id&quot;); PageRequest pageRequest = PageRequest.of(0, 2, sort); Page&lt;Student&gt; studentPage = studentRepository.findAll(pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; 注： Sort.by(排序方式, 排序字段) PageRequest.of(第多少页，页大小) ——–&gt; 一般是写一个 PageUtils Test 五、动态查询1234567891011121314151617// 分页 + 排序 + 搜索@Testpublic void find7() &#123; PageRequest pageRequest = PageRequest.of(0, 2, Sort.by(Sort.Direction.DESC, &quot;id&quot;)); Specification&lt;Student&gt; specification = new Specification&lt;Student&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) &#123; // 增加搜索条件: id &lt;= 5 Predicate predicate = criteriaBuilder.lessThanOrEqualTo(root.get(&quot;id&quot;), 5); return predicate; &#125; &#125;; Page&lt;Student&gt; studentPage = studentRepository.findAll(specification, pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; 注： root: 代表查询的实体类 query: 可以从中得到 Root 对象 criteriaBuilder: 用于创建 Criteria 相关对象的工厂 Predicate: 代表一个查询条件 Test: 多条件： 123456789101112131415161718// 分页 + 排序 + 搜索@Testpublic void find7() &#123; PageRequest pageRequest = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, &quot;id&quot;)); List&lt;Predicate&gt; predicateList = new ArrayList&lt;&gt;(); Specification&lt;Student&gt; specification = new Specification&lt;Student&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) &#123; predicateList.add(criteriaBuilder.lessThanOrEqualTo(root.get(&quot;id&quot;), 5)); predicateList.add(criteriaBuilder.like(root.get(&quot;name&quot;), &quot;%&quot; + &quot;er&quot;)); return criteriaBuilder.and(predicateList.toArray(new Predicate[predicateList.size()])); &#125; &#125;; Page&lt;Student&gt; studentPage = studentRepository.findAll(specification, pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; Test:","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合Spring Data JPA(一)","slug":"SpringBoot整合Spring-Data-JPA-一","date":"2020-09-10T10:38:30.000Z","updated":"2020-09-30T07:08:34.596Z","comments":true,"path":"2020/09/10/SpringBoot整合Spring-Data-JPA-一/","link":"","permalink":"http://wangba.me/2020/09/10/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%B8%80/","excerpt":"","text":"一、OverView JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！ spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现 二、环境搭建pom.xml 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; application.properties 123456789101112spring.datasource.url=jdbc:mysql://localhost:3306/jpaspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.jpa.database=mysql# 是否在控制台打印 sql 语句spring.jpa.show-sql=true# 使用 InnoDB 作为引擎 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect# 每次启动都会更新数据库，如：增加字段等，但是对某个字段进行改造是识别不出来spring.jpa.hibernate.ddl-auto=update entiy Student 123456789101112131415161718@Entity@Table(name = &quot;student&quot;)public class Student &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;id&quot;, columnDefinition = &quot;INT UNSIGNED COMMENT &#x27;自增主键&#x27;&quot;) private Long id; @Column(name = &quot;name&quot;, columnDefinition = &quot;VARCHAR(50) NOT NULL COMMENT &#x27;用户名&#x27;&quot;) private String name; @Column(name = &quot;pwd&quot;, columnDefinition = &quot;VARCHAR(100) DEFAULT NULL COMMENT &#x27;密码&#x27;&quot;) private String pwd; // 省略 set get&#125; Grade 1234567891011121314151617@Entity@Table(name = &quot;grade&quot;)public class Grade &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;id&quot;, columnDefinition = &quot;INT UNSIGNED COMMENT &#x27;自增主键&#x27;&quot;) private Long id; @Column(name = &quot;subject&quot;, columnDefinition = &quot;VARCHAR(50) NOT NULL COMMENT &#x27;学科&#x27;&quot;) private String subject; @Column(name = &quot;score&quot;, columnDefinition = &quot;TINYINT UNSIGNED NOT NULL COMMENT &#x27;成绩&#x27;&quot;) private String score; // 省略 set get&#125; 注：这次使用两个表，为了后面进行复杂查询准备，这里的将两个表的自增 id 关联在一起，就不考虑多对多了 repository StudentRepository 123@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt;, JpaSpecificationExecutor&lt;Student&gt; &#123;&#125; GradeRepository 123@Repositorypublic interface GradeRepository extends JpaRepository&lt;Grade, Long&gt;, JpaSpecificationExecutor&lt;Grade&gt; &#123;&#125; 在上次 aop 那里面就提过，由于继承的有 CRUD 的 repository 和一些其他的，这也是上面提到的解放 DAO 层的操作，具体的可以看下图 三、CRUDcontroller GradeController 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/grade&quot;)public class GradeController &#123; private GradeRepository gradeRepository; @Autowired public void setGradeRepository(GradeRepository gradeRepository) &#123; this.gradeRepository = gradeRepository; &#125; @PutMapping(&quot;/add&quot;) public Grade add(@RequestBody Grade grade) &#123; return gradeRepository.save(grade); &#125; @GetMapping(&quot;/query&quot;) public List&lt;Grade&gt; query() &#123; return gradeRepository.findAll(); &#125; @PostMapping(&quot;/update&quot;) public Grade update(@RequestBody Grade grade) &#123; return gradeRepository.save(grade); &#125; @DeleteMapping(&quot;/delete&quot;) public void delete(@RequestParam Long id) &#123; gradeRepository.deleteById(id); &#125;&#125; StudentController 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/student&quot;)public class StudentController &#123; private StudentRepository studentRepository; @Autowired public void setStudentRepository(StudentRepository studentRepository) &#123; this.studentRepository = studentRepository; &#125; @PutMapping(&quot;/add&quot;) public Student add(@RequestBody Student student) &#123; return studentRepository.save(student); &#125; @GetMapping(&quot;/query&quot;) public List&lt;Student&gt; query() &#123; return studentRepository.findAll(); &#125; @PostMapping(&quot;/update&quot;) public Student update(@RequestBody Student student) &#123; return studentRepository.save(student); &#125; @DeleteMapping(&quot;/delete&quot;) public void delete(@RequestParam Long id) &#123; studentRepository.deleteById(id); &#125;&#125; 注： Spring 建议在这里的注入方式是 set 或者 构造注入，不要直接注解注入 为了方便，在这里还是省略了 Service 层的操作 Postman测试 增 查 改 删","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合MyBatis","slug":"SpringBoot整合MyBatis","date":"2020-09-09T07:52:44.000Z","updated":"2020-09-30T07:08:29.310Z","comments":true,"path":"2020/09/09/SpringBoot整合MyBatis/","link":"","permalink":"http://wangba.me/2020/09/09/SpringBoot%E6%95%B4%E5%90%88MyBatis/","excerpt":"","text":"一、OverView​ 在上篇文章中已经简单的写过 SpringBoot 整合 JDBCTemplate 了，但是现在的公司应该很少有用 JDBCTemplate，国内一般都是 MyBatis 或者是 Spring Data JPA，在本篇文章中就来整合一下 MyBatis。 二、环境搭建新建 SpringBoot 项目，选上 Web、MySQL，在 pom.xml 中配置一下数据库连接池： pom.xml: 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; application.properties: 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password= 三、CRUDUserMapper: 1234567891011121314151617181920212223242526272829@Component@Transactionalpublic interface UserMapper &#123; // 增 @Insert(&quot;insert into mybatis(name, password) values(#&#123;name&#125;, #&#123;password&#125;)&quot;) @SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = Long.class) Integer insert(User user); // 查 @Select(&quot;select * from mybatis&quot;) List&lt;User&gt; queryAllUser(); @Results(&#123; @Result(property = &quot;id&quot;, column = &quot;i&quot;), @Result(property = &quot;name&quot;, column = &quot;n&quot;), @Result(property = &quot;password&quot;, column = &quot;p&quot;) &#125;) @Select(&quot;select id as i, name as n, password as p from mybatis where id = #&#123;id&#125;&quot;) User queryById(Long id); // 改 @Update(&quot;update mybatis set name = #&#123;name&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;&quot;) Integer update(User user); // 删 @Delete(&quot;delete from mybatis where id = #&#123;id&#125;&quot;) Integer delete(Long id);&#125; 注： 如果不使用注解的方式，就要使用 xml 的方式，注意其中的资源解析问题： 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 增加 statement是要运行的SQL语句，它的返回值通过resultType来指定 before表示查询语句statement运行的时机 keyProperty表示查询结果赋值给代码中的哪个对象，keyColumn表示将查询结果赋值给数据库表中哪一列 keyProperty和keyColumn都不是必需的，有没有都可以 before=true，插入之前进行查询，可以将查询结果赋给keyProperty和keyColumn，赋给keyColumn相当于更改数据库 befaore=false，先插入，再查询，这时只能将结果赋给keyProperty 赋值给keyProperty用来“读”数据库，赋值给keyColumn用来写数据库 selectKey的两大作用：1、生成主键；2、获取刚刚插入数据的主键。 使用selectKey，并且使用MySQL的last_insert_id()函数时，before必为false，也就是说必须先插入然后执行last_insert_id()才能获得刚刚插入数据的ID。 参考链接：@SelectKey注解 查 @Results注解类似于XML中的ResultMap映射文件 UserController: 为了方便就不再写 Service 层了 123456789101112131415161718192021222324252627282930313233343536@RestControllerpublic class UserController &#123; private UserMapper userMapper; @Autowired public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @PutMapping(&quot;/insert&quot;) public Integer insert(@RequestBody User user) &#123; return userMapper.insert(user); &#125; @GetMapping(&quot;/query&quot;) public List&lt;User&gt; queryAllUser() &#123; return userMapper.queryAllUser(); &#125; @GetMapping(&quot;/query1&quot;) public User queryById(Long id) &#123; return userMapper.queryById(id); &#125; @PostMapping(&quot;/update&quot;) public Integer update(@RequestBody User user) &#123; return userMapper.update(user); &#125; @DeleteMapping(&quot;/delete&quot;) public Integer delete(Long id) &#123; return userMapper.delete(id); &#125;&#125; Postman 测试： 增加： 查询所有： 通过 id 查询： 更新： 查看一下数据库： 删除： 查看一下数据库： 使用注解进行动态查询具体可以参考：注解版动态查询 使用 xml 方式进行动态查询可以参考：xml 版动态查询","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"}]},{"title":"SpringBoot整合JDBCTemplate","slug":"SpringBoot整合JDBCTemplate","date":"2020-09-08T11:33:14.000Z","updated":"2020-09-30T07:08:27.205Z","comments":true,"path":"2020/09/08/SpringBoot整合JDBCTemplate/","link":"","permalink":"http://wangba.me/2020/09/08/SpringBoot%E6%95%B4%E5%90%88JDBCTemplate/","excerpt":"","text":"一、环境搭建1. 引入依赖1234567891011121314151617181920212223242526272829303132333435363738// WEB&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;// JDBC &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;// 使用 Swagger 进行接口测试&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;// mysql&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;// druid&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt; 2.数据库脚本1234567891011121314151617181920DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27;, `name` varchar(50) NOT NULL COMMENT &#x27;用户名&#x27;, `nick_name` varchar(150) DEFAULT NULL COMMENT &#x27;昵称&#x27;, `avatar` varchar(150) DEFAULT NULL COMMENT &#x27;头像&#x27;, `password` varchar(100) DEFAULT NULL COMMENT &#x27;密码&#x27;, `salt` varchar(40) DEFAULT NULL COMMENT &#x27;加密盐&#x27;, `email` varchar(100) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `mobile` varchar(100) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `status` tinyint(4) DEFAULT NULL COMMENT &#x27;状态 0：禁用 1：正常&#x27;, `dept_id` bigint(20) DEFAULT NULL COMMENT &#x27;机构ID&#x27;, `create_by` varchar(50) DEFAULT NULL COMMENT &#x27;创建人&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `last_update_by` varchar(50) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `last_update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除 -1：已删除 0：正常&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户管理&#x27;; application.properties: 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=****** 二、CRUD1.编写对应的实体类123456789101112131415161718192021222324252627282930313233public class SysUser &#123; private Long id; private String name; private String nickName; private String avatar; private String password; private String salt; private String email; private String mobile; private Byte status; private Long deptId; private String createBy; private Date createTime; private String lastUpdateBy; private Date lastUpdateTime; private Byte delFlag; // set 和 get 省略&#125; 2.编写对应的 CRUD Repository1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Repositorypublic class SysUserRepository &#123; @Autowired private JdbcTemplate jdbcTemplate; public Integer insert(SysUser user) &#123; String sql = &quot;insert into sys_user(id, name, password) values(?,?,?)&quot;; return jdbcTemplate.update(sql, user.getId(), user.getName(), user.getPassword()); &#125; public Integer insert1(SysUser sysUser) &#123; String sql = &quot;insert into sys_user(id, name, password) values(:id, :name, :password)&quot;; NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); return namedParameterJdbcTemplate.update(sql, new BeanPropertySqlParameterSource(sysUser)); &#125; // 推荐使用这种方式，可以不用传所有的参数 public Integer insert2(SysUser sysUser) &#123; String sql = &quot;insert into sys_user(id, name, password) values(:id, :name, :password)&quot;; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;id&quot;, sysUser.getId()); map.put(&quot;name&quot;, sysUser.getName()); map.put(&quot;password&quot;, sysUser.getPassword()); NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); return namedParameterJdbcTemplate.update(sql, map); &#125; public Integer update(SysUser sysUser) &#123; String sql = &quot;update sys_user set name = ?, password = ? where id = ?&quot;; Object[] args = &#123;sysUser.getName(), sysUser.getPassword(), sysUser.getId()&#125;; int[] argTypes = &#123;Types.VARCHAR, Types.VARCHAR, Types.BIGINT&#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125; public List&lt;Map&lt;String, Object&gt;&gt; queryAllListMap() &#123; String sql = &quot;select * from sys_user&quot;; return this.jdbcTemplate.queryForList(sql); &#125; // 这里要写一个 SysUserMapper 实现 RowMapper public SysUser queryById(Long id) &#123; String sql = &quot;select * from sys_user where id = ?&quot;; Object[] args = &#123;id&#125;; int[] argTypes = &#123;Types.BIGINT&#125;; List&lt;SysUser&gt; list = this.jdbcTemplate.query(sql, args, argTypes, new SysUserMapper()); if (StringUtils.isEmpty(list)) &#123; return list.get(0); &#125; else &#123; return null; &#125; &#125; public Integer deleteById(Long id) &#123; String sql = &quot;delete from sys_user where id = ?&quot;; Object[] args = &#123; id &#125;; int[] argTypes = &#123; Types.BIGINT &#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125;&#125; 3.对应的 Controller 层123456789101112131415161718192021222324252627282930313233343536373839404142434445@RestControllerpublic class SysUserController &#123; @Autowired private SysUserRepository sysUserRepository; @PutMapping(&quot;/insert&quot;) public Integer insert(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert(sysUser); return i; &#125; @PutMapping(&quot;/insert1&quot;) public Integer insert1(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert1(sysUser); return i; &#125; @PutMapping(&quot;/insert2&quot;) public Integer insert2(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert2(sysUser); return i; &#125; @PostMapping(&quot;/update&quot;) public Integer update(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.update(sysUser); return i; &#125; @GetMapping(&quot;/list&quot;) public List&lt;Map&lt;String, Object&gt;&gt; queryAllListMap() &#123; return sysUserRepository.queryAllListMap(); &#125; @GetMapping(&quot;/id1&quot;) public SysUser queryById(Long id) &#123; return sysUserRepository.queryById(id); &#125; @DeleteMapping(&quot;/id3&quot;) public Integer deleteById(Long id) &#123; return sysUserRepository.deleteById(id); &#125;&#125; 注：为了图方便，就不再此写 Service 层了 4.使用 Swagger 进行测试增加 第一种方式： 第二种方式： 第三种方式： 看一下数据库是否有三条数据： 修改 查找 查找所有： 删除","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"}]},{"title":"0076.Minimum Window Substring","slug":"0076-Minimum-Window-Substring","date":"2020-09-04T13:56:11.000Z","updated":"2020-09-30T07:09:40.885Z","comments":true,"path":"2020/09/04/0076-Minimum-Window-Substring/","link":"","permalink":"http://wangba.me/2020/09/04/0076-Minimum-Window-Substring/","excerpt":"","text":"76. 最小覆盖子串 Hard给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 12输入：S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;输出：&quot;BANC&quot; 提示： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 解题思路​ 这题在 0003 题中就已经提过了的暗号，就是洒洒水的使用一下 Sliding Window 就可以了，思路还是比较简单的：先不断的扩张窗口右边，直到将所有的要包含的短字符串；然后开始就移动窗口的左边，直到左边压缩到不能再容纳这个短字符串了，再进行不断比较，就可以得到最终结果了。​ 这种时候就需要出现 但是 这个词语，果然在实现的时候就需要注意很多问题了，对于这种抽象问题，先来个🌰：给的例子实在是太普通了，应该用那种带点特殊性的例子 S = “ABANCDB” T = “ABC” 对着代码捋一遍应该就懂了：第一遍过后可以看见：”ABANC” 是一个滑动窗口，map 的值也变为了： A B C 初始值 1 1 1 遍历到 A 0 1 1 遍历到 B 0 0 1 遍历到 A -1 0 1 遍历到 N -1 0 1 遍历到 C -1 0 0 此时的 count == t 的长度了，这样扩张窗口就完成了 ======&gt; min = 5 接下来就是收缩窗口，其根本原因就是这样左边出现重复元素，可以去掉形成最小的窗口： 如果在 map 中的值是等于 0 的，说明它是刚刚好的，如果把这个排除的话，这个窗口就不再成立了，要继续扩张 窗口了；如果 map 中的值 小于 0 的，说明它是多余的，但是要看它的位置了，可以看下🌰： “ABANC” 这个 A 就可以去掉；”BAANC” 这个 A 就不可以去掉，此时就要扩张窗口了 反复横跳 ，完成✅ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // 使用 hashmap 将 t 中的字符存入 for(int i = 0; i &lt; t.length(); i++) &#123; char c = t.charAt(i); if (map.containsKey(c)) &#123; int tmp = map.get(c); map.put(c, tmp + 1); &#125; else &#123; map.put(c, 1); &#125; &#125; // 用来判断这个窗口是否包含了 t int count = 0; // 一个窗口的左右 int left = 0, right = 0; int min = Integer.MAX_VALUE; // 长度最小的窗口的左右 int minLeft = 0, minRight = 0; for (; right &lt; s.length(); right++) &#123; char temp = s.charAt(right); if (map.containsKey(temp)) &#123; count = map.get(temp) &gt; 0 ? count + 1 : count; map.put(temp, map.get(temp) - 1); &#125; while (count == t.length()) &#123; if ((right - left) &lt; min) &#123; min = right - left; minLeft = left; minRight = right; &#125; char c = s.charAt(left); // 左边的重复字符可以不用 if (map.containsKey(c)) &#123; if (map.get(c) &gt;= 0) count--; map.put(c, map.get(c) + 1); &#125; left++; &#125; &#125; return min == Integer.MAX_VALUE ? &quot;&quot; : s.substring(minLeft, minRight + 1); &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"}]},{"title":"SpringBoot整合AOP","slug":"SpringBoot整合AOP","date":"2020-09-03T13:52:37.000Z","updated":"2020-09-30T07:08:24.891Z","comments":true,"path":"2020/09/03/SpringBoot整合AOP/","link":"","permalink":"http://wangba.me/2020/09/03/SpringBoot%E6%95%B4%E5%90%88AOP/","excerpt":"","text":"一、背景​ 在公司写业务的时候，都会有保存日志的操作，方便出错的时候进行排查；一般不仅仅在数据库中保存日志， 也会在后端控制台打印一些需要的信息。在这里，一般使用 AOP 织入的方式将日志保存在数据库中，使用一些日 志包将某些 Controller 层的信息打印在控制台。 二、准备Entiy:1234567891011121314151617181920@Entity@Table(name = &quot;log&quot;)@EntityListeners(AuditingEntityListener.class)public class Log implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY ) @Column(name = &quot;id&quot;) private Long id; @Column(name = &quot;title&quot;, columnDefinition = &quot;VARCHAR(100) COMMENT &#x27;标题&#x27;&quot;) private String title; @Column(name = &quot;author&quot;, columnDefinition = &quot;VARCHAR(255) COMMENT &#x27;作者&#x27;&quot;) private String author; @Column(name = &quot;content&quot;, columnDefinition = &quot;TEXT COMMENT &#x27;内容&#x27;&quot;) private String content; // get 和 set 省略 注: 这里是使用 Spring Data JPA 自动生成的数据库对应实体，导入相关依赖后，可以先运行一遍，看数据库 是否生成对应实体；然后自行在数据库中插入几条数据。 Repository:123public interface LogRepository extends JpaRepository&lt;Log, Long&gt; &#123;&#125; 注: 这里只要继承 JpaRepository ，这个 repository 也继承了别的 repository（里面有一些常见的方法可以 调用） Service:1234567891011@Servicepublic class LogService &#123; @Autowired LogRepository logRepository; public List&lt;Log&gt; getAllLog() &#123; List&lt;Log&gt; logs = logRepository.findAll(); return logs; &#125;&#125; 注: 这里就不写接口，再去实现了 Controller:123456789101112@RestControllerpublic class LogController &#123; @Autowired LogService logService; @GetMapping(&quot;/list&quot;) public List&lt;Log&gt; getAll() &#123; List&lt;Log&gt; logs = logService.getAllLog(); return logs; &#125;&#125; 再使用 Postman 等工具进行一次测试就行 三、使用注解的方式进行 AOP首先定义一个方法级别的 @Log 注解，用于标注需要监控的方法： 1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123; String value() default &quot;&quot;; &#125; 定义一个LogAspect类，使用 @Aspect 标注让其成为一个切面，切点为使用 @Log 注解标注的方法： 1234567891011121314151617181920@Aspect@Componentpublic class LogAspec &#123; private final static Logger logger = LoggerFactory.getLogger(LogAspec.class); @Pointcut(&quot;@annotation(org.wangba.springboot013aop.antoation.Log)&quot;) public void pointcut() &#123; &#125; @Before(&quot;pointcut()&quot;) public void doBefore(JoinPoint joinPoint) throws Throwable &#123; logger.info(&quot;Start Time: &#123;&#125;&quot;, System.currentTimeMillis()); &#125; @After(&quot;pointcut()&quot;) public void doAfter() throws Throwable &#123; logger.info(&quot;End Time: &#123;&#125;&quot;, System.currentTimeMillis()); &#125;&#125; 再在 Controller 层的方法上加上 @Log 注解： 12345678910111213@RestControllerpublic class LogController &#123; @Autowired LogService logService; @Log(&quot;获得所有文章&quot;) @GetMapping(&quot;/list&quot;) public List&lt;Article&gt; getAll() &#123; List&lt;Article&gt; articles = logService.getAllLog(); return articles; &#125;&#125; 此时再在 Postman 中测试一次，你就可以看到控制台会打印如下结果： 在公司业务中，我们一般都是在 @Before 进行一些请求信息等， @After 在控制台打印一些信息，并将结 果直接存到数据库中的日志表中。","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中类型转换","slug":"SpringBoot中类型转换","date":"2020-09-02T12:55:09.000Z","updated":"2020-09-30T07:08:22.269Z","comments":true,"path":"2020/09/02/SpringBoot中类型转换/","link":"","permalink":"http://wangba.me/2020/09/02/SpringBoot%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"一、问题如果前端传来一个日期参数，是用 String 类型的，我们如何在后端进行传参呢？ 也即如下这种情况： 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public void hello(Date date) &#123; System.out.println(date); &#125;&#125; 浏览器输入：http://localhost:8080/hello?date=2020-01-01 可以在后台看到 WARN ： Failed to convert value of type ‘java.lang.String’ to required type ‘java.util.Date’ 二、解决1234567891011121314151617@Componentpublic class StringTransDate implements Converter&lt;String, Date&gt; &#123; private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); @Override public Date convert(String s) &#123; if (s != null &amp;&amp; !&quot;&quot;.equals(s)) &#123; try &#123; return simpleDateFormat.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125;&#125; 注：要将该类使用 @Component 注入","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"0003.Longest Substring Without Repeating Characters","slug":"0003-Longest-Substring-Without-Repeating-Characters","date":"2020-09-01T13:26:29.000Z","updated":"2020-09-30T07:09:37.081Z","comments":true,"path":"2020/09/01/0003-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"http://wangba.me/2020/09/01/0003-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"0003. 无重复字符的最长子串 Medium给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 12345输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路 🐷：第一个想法就是这个是不是和 KMP 算法有那么一点点像的 力扣：让你见识一下，值得我们官网有一个标签的思想 ———&gt; Sliding Window 🐷：说人话 力扣：就是 滑动窗口 大法，你后面会看到很多次这种思想，想继续看这样的题，点这里，还有一些暗号：76、 438、567 滑动窗口思想： 滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。 🐷：应该就是双指针的变形版了…….. 代码12345678910111213class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0, j = 0; i &lt; s.length(); i++) &#123; if (map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i)) + 1); map.put(s.charAt(i), i); max = Math.max(max, i - j + 1); &#125; return max; &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"},{"name":"Two pointer","slug":"Two-pointer","permalink":"http://wangba.me/tags/Two-pointer/"}]},{"title":"SpringBoot中的路径映射","slug":"SpringBoot中的路径映射","date":"2020-09-01T13:25:29.000Z","updated":"2020-09-30T07:08:15.292Z","comments":true,"path":"2020/09/01/SpringBoot中的路径映射/","link":"","permalink":"http://wangba.me/2020/09/01/SpringBoot%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84/","excerpt":"","text":"一、在 SpringBoot中使用 SSM 框架中的映射写下如下的 Controller： 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125;&#125; 并在 resources/templates 中新建 hello.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, Spring Boot&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 注：在 SpringBoot 中，默认的静态资源是放在以下几个位置： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ / 其中第 5 个表示 webapp 目录中的静态资源也不被拦截 所以在这里这不是一个静态资源，我们以前的做法就是直接返回这个页面，没写上面的 Controller 直接使用 http://localhost:8080/hello 是访问不到该页面的 二、在 SpringBoot 中进行路径映射只需要进行如下配置就可以进行路径映射 12345678@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;wangba&quot;).setViewName(&quot;hello&quot;); &#125;&#125; 再次访问：http://localhost:8080/wangba 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"0001.Two Sum","slug":"0001-Two-Sum","date":"2020-08-31T13:26:10.000Z","updated":"2020-09-30T07:08:03.901Z","comments":true,"path":"2020/08/31/0001-Two-Sum/","link":"","permalink":"http://wangba.me/2020/08/31/0001-Two-Sum/","excerpt":"","text":"0001. 两数之和 Easy给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 解题思路 傻瓜式想法：遍历两次，求和（去除重复的元素，位置不同的相等元素可以进行计算） 力扣内心OS：你这样的时间复杂度能过算我输！！！ 😯：就这，略施小计：空间换时间之术 首先，遍历一遍数组将数组的值放入 Map 中，然后再遍历一次，将 target - 取到的值，但是要注意不能仅仅判断是 否存在这个值，因为可能会出现下面这种情况：target = 4，该数组中就只有一个 2，这样就会出错。所以还要判断 取到的值还不能是第一次的元素。 代码：123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; hashMap.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int temp = target - nums[i]; if (hashMap.containsKey(temp) &amp;&amp; hashMap.get(temp) != i) &#123; res[0] = hashMap.get(temp); res[1] = i; break; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"}]},{"title":"SpringBoot中的Servlet、Filter、Listener","slug":"SpringBoot中的Servlet、Filter、Listener","date":"2020-08-31T12:08:27.000Z","updated":"2020-09-30T07:07:21.821Z","comments":true,"path":"2020/08/31/SpringBoot中的Servlet、Filter、Listener/","link":"","permalink":"http://wangba.me/2020/08/31/SpringBoot%E4%B8%AD%E7%9A%84Servlet%E3%80%81Filter%E3%80%81Listener/","excerpt":"","text":"一、Servlet12345678@WebServlet(urlPatterns = &quot;/MyServlet&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;MyServlet&quot;); &#125;&#125; @WebServlet(urlPatterns = “/MyServlet”)：指定Servlet指定的 URL 二、Filter12345678910111213141516171819@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;MyFilter&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; @WebFilter(“/*”)：指定路径进行过滤 三、Listener123456789101112@WebListenerpublic class MyListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(&quot;requestInitialized.............&quot;); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(&quot;requestDestroyed................&quot;); &#125;&#125; @WebListener：标注为监听器 可以自行测试修改路由路径等进行测试 四、区别启动结果：http://localhost:8080/MyServlet 配合官方图解释一下： 首先是 Listener ==&gt; Filter ==&gt; Servlet 下面还有一次： 12MyFilterrequestDestroyed................ 再浏览器打开控制台，强制刷新一下：macOS(快捷键：command + shift + R)，可以看到： 最下面的那个是我的浏览器扩展加载的脚本","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中定义系统启动任务","slug":"SpringBoot中定义系统启动任务","date":"2020-08-22T11:26:24.000Z","updated":"2020-09-30T07:07:19.950Z","comments":true,"path":"2020/08/22/SpringBoot中定义系统启动任务/","link":"","permalink":"http://wangba.me/2020/08/22/SpringBoot%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"一、CommandLineRunner通过实现 CommandLineRunner 来定义启动任务： 12345678@Component@Order(1)public class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;Order(1):&quot; + Arrays.toString(args)); &#125;&#125; 12345678@Component@Order(2)public class MyCommandLineRunner01 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;Order(2):&quot; + Arrays.toString(args)); &#125;&#125; 其中： @Order 注解为优先级，数值越小，优先级越高； args 为启动类中的 String[] args； args 参数可以在配置里面的 Program argumens 进行配置，也可以打成 jar 包的时候，使用命令进行设置 最终结果如下： 可以看到 Order(1) 的优先级高于 Order(2) 二、ApplicationRunner通过实现 ApplicationRunner 来定义启动任务： 1234567891011121314151617181920@Component@Order(3)public class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;Order3:&quot;); String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArg:&quot; + Arrays.toString(sourceArgs)); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs:&quot; + nonOptionArgs); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) &#123; System.out.println(optionName + args.getOptionValues(optionName)); &#125; &#125;&#125; 123456789101112131415161718192021@Component@Order(4)public class MyApplicationRunner01 implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;Order4&quot;); String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArg:&quot; + Arrays.toString(sourceArgs)); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs:&quot; + nonOptionArgs); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) &#123; System.out.println(optionName + args.getOptionValues(optionName)); &#125; System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); &#125;&#125; args.getNonOptionArgs()：可以用来获取命令行中的无key参数； args.getOptionNames()：可以用来获取所有key/value形式的参数的key； args.getOptionValues(key))：可以根据key获取key/value 形式的参数的value； args.getSourceArgs();：则表示获取命令行中的所有参数。 参数配置： 最终结果： 注：CommandLineRunner 和 ApplicationRunner 是可以一起用的，优先级还是通过 @Order 进行排序 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot整合过滤器和拦截器","slug":"SpringBoot整合过滤器和拦截器","date":"2020-08-20T12:32:06.000Z","updated":"2020-09-30T07:07:15.616Z","comments":true,"path":"2020/08/20/SpringBoot整合过滤器和拦截器/","link":"","permalink":"http://wangba.me/2020/08/20/SpringBoot%E6%95%B4%E5%90%88%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"一、过滤器新建如下的 Controller： 123456789@RestControllerpublic class UserController &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) public void get(@PathVariable String id) &#123; System.out.println(id); &#125;&#125; 过滤器的实现：定义一个类实现 Filter ，并重写其中的方法 123456789101112131415161718192021222324@Component@WebFilter(urlPatterns = &quot;/*&quot;)public class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;Initialization&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;++++++++ Start ++++++++&quot;); Long start = new Date().getTime(); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;Filter costs: &quot;); System.out.println(new Date().getTime() - start); System.out.println(&quot;++++++++ End ++++++++&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;Filter is over&quot;); &#125;&#125; init 方法：是对项目启动时，进行的初始化 doFilter 方法：当执行一个请求的时候，进行过滤 destroy 方法：当这个项目关闭时，该过滤器也被销毁了 浏览器运行：http://localhost:8080/user/666 结果： 在这个过程中出现了一点问题： 当我们进行下面这种过滤一部分的情况下： TimeFilter 12345678910111213141516171819202122232425@Component@WebFilter(urlPatterns = &#123;&quot;/user/*&quot;&#125;)public class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(filterConfig.getServletContext().getContextPath()); System.out.println(&quot;Initialization........&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;++++++++ Start ++++++++&quot;); Long start = new Date().getTime(); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;Filter costs: &quot;); System.out.println(new Date().getTime() - start); System.out.println(&quot;++++++++ End ++++++++&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;Filter is over&quot;); &#125;&#125; UserController 123456789@RestControllerpublic class UserController &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) public void get(@PathVariable String id) &#123; System.out.println(&quot;userID：&quot; +id); &#125;&#125; HelloController 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125;&#125; 此时我们过滤的是 /user 后面所有的请求，但是结果是 UserController 和 HelloController 都进入了过滤器中： 最终解决方案：去掉在 TimeFilter 中的 @Component 注解，在启动类上加上 @ServletComponentScan 注解即可： 在上面我们使用了注解的方式进行过滤： @WebFilter(urlPatterns = “/*”) 第二种方式： 去掉 @Component 和 *@WebFilter(urlPatterns = {“/user/“})** 注解，并配置如下的配置类： 123456789101112131415@Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); TimeFilter timeFilter = new TimeFilter(); filterRegistrationBean.setFilter(timeFilter); List&lt;String&gt; urlList = new ArrayList&lt;&gt;(); urlList.add(&quot;/user/*&quot;); filterRegistrationBean.setUrlPatterns(urlList); return filterRegistrationBean; &#125;&#125; 二、拦截器编写一个拦截器类实现 HandlerInterceptor ，如下： 12345678910111213141516171819202122232425public class TimeInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;处理拦截之前&quot;); request.setAttribute(&quot;startTime&quot;, new Date().getTime()); System.out.println(((HandlerMethod) handler).getBean().getClass().getName()); System.out.println(((HandlerMethod) handler).getMethod().getName()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;开始处理拦截&quot;); Long start = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;【拦截器】耗时 &quot; + (new Date().getTime() - start)); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;处理拦截之后&quot;); Long start = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;【拦截器】耗时 &quot; + (new Date().getTime() - start)); System.out.println(&quot;异常信息 &quot; + ex); &#125;&#125; preHandle 方法在处理拦截之前执行 postHandle 方法只有当被拦截的方法没有抛出异常成功时才会处理 afterCompletion 方法无论被拦截的方法抛出异常与否都会执行 将我们写好的拦截器注册到容器中： 123456789101112@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor).addPathPatterns(&quot;/user/*&quot;); &#125;&#125; 同样分别运行：http://localhost:8080/user/888 和 http://localhost:8080/hello 可以看见结果如下： 只是对 user/888 进行拦截了，对 hello 没有进行拦截 三、过滤器与拦截器的对比我们再将前面的过滤器加入其中，可以得到如下结果： 有一张已经整理好执行顺序图：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中跨域问题","slug":"SpringBoot中跨域问题","date":"2020-08-20T10:16:59.000Z","updated":"2020-09-30T07:07:17.590Z","comments":true,"path":"2020/08/20/SpringBoot中跨域问题/","link":"","permalink":"http://wangba.me/2020/08/20/SpringBoot%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、同源策略​ 同源策略是由 Netscape 提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是 JSONP，JSONP 虽然能解决跨域但是有一个很大的局限性，那就是只支持 GET 请求，不支持其他类型的请求，而 CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个 W3C 标准，它是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是 JSONP 模式的现代版。在 Spring 框架中，对于 CORS 也提供了相应的解决方案， SpringBoot 中如何实现 CORS。 二、如何出现启动两个 SpringBoot 项目，分别以 8080 和 8081 端口启动，在其中一个写上如下的 Controller： 1234567891011121314@RestControllerpublic class HelloController &#123; @PostMapping(&quot;/hello&quot;) public String hello1() &#123; return &quot;get hello&quot;; &#125; @GetMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;post hello&quot;; &#125;&#125; 在另一个中写入一个静态页面： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; value=&quot;get_button&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick2()&quot; value=&quot;post_button&quot;&gt;&lt;script&gt; function btnClick() &#123; $.get(&#x27;http://localhost:8080/hello&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125; function btnClick2() &#123; $.post(&#x27;http://localhost:8080/hello&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：记得引入 Jquery 在 http://localhost:8081/hello.html 点击任何请求： 可以看到此时已经发生跨域问题 三、解决方案从后端解决，修改 Controller 为： 12345678910111213141516@RestControllerpublic class HelloController &#123; @CrossOrigin(origins = &quot;http://localhost:8081&quot;) @PostMapping(&quot;/hello&quot;) public String hello1() &#123; return &quot;post hello&quot;; &#125; @CrossOrigin(value = &quot;http://localhost:8081&quot;) @GetMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;get hello&quot;; &#125;&#125; 其中 origins 与 value 效果一样，看源码可以知道它们互相成为对方的别名 此时已经不会出现跨域问题 四、加强版解决此时，在每一个类或者方法上都使用这个注解，法外狂徒张三都觉得这个太麻烦了 只需要配置一个实现 WebMvcConfigurer 配置类，如下： 12345678public class CORSConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) .allowedHeaders(&quot;*&quot;); &#125;&#125; 注：/** 表示本应用的所有方法都会去处理跨域请求；allowedMethods 表示允许通过的请求数；allowedHeaders 则表示允许的请求头。 五、安全问题出现了一个王八老本行的问题：通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。 一句话：利用我们还在登录的状态，即 Cookie 有效，打开一个正常网站，而这个网站上可能有一个非正常操作 ( 图片，链接等) ，那你就可能已经被攻击。 在信息安全中，我们防御 CSRF 的方法主要是增加 Token，这也是现在大多数防御 CSRF 的方式。","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中自定义异常","slug":"SpringBoot中自定义异常","date":"2020-08-19T09:11:17.000Z","updated":"2020-09-30T07:07:13.559Z","comments":true,"path":"2020/08/19/SpringBoot中自定义异常/","link":"","permalink":"http://wangba.me/2020/08/19/SpringBoot%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/","excerpt":"","text":"一、正常出现异常Controller： 12345678910@RestControllerpublic class ErrorController &#123; @GetMapping(&quot;/diyError&quot;) public String error() &#123; int i = 2 / 0; return &quot;diyError&quot;; &#125; &#125; 结果： 可以看见此错误页是 SpringBoot 提供的，由于我们没有提供 /error 页面，顺便展示我们出现的错误 二、静态页面异常在 static 目录下新建一个 error 目录，并在其中新建 404.html 和 500.html： 404.html: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 500.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;500&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 再次访问 http://localhost:8080/diyError 可以看见已经进入自定义的静态页面了： 再访问一个不存在的页面： 注：也可以只定义 4xx.html 与 5xx.html 的静态页面，只要发生 400-499 的状态码或者 500-599 的状态码就对应 4xx.html 与 5xx.html 的结果 三、动态页面异常引入 thymeleaf 的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在 templates 目录下新建一个 error 目录，并在其中新建 404.html、 500.html、 4xx.html、5xx.html ： 再次访问 http://localhost:8080/diyError 可以看见已经进入自定义的动态页面了： 优先级： 如果有 404 的页面，会先找 404.html；如果没有就会找 4xx.html 如果动态页面和静态页面同时存在，会优先使用动态页面 完整顺序大概如下： 发生了500错误 –&gt; 查找动态 500.html 页面 –&gt; 查找静态 500.html –&gt; 查找动态 5xx.html –&gt; 查找静态 5xx.html 四、SpringBoot 怎么自动配置关键类：ErrorMvcAutoConfiguration 12345678910111213141516171819202122@Configuration(proxyBeanMethods = false)static class DefaultErrorViewResolverConfiguration &#123; private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) &#123; this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; &#125; @Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean(ErrorViewResolver.class) // 默认的错误视图解析器 DefaultErrorViewResolver DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); &#125;&#125; 在默认的错误视图解析器 DefaultErrorViewResolver 中： 12345678@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125; 如果 modelAndView 为空，即没找到对应的具体 404.html，就会用 SERIES_VIEWS.containsKey(status.series()) 找 4xx.html 123456789private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; String errorViewName = &quot;error/&quot; + viewName; TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; return resolveResource(errorViewName, model);&#125; 判断 error 文件夹下面是否有对应的状态码的文档 再判断是否有动态页面，即 TemplateAvailabilityProvider 如果是动态页面，就返回动态页面；否则返回静态页面 1234567891011121314private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; for (String location : this.resourceProperties.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + &quot;.html&quot;); if (resource.exists()) &#123; return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; return null;&#125; 五、自定义异常数据在 ErrorMvcAutoConfiguration 中，处理异常数据的方法： 12345@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes();&#125; 在 DefaultErrorAttributes() 中通过设置参数得到相应的结果 例如：将 error 中的 5xx.html 改为： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;5xx&lt;/h1&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;trace&lt;/td&gt; &lt;td th:text=&quot;$&#123;trace&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 此时仔运行结果： 再看一下使 DefaultErrorAttributes 生效的条件： @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) 所以只要我们自定义 ErrorAttributes.class 就可以实现自己定义的异常数据处理 自定义 ErrorAttributes 有两种方式 ： 直接实现 ErrorAttributes 接口 继承 DefaultErrorAttributes（推荐），因为 DefaultErrorAttributes 中对异常数据的处理已经完成，开发者可以直接使用。 新建一个配置类继承 DefaultErrorAttributes 12345678910@Componentpublic class MyErrorConfig extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, options); errorAttributes.put(&quot;myerror&quot;, &quot;自定义异常&quot;); return errorAttributes; &#125;&#125; 在 5xx.html 中加入： 1234&lt;tr&gt; &lt;td&gt;myerror&lt;/td&gt; &lt;td th:text=&quot;$&#123;myerror&#125;&quot;&gt;&lt;/td&gt;&lt;/tr&gt; 运行结果：可以看到此时的自定义的 error 已经加入","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot整合JSON","slug":"SpringBoot整合JSON","date":"2020-08-18T13:01:28.000Z","updated":"2020-09-30T07:07:11.653Z","comments":true,"path":"2020/08/18/SpringBoot整合JSON/","link":"","permalink":"http://wangba.me/2020/08/18/SpringBoot%E6%95%B4%E5%90%88JSON/","excerpt":"","text":"一、Jackson1. 环境搭建只要加入普通的 Web 依赖就行，为了方便依然引入 Lombok 和 热部署 打开 Maven 依赖可以看见 SpringBoot 自带的就是 jackson 2. SpringBoot中使用2.1 建立实体类： 12345678@Datapublic class User &#123; private Integer id; private String name; private String address; private Date date;&#125; 2.2 Controller层： 1234567891011121314151617@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user&quot;) public List&lt;User&gt; getUser() &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setId(i); user.setName(&quot;wang&quot; + i); user.setAddress(&quot;shanghai&quot; + i); user.setDate(new Date()); users.add(user); &#125; return users; &#125;&#125; 2.3 结果： 3. 深入了解 Springboot 中的 JSON 转换思考： 前端传入的 json 数据如何被解析成 Java 对象作为 API入参 API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端 关键类：HttpMessageConverter 官方原话： 1Strategy interface that specifies a converter that can convert from and to HTTP requests and responses. 从 Structure 中可以看见一共有五个方法： canRead：接收到请求时判断是否能读 canWrite：返回结果时判断是否能写 getSupportedMediaTypes：获取支持的 MediaType read：能读则读 write：能写则写 注：在前面我们没有写任何配置也能实现转换，是由于其中有缺省配置 可以在 WebMvcConfigurationSupport 中查看 4.自定义 JSON 配置方式一：在需要转换的属性上加上注解 12345678910@Datapublic class User &#123; private Integer id; private String name; private String address; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private Date date;&#125; 结果： 方式二： 配置类： 1234567891011121314@Configurationpublic class JsonConfig &#123; @Bean MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123; MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd-HH:mm:ss&quot;)); converter.setObjectMapper(objectMapper); return converter; &#125;&#125; 结果： 使用下面的配置类也可以： 123456789101112131415161718192021@Configurationpublic class JsonConfig &#123;// @Bean// MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123;//// MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();// ObjectMapper objectMapper = new ObjectMapper();// objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd-HH:mm:ss&quot;));// converter.setObjectMapper(objectMapper);// return converter;// &#125; @Bean ObjectMapper objectMapper() &#123; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)); return objectMapper; &#125;&#125; 结果： 5.Gson 和 Fastjson如果想要和 Jackson 一样自定义配置： 只需要配置：GsonHttpMessageConverter 和 FastJsonHttpMessageConverter","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"JSON","slug":"JSON","permalink":"http://wangba.me/tags/JSON/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"ControllerAdvice注解的使用","slug":"ControllerAdvice注解的使用","date":"2020-08-18T13:00:09.000Z","updated":"2020-09-30T07:07:09.383Z","comments":true,"path":"2020/08/18/ControllerAdvice注解的使用/","link":"","permalink":"http://wangba.me/2020/08/18/ControllerAdvice%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、用法 处理全局异常 预设全局数据 请求参数预处理 二、处理全局异常我们只需要在 application.properties中配置：spring.servlet.multipart.max-file-size=1KB 就可以看见在上传图片时就会报 500 异常： 此时我们可以自己自定义处理 这种异常： 12345678910111213@ControllerAdvicepublic class MyException &#123; @ExceptionHandler(MaxUploadSizeExceededException.class) public void myException(MaxUploadSizeExceededException e, HttpServletResponse response) throws IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(&quot;上传大小限制为1KB&quot;); writer.flush(); writer.close(); &#125;&#125; 三、预设全局数据设置全局变量： 1234567891011@ControllerAdvicepublic class GlobalData &#123; @ModelAttribute(value = &quot;data&quot;) public Map&lt;String, Object&gt; map() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;wangyi&quot;, &quot;王一&quot;); map.put(&quot;wangba&quot;, &quot;王八&quot;); return map; &#125;&#125; 取出设置的值： 12345678910111213@RestControllerpublic class HelloController &#123; @GetMapping(&quot;hello&quot;) public String hello(Model model) &#123; Map&lt;String, Object&gt; map = model.asMap(); Set&lt;String&gt; set = map.keySet(); for (String s : set) &#123; System.out.println(s + &quot;:&quot; + map.get(s)); &#125; return &quot;hello&quot;; &#125;&#125; 结果： 四、请求参数预处理实体类： 123456@Datapublic class Book &#123; private String name; private double price;&#125; 1234567@Datapublic class Author &#123; private String name; private int age;&#125; Controller: 12345678910@RestControllerpublic class BookController &#123; @PostMapping(&quot;/book&quot;) public void book(Book book, Author author) &#123; System.out.println(book); System.out.println(author); &#125;&#125; 使用 Postman 进行测试： 得到最终结果为： 当出现相同参数时，并不能分清楚参数属于哪个对象，只能将参数赋值给每一个拥有相同参数的对象 处理： Controller： 1234567891011@RestControllerpublic class BookController &#123; @PostMapping(&quot;/book&quot;) public void book(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) &#123; System.out.println(book); System.out.println(author); &#125;&#125; 参数配置： 12345678910111213@ControllerAdvicepublic class GlobalData &#123; @InitBinder(&quot;a&quot;) public void initA(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;a.&quot;); &#125; @InitBinder(&quot;b&quot;) public void initB(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;b.&quot;); &#125;&#125; 使用 Postman 进行测试： 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"注解","slug":"注解","permalink":"http://wangba.me/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"ElasticSearch入门","slug":"ElasticSearch入门","date":"2020-08-12T07:02:23.000Z","updated":"2020-08-12T07:40:52.851Z","comments":true,"path":"2020/08/12/ElasticSearch入门/","link":"","permalink":"http://wangba.me/2020/08/12/ElasticSearch%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、参考链接01.ES官网 02.Spring Boot Elasticsearch 入门 03.图解 Elasticsearch 原理 二、ElasticSearch概述三、Solr和ElasticSearch的对比四、ElasticSearch安装五、Kibana安装5.1 下载 Kibana官方下载地址 注：可以在past releases下载老版本 5.2 运行解压后进入bin目录运行： 1./kibana 在浏览器打开： http://localhost:5601/ 5.3 汉化 zh-CN.json是Kibana的汉化包 再到 kibana.yml 中加入： 六、ElasticSearch核心概念6.1 与关系型数据库对比 elasticsearch是面向文档，关系型数据库和 elasticsearch 客观的对比！一切都是JSON MySQL ElasticSearch 数据库（database） 索引（index） 表（tables） 类型（types） ES 文档（documents） 列（columns） 字段（fields） 注：其中 types 逐渐被弃用了，8.X将被删除 6.2 一个🌰： 对应上面数据库： 6.3 设计elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多个文档(行)，每个文档中又包含多个字段(列)。 物理设计： elasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移 一个人就是一个集群！默认的集群名称就是 elaticsearh 参考以下： 云上的集群 集群里的盒子 节点之间 索引里的小方块 在 ElasticSearch head 中可以看见默认集群的名字为：elasticsearch 逻辑设计： 一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的顺序找到它: 索引 ----&gt; 类型 ----&gt; 文档ID 通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串。 6.4 文档就是我们的一条数据 之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个重要属性 : 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key：value！ 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！就是一个json对象！ 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用， 在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。 尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型 。 6.5 类型​ 类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射， 比如 name 映射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段， 比如新增一个字段，那么elasticsearch是怎么做的呢？elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整型。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。 6.6 索引就是数据库 索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。 一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 ) 在 ElasticSearch head 中可以看见刚建立的索引是5个分片： 6.7 倒排elasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例 如，现在有两个文档， 每个文档包含如下内容： Study every day, good good up to forever # 文档1包含的内容To forever, study every day, good good up # 文档2包含的内容 为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档 term doc_1 doc_2 Study √ X To X √ every √ √ forever √ √ day √ √ study X √ good √ √ every √ √ to √ X up √ √ 现在，我们试图搜索 to forever，只需要查看包含每个词条的文档 score term doc_1 doc_2 to √ X forever √ √ total 2 1 如果没有别的条件，现在，这两个包含关键字的文档都将返回。 在elasticsearch中， 索引 （库）这个词被频繁使用，这就是术语的使用。 在elasticsearch中，索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢! 如无特指，说起索引都是指elasticsearch 的索引。 关系图： 一个 ES 索引 —–&gt; 多个分片(shard) ​ 一个分片(shard) —–&gt; 一个 Lucene 索引 一个 ES 索引 —–&gt; —–&gt; 多个 Lucene 索引 七、IK分词器7.1 分词分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个 词，比如 “我是王八” 会被分为”我”、“是”、“王”、“八”，这显然是不符合要求的，所以我们需要安装中文分词器 IK 来解决这个问题。 IK 提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！ 7.2 下载安装下载地址：IK 分词器下载 安装：解压后放入 plugins 文件夹下 重启 ElasticSearch ：看到 IK 分词器已经加载到 ES 里面了 7.3 IK 分词器的小🌰：使用 ik_smart 算法： 最少切分 使用 ik_max_word 算法： 最细粒度划分：通过字典，找寻所有符合的情况 7.4 自行 DIY 字典在出现以下情况时：我们需要的是 神魔恋 应该是一个词语，而不应该被分词为 神魔 与 恋 在 IK 的 config 目录下，配置 wangba.dic 和 IKAnalyzer.cfg.xml 如下： IKAnalyzer.cfg.xml： wangba.dic: 重启 ES 和 Kibana：已经可以看见 wangba.dic 已经加载进去了 此时在Kibana中可以看见：此时 神魔恋 已经是一个词了 八、Rest风格8.1 Rest命令说明说明一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交 互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 基本Rest命令说明： method url地址 描述 PUT localhost:9200/索引名称/类型名称/文档id 创建文档（指定文档id） POST localhost:9200/索引名称/类型名称 创建文档（随机文档id） _update localhost:9200/索引名称/类型名称/文档id/_update 修改文档 DELETE localhost:9200/索引名称/类型名称/文档id 删除文档 GET localhost:9200/索引名称/类型名称/文档id 查询文档通过文档id POST localhost:9200/索引名称/类型名称/_search 查询所有数据 8.2 基本测试创建索引： PUT /索引名称/类型名称/文档id { ​ 请求体 } 注：类型即将被弃用 在 ES head 中可以看见数据已经插入成功： 8.3 类型 字符串类型 text 、 keyword 数值类型 long、integer、 short、byte、double、float、half_float、 scaled_float 日期类型 date 布尔值类型 boolean 二进制类型 binary 自定义类型： 通过 GET 请求可以看见 test2 索引的信息： 自动匹配类型： 8.4 关于索引的基本操作 增加：如上 查询：如上 修改：如下 方法一：直接覆盖 可以看见 version 发生了改变 方法二： POST /索引名称/_doc/文档id/__update { ​ 请求体 } 可以看见 version 再次发生了改变 删除 8.5 关于文档的基本操作基本操作： 增加数据 PUT 查询数据 GET 方式一：简单的 ID 查询 可以看见，推荐使用 GET /索引/_doc/文档ID 来进行操作 方式二：简单的条件查询 可以看见 type 已经被丢弃了 更新数据 POST 可以看见，推荐使用 POST /索引/_update/文档ID 来进行操作 复杂操作：select (排序、分页、高亮、模糊查询、精准查询 ) 查询 ES 中有 zhangsan 和 zhangshan 008 ，通过关键字zhangsan 查询，会将分词后的结果全部查询出来，且每一个都是有 _score 的。 hits：在Java可以得到索引和文档的信息、查询的结果总数、具体文档数据信息（可以通过遍历得到具体的各种信息） 通过 _source 来指定最后的输出结果 排序 通过 sort 进行排序，用 desc 和 asc 来进行降序和升序 分页 /search/{current}/{pagesize} 第一页一个数据 第二页的一个数据 第一页的两个数据 bool 值查询 must 命令 == and should 命令 == or 两个都查询到了 must_not 命令 == not filter 命令 gt：大于 / gte：大于等于 / lt：小于 / lte：小于等于 匹配多个条件 直接在 tags 中加空格 精确查询 term 查询是直接通过倒排索引指定的词条进行精确的查询 term：直接查询精确的 match：使用分词器解析（先分析文档，在通过分析的文档进行查询） 两个类型： text： 会被分词解析器解析 keyword： 不会被分词解析器解析 使用 keywod 分词器： 使用 standard 分词器： text： 可以看见下面被分词了，所以出现了两个结果 keyword： 可以看见下面没有被分词 高亮查询 九、SpringBoot集成ElasticSearch官方 ES Client 文档 1.依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt;&lt;/dependency&gt; 2.找对象 3.分析类中方法 ES 的版本与本机中的版本不一致 自行配置 SpringBoot 中的 ES 版本 RestClientAutoConfiguration 和 RestClientProperties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.boot.autoconfigure.elasticsearch.rest;import java.time.Duration;import org.apache.http.HttpHost;import org.apache.http.auth.AuthScope;import org.apache.http.auth.Credentials;import org.apache.http.auth.UsernamePasswordCredentials;import org.apache.http.client.CredentialsProvider;import org.apache.http.impl.client.BasicCredentialsProvider;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.beans.factory.ObjectProvider;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.PropertyMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;class RestClientConfigurations &#123; RestClientConfigurations() &#123; &#125; @Configuration( proxyBeanMethods = false ) // RestClient 普通客户端 static class RestClientFallbackConfiguration &#123; RestClientFallbackConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder) &#123; return builder.build(); &#125; &#125; @Configuration( proxyBeanMethods = false ) @ConditionalOnClass(&#123;RestHighLevelClient.class&#125;) // RestHighLevelClient 高级客户端 static class RestHighLevelClientConfiguration &#123; RestHighLevelClientConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder restClientBuilder) &#123; return new RestHighLevelClient(restClientBuilder); &#125; @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder, ObjectProvider&lt;RestHighLevelClient&gt; restHighLevelClient) &#123; RestHighLevelClient client = (RestHighLevelClient)restHighLevelClient.getIfUnique(); return client != null ? client.getLowLevelClient() : builder.build(); &#125; &#125; @Configuration( proxyBeanMethods = false ) // RestClientBuilder static class RestClientBuilderConfiguration &#123; RestClientBuilderConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers) &#123; HttpHost[] hosts = (HttpHost[])properties.getUris().stream().map(HttpHost::create).toArray((x$0) -&gt; &#123; return new HttpHost[x$0]; &#125;); RestClientBuilder builder = RestClient.builder(hosts); PropertyMapper map = PropertyMapper.get(); map.from(properties::getUsername).whenHasText().to((username) -&gt; &#123; CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); Credentials credentials = new UsernamePasswordCredentials(properties.getUsername(), properties.getPassword()); credentialsProvider.setCredentials(AuthScope.ANY, credentials); builder.setHttpClientConfigCallback((httpClientBuilder) -&gt; &#123; return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider); &#125;); &#125;); builder.setRequestConfigCallback((requestConfigBuilder) -&gt; &#123; properties.getClass(); map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMillis).to(requestConfigBuilder::setConnectTimeout); properties.getClass(); map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis).to(requestConfigBuilder::setSocketTimeout); return requestConfigBuilder; &#125;); builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123; customizer.customize(builder); &#125;); return builder; &#125; &#125;&#125; 十、索引、文档 API 操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289package com.wangba;import com.alibaba.fastjson.JSON;import com.wangba.enity.User;import org.apache.lucene.search.TermQuery;import org.apache.lucene.util.QueryBuilder;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchRequestBuilder;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.action.support.master.AcknowledgedResponse;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.client.indices.CreateIndexResponse;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.common.unit.TimeValue;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.index.query.MatchAllQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.TermQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.FetchSourceContext;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.repository.query.Param;import org.w3c.dom.ls.LSOutput;import java.io.IOException;import java.util.ArrayList;import java.util.concurrent.TimeUnit;@SpringBootTestclass SpringbootEsApiApplicationTests &#123; @Autowired @Qualifier(&quot;restHighLevelClient&quot;) private RestHighLevelClient client; /** * @Description: 创建索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void createIndex() throws IOException &#123; // 1. 创建索引请求 CreateIndexRequest request = new CreateIndexRequest(&quot;test&quot;); // 2. 让客户端执行请求 indicesClient CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); &#125; /** * @Description: 查询索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void existIndex() throws IOException &#123; GetIndexRequest request = new GetIndexRequest(&quot;test&quot;); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * @Description: 删除索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void deleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(&quot;test&quot;); AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete); &#125; /** * @Description: 添加文档 PUT test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void addDocument() throws IOException &#123; // 创建对象 User user = new User(&quot;wangba&quot;, 25); // 创建请求 IndexRequest request = new IndexRequest(&quot;test&quot;); // 规则： ==&gt; PUT test/_doc/1 request.id(&quot;1&quot;); request.timeout(&quot;1s&quot;); // 将我们的数据放入请求中 JSON格式 request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求，返回结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); // 对应的状态就是 CREATED 等 &#125; /** * @Description: 文档是否存在 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void existDocument() throws IOException &#123; // GET test/_doc/1 GetRequest request = new GetRequest(&quot;test&quot;, &quot;1&quot;); // _source 不显示上下文 request.fetchSourceContext(new FetchSourceContext(false)); request.storedFields(&quot;_none_&quot;); boolean exists = client.exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * @Description: 查询文档数据 GET test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void getDocument() throws IOException &#123; GetRequest request = new GetRequest(&quot;test&quot;, &quot;1&quot;); GetResponse documentFields = client.get(request, RequestOptions.DEFAULT); System.out.println(documentFields.getSourceAsString()); System.out.println(documentFields); &#125; /** * @Description: 更新文档 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void updateDocument() throws IOException &#123; UpdateRequest request = new UpdateRequest(&quot;test&quot;, &quot;1&quot;); User user = new User(&quot;zhansan&quot;, 22); request.doc(JSON.toJSONString(user), XContentType.JSON); UpdateResponse update = client.update(request, RequestOptions.DEFAULT); System.out.println(update); System.out.println(update.status()); &#125; /** * @Description: 删除文档 DELETE test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void deleteDocument() throws IOException &#123; DeleteRequest request = new DeleteRequest(&quot;test&quot;, &quot;1&quot;); DeleteResponse delete = client.delete(request, RequestOptions.DEFAULT); System.out.println(delete); &#125; /** * @Description: 批处理请求 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void addBulkDocument() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(&quot;10s&quot;); ArrayList&lt;User&gt; userArrayList = new ArrayList&lt;&gt;(); userArrayList.add(new User(&quot;zhangsan&quot;, 5)); userArrayList.add(new User(&quot;lisi&quot;, 10)); userArrayList.add(new User(&quot;xiaoxin&quot;, 25)); for (int i = 0; i &lt; userArrayList.size(); i++) &#123; bulkRequest.add( new IndexRequest(&quot;test&quot;) .id(&quot;&quot;+(i+1)) .source(JSON.toJSONString(userArrayList.get(i)), XContentType.JSON) ); &#125; BulkResponse bulk = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulk); System.out.println(bulk.status()); System.out.println(bulk.hasFailures()); &#125; /** * @Description: 按条件搜索 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ /* 查询： SearchRequest 搜索请求 SearchSourceBuilder 条件构造 HighlightBuilder 高亮构造 TermQueryBuilder 精确查询 MatchAllQueryBuilder 所有查询 // xxxBuilder */ @Test void searchDocument() throws IOException &#123; // 创建搜索请求 SearchRequest searchRequest = new SearchRequest(&quot;test&quot;); // 构造搜索条件 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); // QueryBuilders.termQuery 精确查询 // QueryBuilders.matchAllQuery 查询所有 //TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;age&quot;, &quot;25&quot;); //searchSourceBuilder.query(termQueryBuilder); MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); searchSourceBuilder.query(matchAllQueryBuilder); // 分页 // searchSourceBuilder.from(); // searchSourceBuilder.size(); searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(searchSourceBuilder); SearchResponse search = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(search.getHits())); System.out.println(&quot;+++++++++++++我是分割线++++++++++++++&quot;); for (SearchHit documentFields : search.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsMap()); &#125; &#125;&#125; 十一、实战","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://wangba.me/tags/java/"},{"name":"ES","slug":"ES","permalink":"http://wangba.me/tags/ES/"}]}],"categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"},{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"},{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"},{"name":"WangBa's CookBook","slug":"WangBa-s-CookBook","permalink":"http://wangba.me/categories/WangBa-s-CookBook/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"},{"name":"Queue","slug":"Queue","permalink":"http://wangba.me/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"http://wangba.me/tags/Stack/"},{"name":"Life","slug":"Life","permalink":"http://wangba.me/tags/Life/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://wangba.me/tags/LinkedList/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"},{"name":"Session","slug":"Session","permalink":"http://wangba.me/tags/Session/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://wangba.me/tags/NoSQL/"},{"name":"CookBook","slug":"CookBook","permalink":"http://wangba.me/tags/CookBook/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"},{"name":"Two pointer","slug":"Two-pointer","permalink":"http://wangba.me/tags/Two-pointer/"},{"name":"JSON","slug":"JSON","permalink":"http://wangba.me/tags/JSON/"},{"name":"注解","slug":"注解","permalink":"http://wangba.me/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"java","slug":"java","permalink":"http://wangba.me/tags/java/"},{"name":"ES","slug":"ES","permalink":"http://wangba.me/tags/ES/"}]}