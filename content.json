{"meta":{"title":"wangba's blogs","subtitle":"","description":"辞去已无年少日,羁绊永结少年心","author":"wangba","url":"http://wangba.me","root":"/"},"pages":[{"title":"categories","date":"2020-08-12T00:57:07.000Z","updated":"2020-09-29T06:10:59.525Z","comments":true,"path":"categories/index.html","permalink":"http://wangba.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-12T00:56:53.000Z","updated":"2020-09-29T06:11:31.657Z","comments":true,"path":"tags/index.html","permalink":"http://wangba.me/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-08-12T01:50:42.000Z","updated":"2020-09-11T12:03:23.090Z","comments":true,"path":"about/index.html","permalink":"http://wangba.me/about/index.html","excerpt":"","text":"👋 &nbsp;Hey there! I’m Wangba😯 About meI’m a student of USTC, I’m a Javaer (Java NO.1 !!!)Welcome to my website: wangba’s blogs or wangba’s blog"},{"title":"link","date":"2020-08-12T00:57:15.000Z","updated":"2020-09-29T06:14:20.312Z","comments":true,"path":"friends/index.html","permalink":"http://wangba.me/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Algorithm","slug":"Algorithm","date":"2020-10-01T14:42:29.000Z","updated":"2020-10-01T14:52:58.430Z","comments":true,"path":"2020/10/01/Algorithm/","link":"","permalink":"http://wangba.me/2020/10/01/Algorithm/","excerpt":"","text":"​ 最近实习后发现自己的算法能力急剧下降，CRUD 只是下限，算法才是上限，决定重新开一个系列，将数据结构与算法重新学一遍。这次主要参考的课程是《数据结构与算法之美》和《算法面试通关40讲》。这里就不像《算法导论》那样比较理论化，应该会更偏向于《算法》这本书的类型。 可以看到下面这些有趣的点： 🐷 尽量利用图 + 文字，清晰的表达意思 🐢 一定要结合 Leetcode 上的题目 🐭 尽量介绍一些没用有趣的小 Tips 🐦 使用 Java 来实现所有的算法","categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"}]},{"title":"Array","slug":"Array","date":"2020-10-01T14:35:15.000Z","updated":"2020-10-01T14:35:15.025Z","comments":true,"path":"2020/10/01/Array/","link":"","permalink":"http://wangba.me/2020/10/01/Array/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringBoot整合Spring Security (三)","slug":"SpringBoot整合Spring-Security-三","date":"2020-09-30T06:47:27.000Z","updated":"2020-09-30T08:49:43.318Z","comments":true,"path":"2020/09/30/SpringBoot整合Spring-Security-三/","link":"","permalink":"http://wangba.me/2020/09/30/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%89/","excerpt":"","text":"一、OverView​ 在前后端不分离时代，可能使用的就是上一节中这种方法；在现在这种前后端分离遍地走的情况下，已经不再推荐使用传统的 session ，而是使用现在比较流行的 JWT 这种 token 的方式解决 ​ 对比分析一下： 有状态登录 无状态登录 定义 服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理 服务端不保存任何客户端请求者信息；客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 优点 比较方便，不需要做多余的处理 使用 token 很灵活；服务端不需要存数据；客户端也可以发送给多个服务器 缺点 只能是网页端，在 IOS、Android不行；服务端保存大量数据；集群化不太行 配置稍微复杂(其实在框架的加成下，不复杂) 有状态登录 🌰：在 Tomcat 中，用户登录后，需要把用户的信息保存在服务器的 session 中，然后发送给用户一个 Cookie 值，记录对应的 session 值，等用户下一次再次访问该服务器时，浏览器会自动带上这个 Cookie 值，服务端再识别其中的 session 值，进行判断 无状态登录 🌰：客户端发送账户密码到服务端进行验证；认证后服务端发送一个 token 给客户端；以后客户端每次发送请求都将 token 携带上进行认证，进行判断 二、Test​ 在前后端分离的基础上，现在前端和后端只是通过 JSON 进行交互，所以现在的页面跳转全部由前端进行控制，后端只是返回不同的 JSON 罢了 重写SecurityConfig中的 configure 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() // 登出页面 + 登出成功后页面 .logout() .logoutUrl(&quot;/logout&quot;) .logoutSuccessUrl(&quot;/login.html&quot;) .logoutSuccessHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123; httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close(); &#125;) .and() // 登录页面 + 登录接口 .formLogin().loginPage(&quot;/login.html&quot;) .loginProcessingUrl(&quot;/securityLogin&quot;) .permitAll() // 登录失败处理器 .failureHandler((httpServletRequest, httpServletResponse, e) -&gt; &#123; httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(e.getMessage()); out.flush(); out.close(); &#125;) // 登录成功处理器 .successHandler((httpServletRequest, httpServletResponse, authentication) -&gt; &#123; Object principal = authentication.getPrincipal(); httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close(); &#125;) .and() .csrf().disable() ;&#125; 登录接口 注： 可以看到使用前后端分离，就不需要后端来控制跳转页面等，只需要将 JSON 发给前端就行 这里面的 password 为空，是框架做的，具体可以看这里 登录失败 注： 无论是用户名和密码其中一个错误，就会返回 Bad credentials 提示，主要也是为了安全着想，具体流程可以看下面的 3.1 小节 注销登录 三、Deep Learning3.1 深入了解登录失败​ 在上面我们提到了无论是用户名和密码其中一个错误，就会返回 Bad credentials，实则在其中还有很多种错误，而且用户名是有用户名错误，只是最终被 Bad credentials 覆盖了，稍微分析一下： AbstractUserDetailsAuthenticationProvider 12345678910111213141516171819public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123; return this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;); &#125;); String username = authentication.getPrincipal() == null ? &quot;NONE_PROVIDED&quot; : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); &#125; catch (UsernameNotFoundException var6) &#123; this.logger.debug(&quot;User &#x27;&quot; + username + &quot;&#x27; not found&quot;); if (this.hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; // 省略&#125; 在上面这段代码中，进行调试可以看见： 会先在缓存中查询一下是否有过 再调用 retrieveUser 来进行判断 一旦抛出 UsernameNotFoundException ，就看 hideUserNotFoundExceptions 的值了，如果为 true，就会抛出 Bad credentials 进行断点调试：输错用户名，并打上断点： 通过上图就能看出，hideUserNotFoundExceptions 默认值是 true 的 3.2 未认证处理在前后端分离，如果出现未认证的状态，不可能控制前端来跳转页面等，只能给前端返回相应的信息即可： 在 AuthenticationEntryPoint 接口中有一个方法：commence 在 LoginUrlAuthenticationEntryPoint 中实现方式为： 1234567891011121314151617181920212223public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; String redirectUrl = null; if (this.useForward) &#123; if (this.forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) &#123; redirectUrl = this.buildHttpsRedirectUrlForRequest(request); &#125; if (redirectUrl == null) &#123; String loginForm = this.determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Server side forward to: &quot; + loginForm); &#125; RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); dispatcher.forward(request, response); return; &#125; &#125; else &#123; redirectUrl = this.buildRedirectUrlToLoginPage(request, response, authException); &#125; this.redirectStrategy.sendRedirect(request, response, redirectUrl);&#125; 这段代码中最主要的是看一下 useForward 的默认值，如果是 true，那么默认就是走转发；如果是 false，那么默认走的就是重定向 使出断点调试大法： 在 Postman 中直接使用 GET 方式请求：localhost:8080/security 此方法在第一节中已经写过了，就是输出一个 Spring Security 在方法内打上断点 从上面的图就可以看见，useForward 的默认值是 false，那么就可以确定是走的重定向 只需要重写该方法覆盖它就行： 12345678.exceptionHandling().authenticationEntryPoint((req, resp, authException) -&gt; &#123; resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close();&#125;)","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security (二)","slug":"SpringBoot整合Spring-Security-二","date":"2020-09-28T10:13:07.000Z","updated":"2020-09-30T07:09:26.232Z","comments":true,"path":"2020/09/28/SpringBoot整合Spring-Security-二/","link":"","permalink":"http://wangba.me/2020/09/28/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%BA%8C/","excerpt":"","text":"一、Test环境与上一节的环境一致，这一节主要来进行自定义操作 在 SecurityConfig 中重写这两个方法： 12345678910111213141516@Overridepublic void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;);&#125;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() ;&#125; 自行写一个登录页面： login.html 中的核心代码 123456789101112131415161718&lt;form action=&quot;/login.html&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;input&quot; style=&quot;text-align: center&quot;&gt; &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;name&quot;&gt; &lt;span class=&quot;spin&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;input&quot; style=&quot;text-align: center&quot;&gt; &lt;label for=&quot;pass&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;pass&quot;&gt; &lt;span class=&quot;spin&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;button login&quot; style=&quot;text-align: center&quot;&gt; &lt;button type=&quot;submit&quot;&gt; &lt;span&gt;登录&lt;/span&gt; &lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 主要注意以下几个方面： form 的请求地址是 /login.html，方法是 post 用户名和密码的属性值分别是 username 和 password 二、Deep Learning 🐢之疑问一：为啥默认的登录页面和登录接口是一样的？自定义页面又是如何覆盖默认页面的呢？ 默认登录页面 关于页面的登录的配置都在：FormLoginConfigurer 其中这个类又是继承 AbstractAuthenticationFilterConfigurer 类的 则在 FormLoginConfigurer 初始化的时候，AbstractAuthenticationFilterConfigurer 的构造方法中： 123protected AbstractAuthenticationFilterConfigurer() &#123; setLoginPage(&quot;/login&quot;);&#125; 此时如果没有自定义登录页面，就会是 项目地址/login 这个地址 再看一下 FormLoginConfigurer 中的 init 方法： 1234public void init(H http) throws Exception &#123; super.init(http); initDefaultLoginFilter(http);&#125; 这个方法是调用了父类的 init 方法： 12345public void init(B http) throws Exception &#123; updateAuthenticationDefaults(); updateAccessDefaults(http); registerDefaultAuthenticationEntryPoint(http);&#125; 在父类的 init 方法中调用了 updateAuthenticationDefaults() 方法： 123456789101112131415protected final void updateAuthenticationDefaults() &#123; // 未自定义页面，就会和 loginPage 地址一样 if (loginProcessingUrl == null) &#123; loginProcessingUrl(loginPage); &#125; if (failureHandler == null) &#123; failureUrl(loginPage + &quot;?error&quot;); &#125; final LogoutConfigurer&lt;B&gt; logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null &amp;&amp; !logoutConfigurer.isCustomLogoutSuccess()) &#123; logoutConfigurer.logoutSuccessUrl(loginPage + &quot;?logout&quot;); &#125;&#125; 此时就能看到：如果我们没有自定义登录接口，那么登录接口的地址就会被设置为和登录页面一致 自定义登录页面 如果自定义了页面地址，首先会到 FormLoginConfigurer 中 123public FormLoginConfigurer&lt;H&gt; loginPage(String loginPage) &#123; return super.loginPage(loginPage);&#125; 在这里面调用了父类的 loginPage 方法： 123456protected T loginPage(String loginPage) &#123; setLoginPage(loginPage); updateAuthenticationDefaults(); this.customLoginPage = true; return getSelf();&#125; 可以看到，在这里面 set 完 loginPage 后，又双调用了 updateAuthenticationDefaults() 方法，这个方法在 ☝️ 有 如果自定义了登录接口 loginProcessingUrl ，那么就会进入这个方法： 123456public T loginProcessingUrl(String loginProcessingUrl) &#123; this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf();&#125; 🐢之疑问二：在提交的表单中，参数分别为 username 和 password，可不可以自定义呢？ 首先还是去 FormLoginConfigurer 类中看看构造方法： 12345public FormLoginConfigurer() &#123; super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;);&#125; 这里的 super 根据 👆 的继承关系，就可以知道是 AbstractAuthenticationFilterConfigurer 中的构造： 123456789protected AbstractAuthenticationFilterConfigurer(F authenticationFilter, String defaultLoginProcessingUrl) &#123; this(); // 将传进来的参数赋值给这个类的 authFilter this.authFilter = authenticationFilter; if (defaultLoginProcessingUrl != null) &#123; loginProcessingUrl(defaultLoginProcessingUrl); &#125;&#125; 注：这里为什么能传参，是由于 UsernamePasswordAuthenticationFilter 继承 AbstractAuthenticationProcessingFilter 且 F extends AbstractAuthenticationProcessingFilter 此时已经有了 UsernamePasswordAuthenticationFilter 的实例了，接着执行 usernameParameter 和 passwordParameter 方法： 123456789public FormLoginConfigurer&lt;H&gt; usernameParameter(String usernameParameter) &#123; getAuthenticationFilter().setUsernameParameter(usernameParameter); return this;&#125;public FormLoginConfigurer&lt;H&gt; passwordParameter(String passwordParameter) &#123; getAuthenticationFilter().setPasswordParameter(passwordParameter); return this;&#125; 这里的 getAuthenticationFilter 是父类的方法： 123protected final F getAuthenticationFilter() &#123; return authFilter;&#125; 到这里就很明确了，就是将刚才的 new UsernamePasswordAuthenticationFilter() 放到这里面分别调用 setUsernameParameter 和 setPasswordParameter 方法： 123456789public void setUsernameParameter(String usernameParameter) &#123; Assert.hasText(usernameParameter, &quot;Username parameter must not be empty or null&quot;); this.usernameParameter = usernameParameter;&#125;public void setPasswordParameter(String passwordParameter) &#123; Assert.hasText(passwordParameter, &quot;Password parameter must not be empty or null&quot;); this.passwordParameter = passwordParameter;&#125; 到这里，usernameParameter 和 passwordParameter 就已经被赋好值了 再通过这个类 (UsernamePasswordAuthenticationFilter) 中的这两个方法从登录请求中拿到这两个值： 123456789@Nullableprotected String obtainPassword(HttpServletRequest request) &#123; return request.getParameter(this.passwordParameter);&#125;@Nullableprotected String obtainUsername(HttpServletRequest request) &#123; return request.getParameter(this.usernameParameter);&#125; 那么自定义就很简单了： 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin().loginPage(&quot;/login.html&quot;) // 只需要设置以下两项就行 .usernameParameter(&quot;user&quot;) .passwordParameter(&quot;pwd&quot;) .permitAll() .and() .csrf().disable() ;&#125; 🐢之疑问三：登录成功 or 失败后的重定向的地址，注销登录的地址如何自定义？ 登录成功 登录失败 defaultSuccessUrl failureForwardUrl successForwardUrl failureUrl 区别简单来说就是： defaultSuccessUrl 可能你访问的地址是 http://localhost:8080/security 但是你没登录，所以你就跳转到 http://localhost:8080/login 页面下，如果你登录成功，那么就会回到 /security 页面 successForwardUrl 不管是什么页面，登录成功一律是你设置的页面 登录失败同理 注销登录 看下面的代码 logoutUrl：用来注销的地址，默认为 “/logout” logoutRequestMatcher：改变注销地址，还有请求方式 logoutSuccessUrl：注销登录成功后，要跳转的地址 12345678910111213141516171819202122232425262728293031@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() // 注销登录设置 .logout() .logoutUrl(&quot;&quot;) .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) .logoutSuccessUrl(&quot;&quot;) // 登录设置 .and() .formLogin().loginPage(&quot;/login.html&quot;) .usernameParameter(&quot;user&quot;) .passwordParameter(&quot;pwd&quot;) // 下面两个只需要一个 .defaultSuccessUrl(&quot;&quot;) .successForwardUrl(&quot;&quot;) // 下面两个只需要一个 .failureForwardUrl(&quot;&quot;) .failureUrl(&quot;&quot;) .permitAll() .and() .csrf().disable() ;&#125;","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Spring Security (一)","slug":"SpringBoot整合Spring-Security-一","date":"2020-09-27T10:52:23.000Z","updated":"2020-09-30T07:09:23.777Z","comments":true,"path":"2020/09/27/SpringBoot整合Spring-Security-一/","link":"","permalink":"http://wangba.me/2020/09/27/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%80/","excerpt":"","text":"一、OverViewJava 中权限管理最常用的技术应该就是：Spring Security 和 Shiro。 虽然 Shiro 用它轻量、简单、易于集成占据一席之地，但随着 SpringBoot 的流行，Spring Security 也跟着鸡犬升天，就目前的趋势来看，Spring Security 结合 Oauth2、JWT 等更加方便。 这次先小试牛刀一下，快速入门…… 二、Environment不想 error ，先看依赖 没看错，就只需要这两个依赖就行 pom.xml 12345678910&lt;!--security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SecurityController 12345678@RestControllerpublic class SecurityController &#123; @GetMapping(&quot;/security&quot;) public String hello() &#123; return &quot;spring security&quot;; &#125;&#125; 三、Test启动项目可以看见，在控制台多了一行： Postman 可以看见报错：401，没有进行认证 加上认证 可以看见，加上 Basic Auth： 其中用户名为 user，密码为刚才控制台显示的即可 四、Deep Learning🐢之疑问：为啥用户名是 user，密码就是控制台显示的那个？ 分析思路： 用户名和密码肯定在一起，这个密码又是 UUID 形式，某个地方肯定用了 UUID.randomUUID().toString() 按照我们对 SpringBoot 的特性，肯定在 XXXAutoConfiguration 和 XXXProperties 中存在，果然在 SecurityProperties 中看到了： 接下来，我们要去找一找，在哪里有调用 getPassword 的这个方法的类： 看名字应该就是：UserDetailsServiceAutoConfiguration 12345678910private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) &#123; String password = user.getPassword(); if (user.isPasswordGenerated()) &#123; logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword())); &#125; if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123; return password; &#125; return NOOP_PASSWORD_PREFIX + password;&#125; 其中： user.isPasswordGenerated() 如果为 true，则打印该信息 再去 ==user.isPasswordGenerated()== 方法中探究一下，回到了==SecurityProperties== 类中了： 1234567private boolean passwordGenerated = true; .......public boolean isPasswordGenerated() &#123; return this.passwordGenerated;&#125; 默认情况下：passwordGenerated 就是为 true 🐢之疑问：每次启动都要输入新的的密码，太麻烦了，我需要自定义 第一种方法： 按照 SpringBoot 的特性，必然已经给你安排好了，肯定有一种方法是在 properties 文件中直接进行： idea 已经通过提示显示出来了, idea yyds ! 直接点进去看一下，回跳到哪个类中，不出🐢🐢的所料，应该就是 ==SecurityProperties== 类中： 果不其然，分别跳到了 setName 123public void setName(String name) &#123; this.name = name;&#125; setPassword 1234567public void setPassword(String password) &#123; if (!StringUtils.hasLength(password)) &#123; return; &#125; this.passwordGenerated = false; this.password = password;&#125; 注：如果在这里自定义了密码，就会将 ==passwordGenerated== 设置为 false，那么在 ==isPasswordGenerated== 就是 false 了，在 ==UserDetailsServiceAutoConfiguration== 中就不会自动生成密码了 application.properties 12spring.security.user.name=wangbaspring.security.user.password=8888 第二种方法： 123456789101112131415161718@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean PasswordEncoder passwordEncoder() &#123; // 不对密码进行任何编码方式 return NoOpPasswordEncoder.getInstance(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(&quot;wangba&quot;) .password(&quot;guigui&quot;) .roles(&quot;admin&quot;) ; &#125;&#125;","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"}]},{"title":"SpringBoot整合Session","slug":"SpringBoot整合Session","date":"2020-09-22T13:43:13.000Z","updated":"2020-09-30T07:09:20.959Z","comments":true,"path":"2020/09/22/SpringBoot整合Session/","link":"","permalink":"http://wangba.me/2020/09/22/SpringBoot%E6%95%B4%E5%90%88Session/","excerpt":"","text":"一、OverView Spring Session has the simple goal of free up session management from the limitations of the HTTP session stored in the server. The solution makes it easy to share session data between services in the cloud without being tied to a single container (i.e. Tomcat). Additionally, it supports multiple sessions in the same browser and sending sessions in a header. 简单地来说：由架构导致了这种情况的发生 present 最早的架构就是很简单的单服务器状态，如果我们要保存用户状态，那么只需要一个 session 就行了 now 现在的架构都是集群式了：可以假设这样的情景，如果我在已经登录的状态，我首先要看视频 (这个服务假如在 A 服务器上)，然后我又浏览图片 (这个服务假如在 B 服务器上)，如果不共享 session 的话，那么我选择的服务不在一个服务器上就要重新登录了，这对用户也太不友好了。 解决方案 主流的解决方案：将 seesion 存到 redis 中，每次 server 要向 session 中写数据，或者要读 session 的数据时，都是对 redis 中的 session 进行操作。 二、环境搭建不想 error ，先看依赖 pom.xml 123456789101112131415&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--spring session--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 1234567891011# redis 基本配置# 地址spring.redis.host=10.2.10.115# 端口号 默认就是 6379spring.redis.port=6379# 密码spring.redis.password=123456# 第几个数据库 默认就是第0号数据库spring.redis.database=0server.port=8080 SessionController 1234567891011121314151617@RestControllerpublic class SessionController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) Integer port; @GetMapping(&quot;/set&quot;) public String set(HttpSession session) &#123; session.setAttribute(&quot;wangba&quot;, &quot;8888&quot;); return String.valueOf(port); &#125; @GetMapping(&quot;/get&quot;) public String get(HttpSession session) &#123; return session.getAttribute(&quot;user&quot;) + &quot;:&quot; + port; &#125;&#125; 三、测试访问：http://localhost:8080/set 此时打开 redis 看一下： 再访问：http://localhost:8081/get 可以看到此时，在不同的服务上可以通过共享 session 注：这边可以通过 nginx 进行负载均衡","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Session","slug":"Session","permalink":"http://wangba.me/tags/Session/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2020-09-16T13:34:57.000Z","updated":"2020-09-30T07:09:18.512Z","comments":true,"path":"2020/09/16/SpringBoot整合Redis/","link":"","permalink":"http://wangba.me/2020/09/16/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"","text":"一、OverView面试官：redis 知道吗 🐢：不知道 面试官：你回去等通知吧 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。在2013年5月之前，其开发由VMware赞助。https://zh.wikipedia.org/wiki/Redis#cite_note-5)根据月度排行网站DB-Engines.com的数据，Redis是最流行的键值对存储数据库。 ——–维基百科 我记得我看过一篇讲的非常好的 NoSQL 的文章，下次找到加进来。 增加：关系型数据库与非关系型数据库 二、环境搭建Redis 首先准备好 redis 的环境，此次 redis 是安装在 Ubuntu 18.04 上的，主要配置如下： 可以使用 sudo vi /etc/redis/redis.conf 命令： 123456789101112131415# 该指令允许您声明一个init系统来管理Redis作为服务，从而为您提供对其操作的更多控制supervised systemd# 为了局域网能连接上bind 127.0.0.1 ::1 改为bind 0.0.0.0# 为了局域网能连接上protected-mode yes 改为protected-mode no# 修改密码，非必须requirepass 123456 常用命令： 1234567891011121314151617181920# 修改 redis 配置sudo vi /etc/redis/redis.conf# 重启 redis 服务sudo service redis restart# 启动 redis 服务sudo service redis start# 关闭 redis 服务sudo service redis stop# 启动 redis 客户端，其中 -p 指定端口，-a 表示认证即密码redis-cli -p 6379 -a 123456# 在 redis 里面的一些命令127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; keys *127.0.0.1:6379&gt; get key的名字 pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 123456789# redis 基本配置# 地址spring.redis.host=10.2.10.108# 端口号 默认就是 6379spring.redis.port=6379# 密码spring.redis.password=123456# 第几个数据库 默认就是第0号数据库spring.redis.database=0 三、测试RedisController 12345678910111213141516171819202122@RestControllerpublic class RedisController &#123; private StringRedisTemplate stringRedisTemplate; @Autowired public void setStringRedisTemplate(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @GetMapping(&quot;/put&quot;) public void test1(String key, String value) &#123; ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(key, value); &#125; @GetMapping(&quot;/get&quot;) public String test2(String key) &#123; ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); return ops.get(key); &#125;&#125; Postman 首先将 redis 清空： 插入： 看下 redis 中： 查询：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://wangba.me/tags/NoSQL/"}]},{"title":"铁氏王朝满汉全席 919","slug":"铁氏王朝满汉全席-919","date":"2020-09-15T13:23:00.000Z","updated":"2020-09-30T07:09:13.230Z","comments":true,"path":"2020/09/15/铁氏王朝满汉全席-919/","link":"","permalink":"http://wangba.me/2020/09/15/%E9%93%81%E6%B0%8F%E7%8E%8B%E6%9C%9D%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD-919/","excerpt":"","text":"919 铁氏王朝满汉全席 v1.3 清蒸大闸蟹 5只 材料： 阳澄湖大闸蟹 生姜 蒜瓣 香葱 紫苏 生抽 香醋 料酒 香油 鸡精 糖 可乐鸡翅 材料： 鸡翅10个 可乐300毫升 老抽1勺 盐，鸡精适量 葱姜，八角适量 糖醋排骨 材料： 猪肋排500克 葱适量 姜适量 八角2个 老抽2勺 生抽2勺 白糖3勺 香醋4勺 料酒5勺 熟白芝麻适量 麻辣小龙虾 材料： 小龙虾30斤 香葱适量 姜适量 蒜适量 大葱适量 桂皮适量 八角适量 香叶适量 紫苏适量 小米椒适量 冰糖适量 藕条适量 青椒适量 红油火锅底料适量 豆瓣酱适量 淀粉适量 白芝麻适量 芝士培根泡菜卷 材料： 蒜蓉金针菇 材料： 金针菇1把 蒜一头 食用油适量 酱油4勺 蚝油2勺 小葱4根 鸡精适量 糖 盐 酒酿小汤圆冲鸡蛋 材料： 姜撞奶 材料： 老姜1大块 纯牛奶200毫升 细砂糖适量 蔓越莓干少许","categories":[{"name":"WangBa's CookBook","slug":"WangBa-s-CookBook","permalink":"http://wangba.me/categories/WangBa-s-CookBook/"}],"tags":[{"name":"CookBook","slug":"CookBook","permalink":"http://wangba.me/tags/CookBook/"},{"name":"Life","slug":"Life","permalink":"http://wangba.me/tags/Life/"}]},{"title":"SpringBoot整合Spring Data JPA 之多条件搜索工具类","slug":"SpringBoot整合Spring-Data-JPA-之多条件搜索工具类","date":"2020-09-14T12:21:20.000Z","updated":"2020-09-30T07:08:37.925Z","comments":true,"path":"2020/09/14/SpringBoot整合Spring-Data-JPA-之多条件搜索工具类/","link":"","permalink":"http://wangba.me/2020/09/14/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%B9%8B%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"一、OverView​ 在前面已经介绍过了 SpringBoot 整合 JPA 了，但是一般在公司业务中，如果出现很多次多条件搜索查询的情况，那么就会用大量冗余代码了；再结合注解的思想。本次将公共部分提取出来，并用注解的方式进行操作，可以参考前面使用注解进行 AOP 处理日志，也符合了 SpringBoot 的思想。 二、BaseQueryQueryWord 12345678910111213141516171819@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface QueryWord &#123; // 数据库中字段名,默认为空字符串,则Query类中的字段要与数据库中字段一致 String column() default &quot;&quot;; // equal, like, gt, lt... MatchType func() default MatchType.equal; // object是否可以为null boolean nullable() default false; // 字符串是否可为空 boolean empty() default false; // between...and... 查询语句标识， 0时间 1数字类型 BetweenType type() default BetweenType.datetime;&#125; 注：注解类，只要在要查询的属性上加上相应的注解即可 MatchType 12345678910111213141516171819202122public enum MatchType &#123; equal, // filed = value // 下面四个用于Number类型的比较 gt, // filed &gt; value ge, // field &gt;= value lt, // field &lt; value le, // field &lt;= value notEqual, // field != value like, // field like value notLike, // field not like value between, // between value1 and value2 ,Type is Date // 下面四个用于可比较类型(Comparable)的比较 greaterThan, // field &gt; value greaterThanOrEqualTo, // field &gt;= value lessThan, // field &lt; value lessThanOrEqualTo // field &lt;= value&#125; 注：枚举类，可以对比注释进行理解 BetweenType 1234567public enum BetweenType &#123; datetime, number_long, number_integer&#125; 注：对应上面 QueryWord中的 BetweenType ，可以对时间或数字之间的属性进行注解 BaseQuery 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public abstract class BaseQuery&lt;T&gt; &#123; // 第多少页 + 页大小 private int pageNum = 0; private int pageSize = 10; // private static Map&lt;Class, List&lt;Field&gt;&gt; fieldCache = new HashMap&lt;&gt;(); // 动态查询 public abstract Specification&lt;T&gt; toSpec(); // 分页 public Pageable toPageable() &#123; return PageRequest.of(pageNum, pageSize); &#125; // 分页 + 排序 public Pageable toPageable(Sort sort) &#123; return PageRequest.of(pageNum, pageSize, sort); &#125; // 动态查询 and 连接 protected Specification&lt;T&gt; toSpecWithAnd() &#123; return this.toSpecWithLogicType(&quot;and&quot;); &#125; // 动态查询 or 连接 protected Specification&lt;T&gt; toSpecWithOr() &#123; return this.toSpecWithLogicType(&quot;or&quot;); &#125; // logicType = or ｜ and @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;) private Specification&lt;T&gt; toSpecWithLogicType(final String logicType) &#123; final BaseQuery outerThis = this; // 封装条件查询对象 Specification Specification&lt;T&gt; specification = new Specification&lt;T&gt;() &#123; @Override // Root 用于获取属性字段，CriteriaQuery可以用于简单条件查询，CriteriaBuilder 用于构造复杂条件查询 public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Class clazz = outerThis.getClass(); // 判断缓存中是否已经存在，存在不需要再次生成，不存在需要重新生成 List&lt;Field&gt; fields = fieldCache.get(clazz); if (fields == null) &#123; // 获取查询类Query的所有字段,包括父类字段 fields = getAllFieldsWithRoot(clazz); fieldCache.put(clazz, fields); &#125; List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(fields.size()); for (Field field : fields) &#123; // 获取字段上的 @QueryWord 注解 QueryWord qw = field.getAnnotation(QueryWord.class); if (qw == null) &#123; continue; &#125; // 获取字段名 String column = qw.column(); //如果主注解上 column 为默认值&quot;&quot;,则以 field 为准 if (column.equals(&quot;&quot;)) &#123; column = field.getName(); &#125; field.setAccessible(true); try &#123; // nullable Object value = field.get(outerThis); // 如果值为 null,注解未标注 nullable,跳过 if (value == null &amp;&amp; !qw.nullable()) &#123; continue; &#125; // can be empty if (value != null &amp;&amp; String.class.isAssignableFrom(value.getClass())) &#123; String s = (String) value; //如果值为&quot;&quot;,且注解未标注 empty ,跳过 if (s.equals(&quot;&quot;) &amp;&amp; !qw.empty()) &#123; continue; &#125; &#125; //通过注解上 func 属性,构建路径表达式 Path path = root.get(column); switch (qw.func()) &#123; case equal: predicates.add(cb.equal(path, value)); break; case like: predicates.add(cb.like(path, &quot;%&quot; + value + &quot;%&quot;)); break; case gt: predicates.add(cb.gt(path, (Number) value)); break; case lt: predicates.add(cb.lt(path, (Number) value)); break; case ge: predicates.add(cb.ge(path, (Number) value)); break; case le: predicates.add(cb.le(path, (Number) value)); break; case notEqual: predicates.add(cb.notEqual(path, value)); break; case notLike: predicates.add(cb.notLike(path, &quot;%&quot; + value + &quot;%&quot;)); break; case greaterThan: predicates.add(cb.greaterThan(path, (Comparable) value)); break; case greaterThanOrEqualTo: predicates.add(cb.greaterThanOrEqualTo(path, (Comparable) value)); break; case lessThan: predicates.add(cb.lessThan(path, (Comparable) value)); break; case lessThanOrEqualTo: predicates.add(cb.lessThanOrEqualTo(path, (Comparable) value)); break; case between: switch (qw.type()) &#123; case datetime: List&lt;Date&gt; dateList = (List&lt;Date&gt;) value; predicates.add(cb.between(path, dateList.get(0), dateList.get(1))); break; case number_long: List&lt;Long&gt; longList = (List&lt;Long&gt;) value; predicates.add(cb.between(path, longList.get(0), longList.get(1))); break; case number_integer: List&lt;Integer&gt; integerList = (List&lt;Integer&gt;) value; predicates.add(cb.between(path, integerList.get(0), integerList.get(1))); break; &#125; &#125; &#125; catch (Exception e) &#123; continue; &#125; &#125; Predicate p = null; if (logicType == null || logicType.equals(&quot;&quot;) || logicType.equals(&quot;and&quot;)) &#123; p = cb.and(predicates.toArray(new Predicate[predicates.size()])); // and 连接 &#125; else if (logicType.equals(&quot;or&quot;)) &#123; p = cb.or(predicates.toArray(new Predicate[predicates.size()])); // or 连接 &#125; return p; &#125; &#125;; return specification; &#125; //获取类 clazz 的所有 Field，包括其父类的 Field private List&lt;Field&gt; getAllFieldsWithRoot(Class&lt;?&gt; clazz) &#123; List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;(); Field[] dFields = clazz.getDeclaredFields(); //获取本类所有字段 if (null != dFields &amp;&amp; dFields.length &gt; 0) &#123; fieldList.addAll(Arrays.asList(dFields)); &#125; // 若父类是 Object，则直接返回当前 Field 列表 Class&lt;?&gt; superClass = clazz.getSuperclass(); if (superClass == Object.class) &#123; return Arrays.asList(dFields); &#125; // 递归查询父类的 Field 列表 List&lt;Field&gt; superFields = getAllFieldsWithRoot(superClass); if (null != superFields &amp;&amp; !superFields.isEmpty()) &#123; for (Field field : superFields) &#123; if (!fieldList.contains(field)) &#123; fieldList.add(field); &#125; &#125; &#125; return fieldList; &#125; public int getPageIndex() &#123; return pageNum; &#125; public void setPageIndex(int pageIndex) &#123; this.pageNum = pageIndex; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 注：最关键的类 所有后面要查询的类都要继承它 简单的理解：通过反射获取注解上的字段信息，构造相应的搜索条件 三、TestStudentQuery 123456789101112131415public class StudentQuery extends BaseQuery&#123; @QueryWord(column = &quot;id&quot;, func = MatchType.equal) private Long id; @QueryWord(func = MatchType.like) private String name; // 省略 set / get @Override public Specification toSpec() &#123; return super.toSpecWithOr(); &#125;&#125; 在这个查询中，使用的是 or 查询，测试类如下： Test 123456789101112@Testpublic void find8() &#123; StudentQuery studentQuery = new StudentQuery(); studentQuery.setId(1L); studentQuery.setName(&quot;er&quot;); studentQuery.setPageIndex(0); studentQuery.setPageSize(10); Page page = studentRepository.findAll(studentQuery.toSpec(), studentQuery.toPageable()); for (Object o : page.getContent()) &#123; System.out.println(o); &#125;&#125; 注：构造的条件是 id = 1的，或者 name = ? er ? 的 student 结果 通过这个例子简单捋一下整个过程： 通过 studentQuery.toSpec() 调用父类 BaseQuery； 在 BaseQuery 中，通过反射获得打了相应注解上的字段信息； 将字段信息加到搜索条件中，进行 or 或者 and 连接 注：如果你的业务中只用了很少的条件或者只用极个别的多条件查询，可以不用这个工具类","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合Spring Data JPA(二)","slug":"SpringBoot整合Spring-Data-JPA-二","date":"2020-09-10T10:38:46.000Z","updated":"2020-09-30T07:08:31.365Z","comments":true,"path":"2020/09/10/SpringBoot整合Spring-Data-JPA-二/","link":"","permalink":"http://wangba.me/2020/09/10/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%BA%8C/","excerpt":"","text":"一、OverView​ 在上一篇文章中介绍了一下 Spring Data JPA 的一下简单的 CRUD，但是在公司业务中，不可能这么简单；且在业务中大部分都是查询业务，具体点就是动态查询，什么单表多条件查询、多表多条件查询等等…… 注：使用环境还是和上一篇一样 二、自定义SQL查询如果想和这里面写原生的 SQL 语句，只要在 repository 中这样写就行： 123@Query(nativeQuery = true, value = &quot;select * from Student where id = ?1&quot;)Student catchAllById(Long id); 注： 如果要写原生 SQL，@Query 注解中的 nativeQuery 要设置为 true，默认为 false 函数名设置的不能与自带的冲突，例如：findById，如果设置了一样，就会导致使用的自带的 API 进行查询，而不是自定义的，如果真的想使用自定义覆盖自带的，可以在实体类上使用 @NamedQueries 注解 在这里我们就使用 @Test 进行测试： 还有一种使用 JPQL 语法的查询方式： repository: 12@Query(value = &quot;select s from Student s where s.name = ?1&quot;)List&lt;Student&gt; catchByName(String name); Test: 关于 JPQL：和在 SQL 中一样，JPQL 中的 select 语句用于执行查询。其语法可表示为：select_clause form_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause] 其中： from 子句是查询语句的必选子句。 select 用来指定查询返回的结果实体或实体的某些属性。 from 子句声明查询源实体类，并指定标识符变量（相当于SQL表的别名）。 如果不希望返回重复实体，可使用关键字 distinct 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。 在 JPQL 中，查询所有实体的 JPQL 查询语句很简单，如下：select o from Order o 或 select o from Order as o这里关键字 as 可以省去，标识符变量的命名规范与 Java 标识符相同，且区分大小写 更多参考：官网文档 三、自定义简单查询在 Spring Data JPA 的官网也介绍了这种方式，一般这种方式在一些小项目中也经常使用： Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname,findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection&lt;Age&gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&lt;Age&gt; ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 原理大概如下： 假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 从右往左截取第一个大写字母开头的字符串此处为Uuid），然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设user为查询实体的一个属性； 接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 Doc.user.depUuid 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 Doc.user.dep.uuid 的值进行查询。 可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 findByUser_DepUuid() 或者 findByUserDep_uuid() repository: 1234567891011List&lt;Student&gt; findByName(String name);List&lt;Student&gt; findByNameAndPwd(String name, String pwd);List&lt;Student&gt; findByNameStartingWith(String name);List&lt;Student&gt; findByNameEndingWith(String name);List&lt;Student&gt; findByNameContaining(String name);List&lt;Student&gt; findByNameContainingOrderByIdDesc(String name); test: findByName findByNameAndPwd findByNameStartingWith findByNameEndingWith findByNameContaining findByNameContainingOrderByIdDesc 四、分页查询12345678910// 分页 + 排序@Testpublic void find6() &#123; Sort sort = Sort.by(Sort.Direction.DESC, &quot;id&quot;); PageRequest pageRequest = PageRequest.of(0, 2, sort); Page&lt;Student&gt; studentPage = studentRepository.findAll(pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; 注： Sort.by(排序方式, 排序字段) PageRequest.of(第多少页，页大小) ——–&gt; 一般是写一个 PageUtils Test 五、动态查询1234567891011121314151617// 分页 + 排序 + 搜索@Testpublic void find7() &#123; PageRequest pageRequest = PageRequest.of(0, 2, Sort.by(Sort.Direction.DESC, &quot;id&quot;)); Specification&lt;Student&gt; specification = new Specification&lt;Student&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) &#123; // 增加搜索条件: id &lt;= 5 Predicate predicate = criteriaBuilder.lessThanOrEqualTo(root.get(&quot;id&quot;), 5); return predicate; &#125; &#125;; Page&lt;Student&gt; studentPage = studentRepository.findAll(specification, pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; 注： root: 代表查询的实体类 query: 可以从中得到 Root 对象 criteriaBuilder: 用于创建 Criteria 相关对象的工厂 Predicate: 代表一个查询条件 Test: 多条件： 123456789101112131415161718// 分页 + 排序 + 搜索@Testpublic void find7() &#123; PageRequest pageRequest = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, &quot;id&quot;)); List&lt;Predicate&gt; predicateList = new ArrayList&lt;&gt;(); Specification&lt;Student&gt; specification = new Specification&lt;Student&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Student&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) &#123; predicateList.add(criteriaBuilder.lessThanOrEqualTo(root.get(&quot;id&quot;), 5)); predicateList.add(criteriaBuilder.like(root.get(&quot;name&quot;), &quot;%&quot; + &quot;er&quot;)); return criteriaBuilder.and(predicateList.toArray(new Predicate[predicateList.size()])); &#125; &#125;; Page&lt;Student&gt; studentPage = studentRepository.findAll(specification, pageRequest); for (Student student : studentPage.getContent()) &#123; System.out.println(student); &#125;&#125; Test:","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合Spring Data JPA(一)","slug":"SpringBoot整合Spring-Data-JPA-一","date":"2020-09-10T10:38:30.000Z","updated":"2020-09-30T07:08:34.596Z","comments":true,"path":"2020/09/10/SpringBoot整合Spring-Data-JPA-一/","link":"","permalink":"http://wangba.me/2020/09/10/SpringBoot%E6%95%B4%E5%90%88Spring-Data-JPA-%E4%B8%80/","excerpt":"","text":"一、OverView JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！ spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现 二、环境搭建pom.xml 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; application.properties 123456789101112spring.datasource.url=jdbc:mysql://localhost:3306/jpaspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.jpa.database=mysql# 是否在控制台打印 sql 语句spring.jpa.show-sql=true# 使用 InnoDB 作为引擎 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect# 每次启动都会更新数据库，如：增加字段等，但是对某个字段进行改造是识别不出来spring.jpa.hibernate.ddl-auto=update entiy Student 123456789101112131415161718@Entity@Table(name = &quot;student&quot;)public class Student &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;id&quot;, columnDefinition = &quot;INT UNSIGNED COMMENT &#x27;自增主键&#x27;&quot;) private Long id; @Column(name = &quot;name&quot;, columnDefinition = &quot;VARCHAR(50) NOT NULL COMMENT &#x27;用户名&#x27;&quot;) private String name; @Column(name = &quot;pwd&quot;, columnDefinition = &quot;VARCHAR(100) DEFAULT NULL COMMENT &#x27;密码&#x27;&quot;) private String pwd; // 省略 set get&#125; Grade 1234567891011121314151617@Entity@Table(name = &quot;grade&quot;)public class Grade &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;id&quot;, columnDefinition = &quot;INT UNSIGNED COMMENT &#x27;自增主键&#x27;&quot;) private Long id; @Column(name = &quot;subject&quot;, columnDefinition = &quot;VARCHAR(50) NOT NULL COMMENT &#x27;学科&#x27;&quot;) private String subject; @Column(name = &quot;score&quot;, columnDefinition = &quot;TINYINT UNSIGNED NOT NULL COMMENT &#x27;成绩&#x27;&quot;) private String score; // 省略 set get&#125; 注：这次使用两个表，为了后面进行复杂查询准备，这里的将两个表的自增 id 关联在一起，就不考虑多对多了 repository StudentRepository 123@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt;, JpaSpecificationExecutor&lt;Student&gt; &#123;&#125; GradeRepository 123@Repositorypublic interface GradeRepository extends JpaRepository&lt;Grade, Long&gt;, JpaSpecificationExecutor&lt;Grade&gt; &#123;&#125; 在上次 aop 那里面就提过，由于继承的有 CRUD 的 repository 和一些其他的，这也是上面提到的解放 DAO 层的操作，具体的可以看下图 三、CRUDcontroller GradeController 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/grade&quot;)public class GradeController &#123; private GradeRepository gradeRepository; @Autowired public void setGradeRepository(GradeRepository gradeRepository) &#123; this.gradeRepository = gradeRepository; &#125; @PutMapping(&quot;/add&quot;) public Grade add(@RequestBody Grade grade) &#123; return gradeRepository.save(grade); &#125; @GetMapping(&quot;/query&quot;) public List&lt;Grade&gt; query() &#123; return gradeRepository.findAll(); &#125; @PostMapping(&quot;/update&quot;) public Grade update(@RequestBody Grade grade) &#123; return gradeRepository.save(grade); &#125; @DeleteMapping(&quot;/delete&quot;) public void delete(@RequestParam Long id) &#123; gradeRepository.deleteById(id); &#125;&#125; StudentController 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/student&quot;)public class StudentController &#123; private StudentRepository studentRepository; @Autowired public void setStudentRepository(StudentRepository studentRepository) &#123; this.studentRepository = studentRepository; &#125; @PutMapping(&quot;/add&quot;) public Student add(@RequestBody Student student) &#123; return studentRepository.save(student); &#125; @GetMapping(&quot;/query&quot;) public List&lt;Student&gt; query() &#123; return studentRepository.findAll(); &#125; @PostMapping(&quot;/update&quot;) public Student update(@RequestBody Student student) &#123; return studentRepository.save(student); &#125; @DeleteMapping(&quot;/delete&quot;) public void delete(@RequestParam Long id) &#123; studentRepository.deleteById(id); &#125;&#125; 注： Spring 建议在这里的注入方式是 set 或者 构造注入，不要直接注解注入 为了方便，在这里还是省略了 Service 层的操作 Postman测试 增 查 改 删","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"}]},{"title":"SpringBoot整合MyBatis","slug":"SpringBoot整合MyBatis","date":"2020-09-09T07:52:44.000Z","updated":"2020-09-30T07:08:29.310Z","comments":true,"path":"2020/09/09/SpringBoot整合MyBatis/","link":"","permalink":"http://wangba.me/2020/09/09/SpringBoot%E6%95%B4%E5%90%88MyBatis/","excerpt":"","text":"一、OverView​ 在上篇文章中已经简单的写过 SpringBoot 整合 JDBCTemplate 了，但是现在的公司应该很少有用 JDBCTemplate，国内一般都是 MyBatis 或者是 Spring Data JPA，在本篇文章中就来整合一下 MyBatis。 二、环境搭建新建 SpringBoot 项目，选上 Web、MySQL，在 pom.xml 中配置一下数据库连接池： pom.xml: 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; application.properties: 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password= 三、CRUDUserMapper: 1234567891011121314151617181920212223242526272829@Component@Transactionalpublic interface UserMapper &#123; // 增 @Insert(&quot;insert into mybatis(name, password) values(#&#123;name&#125;, #&#123;password&#125;)&quot;) @SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = Long.class) Integer insert(User user); // 查 @Select(&quot;select * from mybatis&quot;) List&lt;User&gt; queryAllUser(); @Results(&#123; @Result(property = &quot;id&quot;, column = &quot;i&quot;), @Result(property = &quot;name&quot;, column = &quot;n&quot;), @Result(property = &quot;password&quot;, column = &quot;p&quot;) &#125;) @Select(&quot;select id as i, name as n, password as p from mybatis where id = #&#123;id&#125;&quot;) User queryById(Long id); // 改 @Update(&quot;update mybatis set name = #&#123;name&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;&quot;) Integer update(User user); // 删 @Delete(&quot;delete from mybatis where id = #&#123;id&#125;&quot;) Integer delete(Long id);&#125; 注： 如果不使用注解的方式，就要使用 xml 的方式，注意其中的资源解析问题： 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 增加 statement是要运行的SQL语句，它的返回值通过resultType来指定 before表示查询语句statement运行的时机 keyProperty表示查询结果赋值给代码中的哪个对象，keyColumn表示将查询结果赋值给数据库表中哪一列 keyProperty和keyColumn都不是必需的，有没有都可以 before=true，插入之前进行查询，可以将查询结果赋给keyProperty和keyColumn，赋给keyColumn相当于更改数据库 befaore=false，先插入，再查询，这时只能将结果赋给keyProperty 赋值给keyProperty用来“读”数据库，赋值给keyColumn用来写数据库 selectKey的两大作用：1、生成主键；2、获取刚刚插入数据的主键。 使用selectKey，并且使用MySQL的last_insert_id()函数时，before必为false，也就是说必须先插入然后执行last_insert_id()才能获得刚刚插入数据的ID。 参考链接：@SelectKey注解 查 @Results注解类似于XML中的ResultMap映射文件 UserController: 为了方便就不再写 Service 层了 123456789101112131415161718192021222324252627282930313233343536@RestControllerpublic class UserController &#123; private UserMapper userMapper; @Autowired public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @PutMapping(&quot;/insert&quot;) public Integer insert(@RequestBody User user) &#123; return userMapper.insert(user); &#125; @GetMapping(&quot;/query&quot;) public List&lt;User&gt; queryAllUser() &#123; return userMapper.queryAllUser(); &#125; @GetMapping(&quot;/query1&quot;) public User queryById(Long id) &#123; return userMapper.queryById(id); &#125; @PostMapping(&quot;/update&quot;) public Integer update(@RequestBody User user) &#123; return userMapper.update(user); &#125; @DeleteMapping(&quot;/delete&quot;) public Integer delete(Long id) &#123; return userMapper.delete(id); &#125;&#125; Postman 测试： 增加： 查询所有： 通过 id 查询： 更新： 查看一下数据库： 删除： 查看一下数据库： 使用注解进行动态查询具体可以参考：注解版动态查询 使用 xml 方式进行动态查询可以参考：xml 版动态查询","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"}]},{"title":"SpringBoot整合JDBCTemplate","slug":"SpringBoot整合JDBCTemplate","date":"2020-09-08T11:33:14.000Z","updated":"2020-09-30T07:08:27.205Z","comments":true,"path":"2020/09/08/SpringBoot整合JDBCTemplate/","link":"","permalink":"http://wangba.me/2020/09/08/SpringBoot%E6%95%B4%E5%90%88JDBCTemplate/","excerpt":"","text":"一、环境搭建1. 引入依赖1234567891011121314151617181920212223242526272829303132333435363738// WEB&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;// JDBC &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;// 使用 Swagger 进行接口测试&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;// mysql&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;// druid&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt; 2.数据库脚本1234567891011121314151617181920DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27;, `name` varchar(50) NOT NULL COMMENT &#x27;用户名&#x27;, `nick_name` varchar(150) DEFAULT NULL COMMENT &#x27;昵称&#x27;, `avatar` varchar(150) DEFAULT NULL COMMENT &#x27;头像&#x27;, `password` varchar(100) DEFAULT NULL COMMENT &#x27;密码&#x27;, `salt` varchar(40) DEFAULT NULL COMMENT &#x27;加密盐&#x27;, `email` varchar(100) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `mobile` varchar(100) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `status` tinyint(4) DEFAULT NULL COMMENT &#x27;状态 0：禁用 1：正常&#x27;, `dept_id` bigint(20) DEFAULT NULL COMMENT &#x27;机构ID&#x27;, `create_by` varchar(50) DEFAULT NULL COMMENT &#x27;创建人&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `last_update_by` varchar(50) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `last_update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除 -1：已删除 0：正常&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户管理&#x27;; application.properties: 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=****** 二、CRUD1.编写对应的实体类123456789101112131415161718192021222324252627282930313233public class SysUser &#123; private Long id; private String name; private String nickName; private String avatar; private String password; private String salt; private String email; private String mobile; private Byte status; private Long deptId; private String createBy; private Date createTime; private String lastUpdateBy; private Date lastUpdateTime; private Byte delFlag; // set 和 get 省略&#125; 2.编写对应的 CRUD Repository1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Repositorypublic class SysUserRepository &#123; @Autowired private JdbcTemplate jdbcTemplate; public Integer insert(SysUser user) &#123; String sql = &quot;insert into sys_user(id, name, password) values(?,?,?)&quot;; return jdbcTemplate.update(sql, user.getId(), user.getName(), user.getPassword()); &#125; public Integer insert1(SysUser sysUser) &#123; String sql = &quot;insert into sys_user(id, name, password) values(:id, :name, :password)&quot;; NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); return namedParameterJdbcTemplate.update(sql, new BeanPropertySqlParameterSource(sysUser)); &#125; // 推荐使用这种方式，可以不用传所有的参数 public Integer insert2(SysUser sysUser) &#123; String sql = &quot;insert into sys_user(id, name, password) values(:id, :name, :password)&quot;; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;id&quot;, sysUser.getId()); map.put(&quot;name&quot;, sysUser.getName()); map.put(&quot;password&quot;, sysUser.getPassword()); NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); return namedParameterJdbcTemplate.update(sql, map); &#125; public Integer update(SysUser sysUser) &#123; String sql = &quot;update sys_user set name = ?, password = ? where id = ?&quot;; Object[] args = &#123;sysUser.getName(), sysUser.getPassword(), sysUser.getId()&#125;; int[] argTypes = &#123;Types.VARCHAR, Types.VARCHAR, Types.BIGINT&#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125; public List&lt;Map&lt;String, Object&gt;&gt; queryAllListMap() &#123; String sql = &quot;select * from sys_user&quot;; return this.jdbcTemplate.queryForList(sql); &#125; // 这里要写一个 SysUserMapper 实现 RowMapper public SysUser queryById(Long id) &#123; String sql = &quot;select * from sys_user where id = ?&quot;; Object[] args = &#123;id&#125;; int[] argTypes = &#123;Types.BIGINT&#125;; List&lt;SysUser&gt; list = this.jdbcTemplate.query(sql, args, argTypes, new SysUserMapper()); if (StringUtils.isEmpty(list)) &#123; return list.get(0); &#125; else &#123; return null; &#125; &#125; public Integer deleteById(Long id) &#123; String sql = &quot;delete from sys_user where id = ?&quot;; Object[] args = &#123; id &#125;; int[] argTypes = &#123; Types.BIGINT &#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125;&#125; 3.对应的 Controller 层123456789101112131415161718192021222324252627282930313233343536373839404142434445@RestControllerpublic class SysUserController &#123; @Autowired private SysUserRepository sysUserRepository; @PutMapping(&quot;/insert&quot;) public Integer insert(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert(sysUser); return i; &#125; @PutMapping(&quot;/insert1&quot;) public Integer insert1(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert1(sysUser); return i; &#125; @PutMapping(&quot;/insert2&quot;) public Integer insert2(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.insert2(sysUser); return i; &#125; @PostMapping(&quot;/update&quot;) public Integer update(@RequestBody SysUser sysUser) &#123; int i = sysUserRepository.update(sysUser); return i; &#125; @GetMapping(&quot;/list&quot;) public List&lt;Map&lt;String, Object&gt;&gt; queryAllListMap() &#123; return sysUserRepository.queryAllListMap(); &#125; @GetMapping(&quot;/id1&quot;) public SysUser queryById(Long id) &#123; return sysUserRepository.queryById(id); &#125; @DeleteMapping(&quot;/id3&quot;) public Integer deleteById(Long id) &#123; return sysUserRepository.deleteById(id); &#125;&#125; 注：为了图方便，就不再此写 Service 层了 4.使用 Swagger 进行测试增加 第一种方式： 第二种方式： 第三种方式： 看一下数据库是否有三条数据： 修改 查找 查找所有： 删除","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"}]},{"title":"0076.Minimum Window Substring","slug":"0076-Minimum-Window-Substring","date":"2020-09-04T13:56:11.000Z","updated":"2020-09-30T07:09:40.885Z","comments":true,"path":"2020/09/04/0076-Minimum-Window-Substring/","link":"","permalink":"http://wangba.me/2020/09/04/0076-Minimum-Window-Substring/","excerpt":"","text":"76. 最小覆盖子串 Hard给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 12输入：S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;输出：&quot;BANC&quot; 提示： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 解题思路​ 这题在 0003 题中就已经提过了的暗号，就是洒洒水的使用一下 Sliding Window 就可以了，思路还是比较简单的：先不断的扩张窗口右边，直到将所有的要包含的短字符串；然后开始就移动窗口的左边，直到左边压缩到不能再容纳这个短字符串了，再进行不断比较，就可以得到最终结果了。​ 这种时候就需要出现 但是 这个词语，果然在实现的时候就需要注意很多问题了，对于这种抽象问题，先来个🌰：给的例子实在是太普通了，应该用那种带点特殊性的例子 S = “ABANCDB” T = “ABC” 对着代码捋一遍应该就懂了：第一遍过后可以看见：”ABANC” 是一个滑动窗口，map 的值也变为了： A B C 初始值 1 1 1 遍历到 A 0 1 1 遍历到 B 0 0 1 遍历到 A -1 0 1 遍历到 N -1 0 1 遍历到 C -1 0 0 此时的 count == t 的长度了，这样扩张窗口就完成了 ======&gt; min = 5 接下来就是收缩窗口，其根本原因就是这样左边出现重复元素，可以去掉形成最小的窗口： 如果在 map 中的值是等于 0 的，说明它是刚刚好的，如果把这个排除的话，这个窗口就不再成立了，要继续扩张 窗口了；如果 map 中的值 小于 0 的，说明它是多余的，但是要看它的位置了，可以看下🌰： “ABANC” 这个 A 就可以去掉；”BAANC” 这个 A 就不可以去掉，此时就要扩张窗口了 反复横跳 ，完成✅ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // 使用 hashmap 将 t 中的字符存入 for(int i = 0; i &lt; t.length(); i++) &#123; char c = t.charAt(i); if (map.containsKey(c)) &#123; int tmp = map.get(c); map.put(c, tmp + 1); &#125; else &#123; map.put(c, 1); &#125; &#125; // 用来判断这个窗口是否包含了 t int count = 0; // 一个窗口的左右 int left = 0, right = 0; int min = Integer.MAX_VALUE; // 长度最小的窗口的左右 int minLeft = 0, minRight = 0; for (; right &lt; s.length(); right++) &#123; char temp = s.charAt(right); if (map.containsKey(temp)) &#123; count = map.get(temp) &gt; 0 ? count + 1 : count; map.put(temp, map.get(temp) - 1); &#125; while (count == t.length()) &#123; if ((right - left) &lt; min) &#123; min = right - left; minLeft = left; minRight = right; &#125; char c = s.charAt(left); // 左边的重复字符可以不用 if (map.containsKey(c)) &#123; if (map.get(c) &gt;= 0) count--; map.put(c, map.get(c) + 1); &#125; left++; &#125; &#125; return min == Integer.MAX_VALUE ? &quot;&quot; : s.substring(minLeft, minRight + 1); &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"}]},{"title":"SpringBoot整合AOP","slug":"SpringBoot整合AOP","date":"2020-09-03T13:52:37.000Z","updated":"2020-09-30T07:08:24.891Z","comments":true,"path":"2020/09/03/SpringBoot整合AOP/","link":"","permalink":"http://wangba.me/2020/09/03/SpringBoot%E6%95%B4%E5%90%88AOP/","excerpt":"","text":"一、背景​ 在公司写业务的时候，都会有保存日志的操作，方便出错的时候进行排查；一般不仅仅在数据库中保存日志， 也会在后端控制台打印一些需要的信息。在这里，一般使用 AOP 织入的方式将日志保存在数据库中，使用一些日 志包将某些 Controller 层的信息打印在控制台。 二、准备Entiy:1234567891011121314151617181920@Entity@Table(name = &quot;log&quot;)@EntityListeners(AuditingEntityListener.class)public class Log implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY ) @Column(name = &quot;id&quot;) private Long id; @Column(name = &quot;title&quot;, columnDefinition = &quot;VARCHAR(100) COMMENT &#x27;标题&#x27;&quot;) private String title; @Column(name = &quot;author&quot;, columnDefinition = &quot;VARCHAR(255) COMMENT &#x27;作者&#x27;&quot;) private String author; @Column(name = &quot;content&quot;, columnDefinition = &quot;TEXT COMMENT &#x27;内容&#x27;&quot;) private String content; // get 和 set 省略 注: 这里是使用 Spring Data JPA 自动生成的数据库对应实体，导入相关依赖后，可以先运行一遍，看数据库 是否生成对应实体；然后自行在数据库中插入几条数据。 Repository:123public interface LogRepository extends JpaRepository&lt;Log, Long&gt; &#123;&#125; 注: 这里只要继承 JpaRepository ，这个 repository 也继承了别的 repository（里面有一些常见的方法可以 调用） Service:1234567891011@Servicepublic class LogService &#123; @Autowired LogRepository logRepository; public List&lt;Log&gt; getAllLog() &#123; List&lt;Log&gt; logs = logRepository.findAll(); return logs; &#125;&#125; 注: 这里就不写接口，再去实现了 Controller:123456789101112@RestControllerpublic class LogController &#123; @Autowired LogService logService; @GetMapping(&quot;/list&quot;) public List&lt;Log&gt; getAll() &#123; List&lt;Log&gt; logs = logService.getAllLog(); return logs; &#125;&#125; 再使用 Postman 等工具进行一次测试就行 三、使用注解的方式进行 AOP首先定义一个方法级别的 @Log 注解，用于标注需要监控的方法： 1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123; String value() default &quot;&quot;; &#125; 定义一个LogAspect类，使用 @Aspect 标注让其成为一个切面，切点为使用 @Log 注解标注的方法： 1234567891011121314151617181920@Aspect@Componentpublic class LogAspec &#123; private final static Logger logger = LoggerFactory.getLogger(LogAspec.class); @Pointcut(&quot;@annotation(org.wangba.springboot013aop.antoation.Log)&quot;) public void pointcut() &#123; &#125; @Before(&quot;pointcut()&quot;) public void doBefore(JoinPoint joinPoint) throws Throwable &#123; logger.info(&quot;Start Time: &#123;&#125;&quot;, System.currentTimeMillis()); &#125; @After(&quot;pointcut()&quot;) public void doAfter() throws Throwable &#123; logger.info(&quot;End Time: &#123;&#125;&quot;, System.currentTimeMillis()); &#125;&#125; 再在 Controller 层的方法上加上 @Log 注解： 12345678910111213@RestControllerpublic class LogController &#123; @Autowired LogService logService; @Log(&quot;获得所有文章&quot;) @GetMapping(&quot;/list&quot;) public List&lt;Article&gt; getAll() &#123; List&lt;Article&gt; articles = logService.getAllLog(); return articles; &#125;&#125; 此时再在 Postman 中测试一次，你就可以看到控制台会打印如下结果： 在公司业务中，我们一般都是在 @Before 进行一些请求信息等， @After 在控制台打印一些信息，并将结 果直接存到数据库中的日志表中。","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中类型转换","slug":"SpringBoot中类型转换","date":"2020-09-02T12:55:09.000Z","updated":"2020-09-30T07:08:22.269Z","comments":true,"path":"2020/09/02/SpringBoot中类型转换/","link":"","permalink":"http://wangba.me/2020/09/02/SpringBoot%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"一、问题如果前端传来一个日期参数，是用 String 类型的，我们如何在后端进行传参呢？ 也即如下这种情况： 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public void hello(Date date) &#123; System.out.println(date); &#125;&#125; 浏览器输入：http://localhost:8080/hello?date=2020-01-01 可以在后台看到 WARN ： Failed to convert value of type ‘java.lang.String’ to required type ‘java.util.Date’ 二、解决1234567891011121314151617@Componentpublic class StringTransDate implements Converter&lt;String, Date&gt; &#123; private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); @Override public Date convert(String s) &#123; if (s != null &amp;&amp; !&quot;&quot;.equals(s)) &#123; try &#123; return simpleDateFormat.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125;&#125; 注：要将该类使用 @Component 注入","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"0003.Longest Substring Without Repeating Characters","slug":"0003-Longest-Substring-Without-Repeating-Characters","date":"2020-09-01T13:26:29.000Z","updated":"2020-09-30T07:09:37.081Z","comments":true,"path":"2020/09/01/0003-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"http://wangba.me/2020/09/01/0003-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"0003. 无重复字符的最长子串 Medium给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 12345输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路 🐷：第一个想法就是这个是不是和 KMP 算法有那么一点点像的 力扣：让你见识一下，值得我们官网有一个标签的思想 ———&gt; Sliding Window 🐷：说人话 力扣：就是 滑动窗口 大法，你后面会看到很多次这种思想，想继续看这样的题，点这里，还有一些暗号：76、 438、567 滑动窗口思想： 滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。 🐷：应该就是双指针的变形版了…….. 代码12345678910111213class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0, j = 0; i &lt; s.length(); i++) &#123; if (map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i)) + 1); map.put(s.charAt(i), i); max = Math.max(max, i - j + 1); &#125; return max; &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"},{"name":"Two pointer","slug":"Two-pointer","permalink":"http://wangba.me/tags/Two-pointer/"}]},{"title":"SpringBoot中的路径映射","slug":"SpringBoot中的路径映射","date":"2020-09-01T13:25:29.000Z","updated":"2020-09-30T07:08:15.292Z","comments":true,"path":"2020/09/01/SpringBoot中的路径映射/","link":"","permalink":"http://wangba.me/2020/09/01/SpringBoot%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84/","excerpt":"","text":"一、在 SpringBoot中使用 SSM 框架中的映射写下如下的 Controller： 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125;&#125; 并在 resources/templates 中新建 hello.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, Spring Boot&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 注：在 SpringBoot 中，默认的静态资源是放在以下几个位置： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ / 其中第 5 个表示 webapp 目录中的静态资源也不被拦截 所以在这里这不是一个静态资源，我们以前的做法就是直接返回这个页面，没写上面的 Controller 直接使用 http://localhost:8080/hello 是访问不到该页面的 二、在 SpringBoot 中进行路径映射只需要进行如下配置就可以进行路径映射 12345678@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;wangba&quot;).setViewName(&quot;hello&quot;); &#125;&#125; 再次访问：http://localhost:8080/wangba 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"0001.Two Sum","slug":"0001-Two-Sum","date":"2020-08-31T13:26:10.000Z","updated":"2020-09-30T07:08:03.901Z","comments":true,"path":"2020/08/31/0001-Two-Sum/","link":"","permalink":"http://wangba.me/2020/08/31/0001-Two-Sum/","excerpt":"","text":"0001. 两数之和 Easy给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 解题思路 傻瓜式想法：遍历两次，求和（去除重复的元素，位置不同的相等元素可以进行计算） 力扣内心OS：你这样的时间复杂度能过算我输！！！ 😯：就这，略施小计：空间换时间之术 首先，遍历一遍数组将数组的值放入 Map 中，然后再遍历一次，将 target - 取到的值，但是要注意不能仅仅判断是 否存在这个值，因为可能会出现下面这种情况：target = 4，该数组中就只有一个 2，这样就会出错。所以还要判断 取到的值还不能是第一次的元素。 代码：123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; hashMap.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int temp = target - nums[i]; if (hashMap.containsKey(temp) &amp;&amp; hashMap.get(temp) != i) &#123; res[0] = hashMap.get(temp); res[1] = i; break; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"}]},{"title":"SpringBoot中的Servlet、Filter、Listener","slug":"SpringBoot中的Servlet、Filter、Listener","date":"2020-08-31T12:08:27.000Z","updated":"2020-09-30T07:07:21.821Z","comments":true,"path":"2020/08/31/SpringBoot中的Servlet、Filter、Listener/","link":"","permalink":"http://wangba.me/2020/08/31/SpringBoot%E4%B8%AD%E7%9A%84Servlet%E3%80%81Filter%E3%80%81Listener/","excerpt":"","text":"一、Servlet12345678@WebServlet(urlPatterns = &quot;/MyServlet&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;MyServlet&quot;); &#125;&#125; @WebServlet(urlPatterns = “/MyServlet”)：指定Servlet指定的 URL 二、Filter12345678910111213141516171819@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;MyFilter&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; @WebFilter(“/*”)：指定路径进行过滤 三、Listener123456789101112@WebListenerpublic class MyListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(&quot;requestInitialized.............&quot;); &#125; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(&quot;requestDestroyed................&quot;); &#125;&#125; @WebListener：标注为监听器 可以自行测试修改路由路径等进行测试 四、区别启动结果：http://localhost:8080/MyServlet 配合官方图解释一下： 首先是 Listener ==&gt; Filter ==&gt; Servlet 下面还有一次： 12MyFilterrequestDestroyed................ 再浏览器打开控制台，强制刷新一下：macOS(快捷键：command + shift + R)，可以看到： 最下面的那个是我的浏览器扩展加载的脚本","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中定义系统启动任务","slug":"SpringBoot中定义系统启动任务","date":"2020-08-22T11:26:24.000Z","updated":"2020-09-30T07:07:19.950Z","comments":true,"path":"2020/08/22/SpringBoot中定义系统启动任务/","link":"","permalink":"http://wangba.me/2020/08/22/SpringBoot%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"一、CommandLineRunner通过实现 CommandLineRunner 来定义启动任务： 12345678@Component@Order(1)public class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;Order(1):&quot; + Arrays.toString(args)); &#125;&#125; 12345678@Component@Order(2)public class MyCommandLineRunner01 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;Order(2):&quot; + Arrays.toString(args)); &#125;&#125; 其中： @Order 注解为优先级，数值越小，优先级越高； args 为启动类中的 String[] args； args 参数可以在配置里面的 Program argumens 进行配置，也可以打成 jar 包的时候，使用命令进行设置 最终结果如下： 可以看到 Order(1) 的优先级高于 Order(2) 二、ApplicationRunner通过实现 ApplicationRunner 来定义启动任务： 1234567891011121314151617181920@Component@Order(3)public class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;Order3:&quot;); String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArg:&quot; + Arrays.toString(sourceArgs)); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs:&quot; + nonOptionArgs); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) &#123; System.out.println(optionName + args.getOptionValues(optionName)); &#125; &#125;&#125; 123456789101112131415161718192021@Component@Order(4)public class MyApplicationRunner01 implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;Order4&quot;); String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArg:&quot; + Arrays.toString(sourceArgs)); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs:&quot; + nonOptionArgs); System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) &#123; System.out.println(optionName + args.getOptionValues(optionName)); &#125; System.out.println(&quot;🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰🌰&quot;); &#125;&#125; args.getNonOptionArgs()：可以用来获取命令行中的无key参数； args.getOptionNames()：可以用来获取所有key/value形式的参数的key； args.getOptionValues(key))：可以根据key获取key/value 形式的参数的value； args.getSourceArgs();：则表示获取命令行中的所有参数。 参数配置： 最终结果： 注：CommandLineRunner 和 ApplicationRunner 是可以一起用的，优先级还是通过 @Order 进行排序 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot整合过滤器和拦截器","slug":"SpringBoot整合过滤器和拦截器","date":"2020-08-20T12:32:06.000Z","updated":"2020-09-30T07:07:15.616Z","comments":true,"path":"2020/08/20/SpringBoot整合过滤器和拦截器/","link":"","permalink":"http://wangba.me/2020/08/20/SpringBoot%E6%95%B4%E5%90%88%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"一、过滤器新建如下的 Controller： 123456789@RestControllerpublic class UserController &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) public void get(@PathVariable String id) &#123; System.out.println(id); &#125;&#125; 过滤器的实现：定义一个类实现 Filter ，并重写其中的方法 123456789101112131415161718192021222324@Component@WebFilter(urlPatterns = &quot;/*&quot;)public class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;Initialization&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;++++++++ Start ++++++++&quot;); Long start = new Date().getTime(); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;Filter costs: &quot;); System.out.println(new Date().getTime() - start); System.out.println(&quot;++++++++ End ++++++++&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;Filter is over&quot;); &#125;&#125; init 方法：是对项目启动时，进行的初始化 doFilter 方法：当执行一个请求的时候，进行过滤 destroy 方法：当这个项目关闭时，该过滤器也被销毁了 浏览器运行：http://localhost:8080/user/666 结果： 在这个过程中出现了一点问题： 当我们进行下面这种过滤一部分的情况下： TimeFilter 12345678910111213141516171819202122232425@Component@WebFilter(urlPatterns = &#123;&quot;/user/*&quot;&#125;)public class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(filterConfig.getServletContext().getContextPath()); System.out.println(&quot;Initialization........&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;++++++++ Start ++++++++&quot;); Long start = new Date().getTime(); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;Filter costs: &quot;); System.out.println(new Date().getTime() - start); System.out.println(&quot;++++++++ End ++++++++&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;Filter is over&quot;); &#125;&#125; UserController 123456789@RestControllerpublic class UserController &#123; @GetMapping(&quot;user/&#123;id&#125;&quot;) public void get(@PathVariable String id) &#123; System.out.println(&quot;userID：&quot; +id); &#125;&#125; HelloController 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125;&#125; 此时我们过滤的是 /user 后面所有的请求，但是结果是 UserController 和 HelloController 都进入了过滤器中： 最终解决方案：去掉在 TimeFilter 中的 @Component 注解，在启动类上加上 @ServletComponentScan 注解即可： 在上面我们使用了注解的方式进行过滤： @WebFilter(urlPatterns = “/*”) 第二种方式： 去掉 @Component 和 *@WebFilter(urlPatterns = {“/user/“})** 注解，并配置如下的配置类： 123456789101112131415@Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); TimeFilter timeFilter = new TimeFilter(); filterRegistrationBean.setFilter(timeFilter); List&lt;String&gt; urlList = new ArrayList&lt;&gt;(); urlList.add(&quot;/user/*&quot;); filterRegistrationBean.setUrlPatterns(urlList); return filterRegistrationBean; &#125;&#125; 二、拦截器编写一个拦截器类实现 HandlerInterceptor ，如下： 12345678910111213141516171819202122232425public class TimeInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;处理拦截之前&quot;); request.setAttribute(&quot;startTime&quot;, new Date().getTime()); System.out.println(((HandlerMethod) handler).getBean().getClass().getName()); System.out.println(((HandlerMethod) handler).getMethod().getName()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;开始处理拦截&quot;); Long start = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;【拦截器】耗时 &quot; + (new Date().getTime() - start)); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;处理拦截之后&quot;); Long start = (Long) request.getAttribute(&quot;startTime&quot;); System.out.println(&quot;【拦截器】耗时 &quot; + (new Date().getTime() - start)); System.out.println(&quot;异常信息 &quot; + ex); &#125;&#125; preHandle 方法在处理拦截之前执行 postHandle 方法只有当被拦截的方法没有抛出异常成功时才会处理 afterCompletion 方法无论被拦截的方法抛出异常与否都会执行 将我们写好的拦截器注册到容器中： 123456789101112@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor).addPathPatterns(&quot;/user/*&quot;); &#125;&#125; 同样分别运行：http://localhost:8080/user/888 和 http://localhost:8080/hello 可以看见结果如下： 只是对 user/888 进行拦截了，对 hello 没有进行拦截 三、过滤器与拦截器的对比我们再将前面的过滤器加入其中，可以得到如下结果： 有一张已经整理好执行顺序图：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中跨域问题","slug":"SpringBoot中跨域问题","date":"2020-08-20T10:16:59.000Z","updated":"2020-09-30T07:07:17.590Z","comments":true,"path":"2020/08/20/SpringBoot中跨域问题/","link":"","permalink":"http://wangba.me/2020/08/20/SpringBoot%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、同源策略​ 同源策略是由 Netscape 提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是 JSONP，JSONP 虽然能解决跨域但是有一个很大的局限性，那就是只支持 GET 请求，不支持其他类型的请求，而 CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个 W3C 标准，它是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是 JSONP 模式的现代版。在 Spring 框架中，对于 CORS 也提供了相应的解决方案， SpringBoot 中如何实现 CORS。 二、如何出现启动两个 SpringBoot 项目，分别以 8080 和 8081 端口启动，在其中一个写上如下的 Controller： 1234567891011121314@RestControllerpublic class HelloController &#123; @PostMapping(&quot;/hello&quot;) public String hello1() &#123; return &quot;get hello&quot;; &#125; @GetMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;post hello&quot;; &#125;&#125; 在另一个中写入一个静态页面： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; value=&quot;get_button&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick2()&quot; value=&quot;post_button&quot;&gt;&lt;script&gt; function btnClick() &#123; $.get(&#x27;http://localhost:8080/hello&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125; function btnClick2() &#123; $.post(&#x27;http://localhost:8080/hello&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：记得引入 Jquery 在 http://localhost:8081/hello.html 点击任何请求： 可以看到此时已经发生跨域问题 三、解决方案从后端解决，修改 Controller 为： 12345678910111213141516@RestControllerpublic class HelloController &#123; @CrossOrigin(origins = &quot;http://localhost:8081&quot;) @PostMapping(&quot;/hello&quot;) public String hello1() &#123; return &quot;post hello&quot;; &#125; @CrossOrigin(value = &quot;http://localhost:8081&quot;) @GetMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;get hello&quot;; &#125;&#125; 其中 origins 与 value 效果一样，看源码可以知道它们互相成为对方的别名 此时已经不会出现跨域问题 四、加强版解决此时，在每一个类或者方法上都使用这个注解，法外狂徒张三都觉得这个太麻烦了 只需要配置一个实现 WebMvcConfigurer 配置类，如下： 12345678public class CORSConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) .allowedHeaders(&quot;*&quot;); &#125;&#125; 注：/** 表示本应用的所有方法都会去处理跨域请求；allowedMethods 表示允许通过的请求数；allowedHeaders 则表示允许的请求头。 五、安全问题出现了一个王八老本行的问题：通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。 一句话：利用我们还在登录的状态，即 Cookie 有效，打开一个正常网站，而这个网站上可能有一个非正常操作 ( 图片，链接等) ，那你就可能已经被攻击。 在信息安全中，我们防御 CSRF 的方法主要是增加 Token，这也是现在大多数防御 CSRF 的方式。","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot中自定义异常","slug":"SpringBoot中自定义异常","date":"2020-08-19T09:11:17.000Z","updated":"2020-09-30T07:07:13.559Z","comments":true,"path":"2020/08/19/SpringBoot中自定义异常/","link":"","permalink":"http://wangba.me/2020/08/19/SpringBoot%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/","excerpt":"","text":"一、正常出现异常Controller： 12345678910@RestControllerpublic class ErrorController &#123; @GetMapping(&quot;/diyError&quot;) public String error() &#123; int i = 2 / 0; return &quot;diyError&quot;; &#125; &#125; 结果： 可以看见此错误页是 SpringBoot 提供的，由于我们没有提供 /error 页面，顺便展示我们出现的错误 二、静态页面异常在 static 目录下新建一个 error 目录，并在其中新建 404.html 和 500.html： 404.html: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 500.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;500&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 再次访问 http://localhost:8080/diyError 可以看见已经进入自定义的静态页面了： 再访问一个不存在的页面： 注：也可以只定义 4xx.html 与 5xx.html 的静态页面，只要发生 400-499 的状态码或者 500-599 的状态码就对应 4xx.html 与 5xx.html 的结果 三、动态页面异常引入 thymeleaf 的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在 templates 目录下新建一个 error 目录，并在其中新建 404.html、 500.html、 4xx.html、5xx.html ： 再次访问 http://localhost:8080/diyError 可以看见已经进入自定义的动态页面了： 优先级： 如果有 404 的页面，会先找 404.html；如果没有就会找 4xx.html 如果动态页面和静态页面同时存在，会优先使用动态页面 完整顺序大概如下： 发生了500错误 –&gt; 查找动态 500.html 页面 –&gt; 查找静态 500.html –&gt; 查找动态 5xx.html –&gt; 查找静态 5xx.html 四、SpringBoot 怎么自动配置关键类：ErrorMvcAutoConfiguration 12345678910111213141516171819202122@Configuration(proxyBeanMethods = false)static class DefaultErrorViewResolverConfiguration &#123; private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) &#123; this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; &#125; @Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean(ErrorViewResolver.class) // 默认的错误视图解析器 DefaultErrorViewResolver DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); &#125;&#125; 在默认的错误视图解析器 DefaultErrorViewResolver 中： 12345678@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125; 如果 modelAndView 为空，即没找到对应的具体 404.html，就会用 SERIES_VIEWS.containsKey(status.series()) 找 4xx.html 123456789private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; String errorViewName = &quot;error/&quot; + viewName; TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; return resolveResource(errorViewName, model);&#125; 判断 error 文件夹下面是否有对应的状态码的文档 再判断是否有动态页面，即 TemplateAvailabilityProvider 如果是动态页面，就返回动态页面；否则返回静态页面 1234567891011121314private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; for (String location : this.resourceProperties.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + &quot;.html&quot;); if (resource.exists()) &#123; return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; return null;&#125; 五、自定义异常数据在 ErrorMvcAutoConfiguration 中，处理异常数据的方法： 12345@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes();&#125; 在 DefaultErrorAttributes() 中通过设置参数得到相应的结果 例如：将 error 中的 5xx.html 改为： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;5xx&lt;/h1&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;trace&lt;/td&gt; &lt;td th:text=&quot;$&#123;trace&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 此时仔运行结果： 再看一下使 DefaultErrorAttributes 生效的条件： @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) 所以只要我们自定义 ErrorAttributes.class 就可以实现自己定义的异常数据处理 自定义 ErrorAttributes 有两种方式 ： 直接实现 ErrorAttributes 接口 继承 DefaultErrorAttributes（推荐），因为 DefaultErrorAttributes 中对异常数据的处理已经完成，开发者可以直接使用。 新建一个配置类继承 DefaultErrorAttributes 12345678910@Componentpublic class MyErrorConfig extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, options); errorAttributes.put(&quot;myerror&quot;, &quot;自定义异常&quot;); return errorAttributes; &#125;&#125; 在 5xx.html 中加入： 1234&lt;tr&gt; &lt;td&gt;myerror&lt;/td&gt; &lt;td th:text=&quot;$&#123;myerror&#125;&quot;&gt;&lt;/td&gt;&lt;/tr&gt; 运行结果：可以看到此时的自定义的 error 已经加入","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"SpringBoot整合JSON","slug":"SpringBoot整合JSON","date":"2020-08-18T13:01:28.000Z","updated":"2020-09-30T07:07:11.653Z","comments":true,"path":"2020/08/18/SpringBoot整合JSON/","link":"","permalink":"http://wangba.me/2020/08/18/SpringBoot%E6%95%B4%E5%90%88JSON/","excerpt":"","text":"一、Jackson1. 环境搭建只要加入普通的 Web 依赖就行，为了方便依然引入 Lombok 和 热部署 打开 Maven 依赖可以看见 SpringBoot 自带的就是 jackson 2. SpringBoot中使用2.1 建立实体类： 12345678@Datapublic class User &#123; private Integer id; private String name; private String address; private Date date;&#125; 2.2 Controller层： 1234567891011121314151617@RestControllerpublic class UserController &#123; @GetMapping(&quot;/user&quot;) public List&lt;User&gt; getUser() &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setId(i); user.setName(&quot;wang&quot; + i); user.setAddress(&quot;shanghai&quot; + i); user.setDate(new Date()); users.add(user); &#125; return users; &#125;&#125; 2.3 结果： 3. 深入了解 Springboot 中的 JSON 转换思考： 前端传入的 json 数据如何被解析成 Java 对象作为 API入参 API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端 关键类：HttpMessageConverter 官方原话： 1Strategy interface that specifies a converter that can convert from and to HTTP requests and responses. 从 Structure 中可以看见一共有五个方法： canRead：接收到请求时判断是否能读 canWrite：返回结果时判断是否能写 getSupportedMediaTypes：获取支持的 MediaType read：能读则读 write：能写则写 注：在前面我们没有写任何配置也能实现转换，是由于其中有缺省配置 可以在 WebMvcConfigurationSupport 中查看 4.自定义 JSON 配置方式一：在需要转换的属性上加上注解 12345678910@Datapublic class User &#123; private Integer id; private String name; private String address; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private Date date;&#125; 结果： 方式二： 配置类： 1234567891011121314@Configurationpublic class JsonConfig &#123; @Bean MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123; MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd-HH:mm:ss&quot;)); converter.setObjectMapper(objectMapper); return converter; &#125;&#125; 结果： 使用下面的配置类也可以： 123456789101112131415161718192021@Configurationpublic class JsonConfig &#123;// @Bean// MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter () &#123;//// MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();// ObjectMapper objectMapper = new ObjectMapper();// objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd-HH:mm:ss&quot;));// converter.setObjectMapper(objectMapper);// return converter;// &#125; @Bean ObjectMapper objectMapper() &#123; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)); return objectMapper; &#125;&#125; 结果： 5.Gson 和 Fastjson如果想要和 Jackson 一样自定义配置： 只需要配置：GsonHttpMessageConverter 和 FastJsonHttpMessageConverter","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"JSON","slug":"JSON","permalink":"http://wangba.me/tags/JSON/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"}]},{"title":"ControllerAdvice注解的使用","slug":"ControllerAdvice注解的使用","date":"2020-08-18T13:00:09.000Z","updated":"2020-09-30T07:07:09.383Z","comments":true,"path":"2020/08/18/ControllerAdvice注解的使用/","link":"","permalink":"http://wangba.me/2020/08/18/ControllerAdvice%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、用法 处理全局异常 预设全局数据 请求参数预处理 二、处理全局异常我们只需要在 application.properties中配置：spring.servlet.multipart.max-file-size=1KB 就可以看见在上传图片时就会报 500 异常： 此时我们可以自己自定义处理 这种异常： 12345678910111213@ControllerAdvicepublic class MyException &#123; @ExceptionHandler(MaxUploadSizeExceededException.class) public void myException(MaxUploadSizeExceededException e, HttpServletResponse response) throws IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter writer = response.getWriter(); writer.write(&quot;上传大小限制为1KB&quot;); writer.flush(); writer.close(); &#125;&#125; 三、预设全局数据设置全局变量： 1234567891011@ControllerAdvicepublic class GlobalData &#123; @ModelAttribute(value = &quot;data&quot;) public Map&lt;String, Object&gt; map() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;wangyi&quot;, &quot;王一&quot;); map.put(&quot;wangba&quot;, &quot;王八&quot;); return map; &#125;&#125; 取出设置的值： 12345678910111213@RestControllerpublic class HelloController &#123; @GetMapping(&quot;hello&quot;) public String hello(Model model) &#123; Map&lt;String, Object&gt; map = model.asMap(); Set&lt;String&gt; set = map.keySet(); for (String s : set) &#123; System.out.println(s + &quot;:&quot; + map.get(s)); &#125; return &quot;hello&quot;; &#125;&#125; 结果： 四、请求参数预处理实体类： 123456@Datapublic class Book &#123; private String name; private double price;&#125; 1234567@Datapublic class Author &#123; private String name; private int age;&#125; Controller: 12345678910@RestControllerpublic class BookController &#123; @PostMapping(&quot;/book&quot;) public void book(Book book, Author author) &#123; System.out.println(book); System.out.println(author); &#125;&#125; 使用 Postman 进行测试： 得到最终结果为： 当出现相同参数时，并不能分清楚参数属于哪个对象，只能将参数赋值给每一个拥有相同参数的对象 处理： Controller： 1234567891011@RestControllerpublic class BookController &#123; @PostMapping(&quot;/book&quot;) public void book(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) &#123; System.out.println(book); System.out.println(author); &#125;&#125; 参数配置： 12345678910111213@ControllerAdvicepublic class GlobalData &#123; @InitBinder(&quot;a&quot;) public void initA(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;a.&quot;); &#125; @InitBinder(&quot;b&quot;) public void initB(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix(&quot;b.&quot;); &#125;&#125; 使用 Postman 进行测试： 结果：","categories":[{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"注解","slug":"注解","permalink":"http://wangba.me/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"ElasticSearch入门","slug":"ElasticSearch入门","date":"2020-08-12T07:02:23.000Z","updated":"2020-08-12T07:40:52.851Z","comments":true,"path":"2020/08/12/ElasticSearch入门/","link":"","permalink":"http://wangba.me/2020/08/12/ElasticSearch%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、参考链接01.ES官网 02.Spring Boot Elasticsearch 入门 03.图解 Elasticsearch 原理 二、ElasticSearch概述三、Solr和ElasticSearch的对比四、ElasticSearch安装五、Kibana安装5.1 下载 Kibana官方下载地址 注：可以在past releases下载老版本 5.2 运行解压后进入bin目录运行： 1./kibana 在浏览器打开： http://localhost:5601/ 5.3 汉化 zh-CN.json是Kibana的汉化包 再到 kibana.yml 中加入： 六、ElasticSearch核心概念6.1 与关系型数据库对比 elasticsearch是面向文档，关系型数据库和 elasticsearch 客观的对比！一切都是JSON MySQL ElasticSearch 数据库（database） 索引（index） 表（tables） 类型（types） ES 文档（documents） 列（columns） 字段（fields） 注：其中 types 逐渐被弃用了，8.X将被删除 6.2 一个🌰： 对应上面数据库： 6.3 设计elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多个文档(行)，每个文档中又包含多个字段(列)。 物理设计： elasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移 一个人就是一个集群！默认的集群名称就是 elaticsearh 参考以下： 云上的集群 集群里的盒子 节点之间 索引里的小方块 在 ElasticSearch head 中可以看见默认集群的名字为：elasticsearch 逻辑设计： 一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的顺序找到它: 索引 ----&gt; 类型 ----&gt; 文档ID 通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串。 6.4 文档就是我们的一条数据 之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个重要属性 : 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key：value！ 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！就是一个json对象！ 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用， 在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。 尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型 。 6.5 类型​ 类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射， 比如 name 映射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段， 比如新增一个字段，那么elasticsearch是怎么做的呢？elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整型。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。 6.6 索引就是数据库 索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。 一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 ) 在 ElasticSearch head 中可以看见刚建立的索引是5个分片： 6.7 倒排elasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例 如，现在有两个文档， 每个文档包含如下内容： Study every day, good good up to forever # 文档1包含的内容To forever, study every day, good good up # 文档2包含的内容 为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档 term doc_1 doc_2 Study √ X To X √ every √ √ forever √ √ day √ √ study X √ good √ √ every √ √ to √ X up √ √ 现在，我们试图搜索 to forever，只需要查看包含每个词条的文档 score term doc_1 doc_2 to √ X forever √ √ total 2 1 如果没有别的条件，现在，这两个包含关键字的文档都将返回。 在elasticsearch中， 索引 （库）这个词被频繁使用，这就是术语的使用。 在elasticsearch中，索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢! 如无特指，说起索引都是指elasticsearch 的索引。 关系图： 一个 ES 索引 —–&gt; 多个分片(shard) ​ 一个分片(shard) —–&gt; 一个 Lucene 索引 一个 ES 索引 —–&gt; —–&gt; 多个 Lucene 索引 七、IK分词器7.1 分词分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个 词，比如 “我是王八” 会被分为”我”、“是”、“王”、“八”，这显然是不符合要求的，所以我们需要安装中文分词器 IK 来解决这个问题。 IK 提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！ 7.2 下载安装下载地址：IK 分词器下载 安装：解压后放入 plugins 文件夹下 重启 ElasticSearch ：看到 IK 分词器已经加载到 ES 里面了 7.3 IK 分词器的小🌰：使用 ik_smart 算法： 最少切分 使用 ik_max_word 算法： 最细粒度划分：通过字典，找寻所有符合的情况 7.4 自行 DIY 字典在出现以下情况时：我们需要的是 神魔恋 应该是一个词语，而不应该被分词为 神魔 与 恋 在 IK 的 config 目录下，配置 wangba.dic 和 IKAnalyzer.cfg.xml 如下： IKAnalyzer.cfg.xml： wangba.dic: 重启 ES 和 Kibana：已经可以看见 wangba.dic 已经加载进去了 此时在Kibana中可以看见：此时 神魔恋 已经是一个词了 八、Rest风格8.1 Rest命令说明说明一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交 互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 基本Rest命令说明： method url地址 描述 PUT localhost:9200/索引名称/类型名称/文档id 创建文档（指定文档id） POST localhost:9200/索引名称/类型名称 创建文档（随机文档id） _update localhost:9200/索引名称/类型名称/文档id/_update 修改文档 DELETE localhost:9200/索引名称/类型名称/文档id 删除文档 GET localhost:9200/索引名称/类型名称/文档id 查询文档通过文档id POST localhost:9200/索引名称/类型名称/_search 查询所有数据 8.2 基本测试创建索引： PUT /索引名称/类型名称/文档id { ​ 请求体 } 注：类型即将被弃用 在 ES head 中可以看见数据已经插入成功： 8.3 类型 字符串类型 text 、 keyword 数值类型 long、integer、 short、byte、double、float、half_float、 scaled_float 日期类型 date 布尔值类型 boolean 二进制类型 binary 自定义类型： 通过 GET 请求可以看见 test2 索引的信息： 自动匹配类型： 8.4 关于索引的基本操作 增加：如上 查询：如上 修改：如下 方法一：直接覆盖 可以看见 version 发生了改变 方法二： POST /索引名称/_doc/文档id/__update { ​ 请求体 } 可以看见 version 再次发生了改变 删除 8.5 关于文档的基本操作基本操作： 增加数据 PUT 查询数据 GET 方式一：简单的 ID 查询 可以看见，推荐使用 GET /索引/_doc/文档ID 来进行操作 方式二：简单的条件查询 可以看见 type 已经被丢弃了 更新数据 POST 可以看见，推荐使用 POST /索引/_update/文档ID 来进行操作 复杂操作：select (排序、分页、高亮、模糊查询、精准查询 ) 查询 ES 中有 zhangsan 和 zhangshan 008 ，通过关键字zhangsan 查询，会将分词后的结果全部查询出来，且每一个都是有 _score 的。 hits：在Java可以得到索引和文档的信息、查询的结果总数、具体文档数据信息（可以通过遍历得到具体的各种信息） 通过 _source 来指定最后的输出结果 排序 通过 sort 进行排序，用 desc 和 asc 来进行降序和升序 分页 /search/{current}/{pagesize} 第一页一个数据 第二页的一个数据 第一页的两个数据 bool 值查询 must 命令 == and should 命令 == or 两个都查询到了 must_not 命令 == not filter 命令 gt：大于 / gte：大于等于 / lt：小于 / lte：小于等于 匹配多个条件 直接在 tags 中加空格 精确查询 term 查询是直接通过倒排索引指定的词条进行精确的查询 term：直接查询精确的 match：使用分词器解析（先分析文档，在通过分析的文档进行查询） 两个类型： text： 会被分词解析器解析 keyword： 不会被分词解析器解析 使用 keywod 分词器： 使用 standard 分词器： text： 可以看见下面被分词了，所以出现了两个结果 keyword： 可以看见下面没有被分词 高亮查询 九、SpringBoot集成ElasticSearch官方 ES Client 文档 1.依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt;&lt;/dependency&gt; 2.找对象 3.分析类中方法 ES 的版本与本机中的版本不一致 自行配置 SpringBoot 中的 ES 版本 RestClientAutoConfiguration 和 RestClientProperties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.boot.autoconfigure.elasticsearch.rest;import java.time.Duration;import org.apache.http.HttpHost;import org.apache.http.auth.AuthScope;import org.apache.http.auth.Credentials;import org.apache.http.auth.UsernamePasswordCredentials;import org.apache.http.client.CredentialsProvider;import org.apache.http.impl.client.BasicCredentialsProvider;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.beans.factory.ObjectProvider;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.PropertyMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;class RestClientConfigurations &#123; RestClientConfigurations() &#123; &#125; @Configuration( proxyBeanMethods = false ) // RestClient 普通客户端 static class RestClientFallbackConfiguration &#123; RestClientFallbackConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder) &#123; return builder.build(); &#125; &#125; @Configuration( proxyBeanMethods = false ) @ConditionalOnClass(&#123;RestHighLevelClient.class&#125;) // RestHighLevelClient 高级客户端 static class RestHighLevelClientConfiguration &#123; RestHighLevelClientConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder restClientBuilder) &#123; return new RestHighLevelClient(restClientBuilder); &#125; @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder, ObjectProvider&lt;RestHighLevelClient&gt; restHighLevelClient) &#123; RestHighLevelClient client = (RestHighLevelClient)restHighLevelClient.getIfUnique(); return client != null ? client.getLowLevelClient() : builder.build(); &#125; &#125; @Configuration( proxyBeanMethods = false ) // RestClientBuilder static class RestClientBuilderConfiguration &#123; RestClientBuilderConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers) &#123; HttpHost[] hosts = (HttpHost[])properties.getUris().stream().map(HttpHost::create).toArray((x$0) -&gt; &#123; return new HttpHost[x$0]; &#125;); RestClientBuilder builder = RestClient.builder(hosts); PropertyMapper map = PropertyMapper.get(); map.from(properties::getUsername).whenHasText().to((username) -&gt; &#123; CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); Credentials credentials = new UsernamePasswordCredentials(properties.getUsername(), properties.getPassword()); credentialsProvider.setCredentials(AuthScope.ANY, credentials); builder.setHttpClientConfigCallback((httpClientBuilder) -&gt; &#123; return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider); &#125;); &#125;); builder.setRequestConfigCallback((requestConfigBuilder) -&gt; &#123; properties.getClass(); map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMillis).to(requestConfigBuilder::setConnectTimeout); properties.getClass(); map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis).to(requestConfigBuilder::setSocketTimeout); return requestConfigBuilder; &#125;); builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123; customizer.customize(builder); &#125;); return builder; &#125; &#125;&#125; 十、索引、文档 API 操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289package com.wangba;import com.alibaba.fastjson.JSON;import com.wangba.enity.User;import org.apache.lucene.search.TermQuery;import org.apache.lucene.util.QueryBuilder;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchRequestBuilder;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.action.support.master.AcknowledgedResponse;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.client.indices.CreateIndexResponse;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.common.unit.TimeValue;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.index.query.MatchAllQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.TermQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.FetchSourceContext;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.repository.query.Param;import org.w3c.dom.ls.LSOutput;import java.io.IOException;import java.util.ArrayList;import java.util.concurrent.TimeUnit;@SpringBootTestclass SpringbootEsApiApplicationTests &#123; @Autowired @Qualifier(&quot;restHighLevelClient&quot;) private RestHighLevelClient client; /** * @Description: 创建索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void createIndex() throws IOException &#123; // 1. 创建索引请求 CreateIndexRequest request = new CreateIndexRequest(&quot;test&quot;); // 2. 让客户端执行请求 indicesClient CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); &#125; /** * @Description: 查询索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void existIndex() throws IOException &#123; GetIndexRequest request = new GetIndexRequest(&quot;test&quot;); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * @Description: 删除索引 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void deleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(&quot;test&quot;); AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete); &#125; /** * @Description: 添加文档 PUT test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void addDocument() throws IOException &#123; // 创建对象 User user = new User(&quot;wangba&quot;, 25); // 创建请求 IndexRequest request = new IndexRequest(&quot;test&quot;); // 规则： ==&gt; PUT test/_doc/1 request.id(&quot;1&quot;); request.timeout(&quot;1s&quot;); // 将我们的数据放入请求中 JSON格式 request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求，返回结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); // 对应的状态就是 CREATED 等 &#125; /** * @Description: 文档是否存在 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void existDocument() throws IOException &#123; // GET test/_doc/1 GetRequest request = new GetRequest(&quot;test&quot;, &quot;1&quot;); // _source 不显示上下文 request.fetchSourceContext(new FetchSourceContext(false)); request.storedFields(&quot;_none_&quot;); boolean exists = client.exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * @Description: 查询文档数据 GET test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void getDocument() throws IOException &#123; GetRequest request = new GetRequest(&quot;test&quot;, &quot;1&quot;); GetResponse documentFields = client.get(request, RequestOptions.DEFAULT); System.out.println(documentFields.getSourceAsString()); System.out.println(documentFields); &#125; /** * @Description: 更新文档 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void updateDocument() throws IOException &#123; UpdateRequest request = new UpdateRequest(&quot;test&quot;, &quot;1&quot;); User user = new User(&quot;zhansan&quot;, 22); request.doc(JSON.toJSONString(user), XContentType.JSON); UpdateResponse update = client.update(request, RequestOptions.DEFAULT); System.out.println(update); System.out.println(update.status()); &#125; /** * @Description: 删除文档 DELETE test/_doc/1 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void deleteDocument() throws IOException &#123; DeleteRequest request = new DeleteRequest(&quot;test&quot;, &quot;1&quot;); DeleteResponse delete = client.delete(request, RequestOptions.DEFAULT); System.out.println(delete); &#125; /** * @Description: 批处理请求 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ @Test void addBulkDocument() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(&quot;10s&quot;); ArrayList&lt;User&gt; userArrayList = new ArrayList&lt;&gt;(); userArrayList.add(new User(&quot;zhangsan&quot;, 5)); userArrayList.add(new User(&quot;lisi&quot;, 10)); userArrayList.add(new User(&quot;xiaoxin&quot;, 25)); for (int i = 0; i &lt; userArrayList.size(); i++) &#123; bulkRequest.add( new IndexRequest(&quot;test&quot;) .id(&quot;&quot;+(i+1)) .source(JSON.toJSONString(userArrayList.get(i)), XContentType.JSON) ); &#125; BulkResponse bulk = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulk); System.out.println(bulk.status()); System.out.println(bulk.hasFailures()); &#125; /** * @Description: 按条件搜索 * @Param: [] * @return: void * @Author: wang ba * @Date: 2020/7/29 */ /* 查询： SearchRequest 搜索请求 SearchSourceBuilder 条件构造 HighlightBuilder 高亮构造 TermQueryBuilder 精确查询 MatchAllQueryBuilder 所有查询 // xxxBuilder */ @Test void searchDocument() throws IOException &#123; // 创建搜索请求 SearchRequest searchRequest = new SearchRequest(&quot;test&quot;); // 构造搜索条件 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); // QueryBuilders.termQuery 精确查询 // QueryBuilders.matchAllQuery 查询所有 //TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;age&quot;, &quot;25&quot;); //searchSourceBuilder.query(termQueryBuilder); MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); searchSourceBuilder.query(matchAllQueryBuilder); // 分页 // searchSourceBuilder.from(); // searchSourceBuilder.size(); searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(searchSourceBuilder); SearchResponse search = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(search.getHits())); System.out.println(&quot;+++++++++++++我是分割线++++++++++++++&quot;); for (SearchHit documentFields : search.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsMap()); &#125; &#125;&#125; 十一、实战","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://wangba.me/tags/java/"},{"name":"ES","slug":"ES","permalink":"http://wangba.me/tags/ES/"}]}],"categories":[{"name":"重学算法系列","slug":"重学算法系列","permalink":"http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"},{"name":"Spring Boot真的香系列","slug":"Spring-Boot真的香系列","permalink":"http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"},{"name":"WangBa's CookBook","slug":"WangBa-s-CookBook","permalink":"http://wangba.me/categories/WangBa-s-CookBook/"},{"name":"LeetCode真的难系列","slug":"LeetCode真的难系列","permalink":"http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://wangba.me/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://wangba.me/tags/Algorithm/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wangba.me/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://wangba.me/tags/Spring-Security/"},{"name":"Session","slug":"Session","permalink":"http://wangba.me/tags/Session/"},{"name":"Java","slug":"Java","permalink":"http://wangba.me/tags/Java/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://wangba.me/tags/NoSQL/"},{"name":"CookBook","slug":"CookBook","permalink":"http://wangba.me/tags/CookBook/"},{"name":"Life","slug":"Life","permalink":"http://wangba.me/tags/Life/"},{"name":"MySQL","slug":"MySQL","permalink":"http://wangba.me/tags/MySQL/"},{"name":"SQL","slug":"SQL","permalink":"http://wangba.me/tags/SQL/"},{"name":"String","slug":"String","permalink":"http://wangba.me/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangba.me/tags/Sliding-Window/"},{"name":"Two pointer","slug":"Two-pointer","permalink":"http://wangba.me/tags/Two-pointer/"},{"name":"Array","slug":"Array","permalink":"http://wangba.me/tags/Array/"},{"name":"JSON","slug":"JSON","permalink":"http://wangba.me/tags/JSON/"},{"name":"注解","slug":"注解","permalink":"http://wangba.me/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"java","slug":"java","permalink":"http://wangba.me/tags/java/"},{"name":"ES","slug":"ES","permalink":"http://wangba.me/tags/ES/"}]}