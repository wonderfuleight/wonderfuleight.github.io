<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangba&#39;s blogs</title>
  
  
  <link href="http://wangba.me/atom.xml" rel="self"/>
  
  <link href="http://wangba.me/"/>
  <updated>2020-11-23T13:05:11.287Z</updated>
  <id>http://wangba.me/</id>
  
  <author>
    <name>wangba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stack--Monotonic Stack</title>
    <link href="http://wangba.me/2020/11/23/Stack-Monotonic-Stack/"/>
    <id>http://wangba.me/2020/11/23/Stack-Monotonic-Stack/</id>
    <published>2020-11-23T13:03:24.000Z</published>
    <updated>2020-11-23T13:05:11.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>在前面已经提及过 <a href="http://wangba.me/2020/10/27/Stack/">栈</a> 这个数据结构，在 LeetCode 中有考察过这样一种栈操作：单调栈。</p><p>顾名思义，这是在栈的基础上达到单调递增或单调递减的效果。</p><p>大概的过程如下：</p><ul><li><p>如果想达到递增的效果：</p><ul><li>进栈：首先要比较与栈顶的大小，如果比栈顶元素大，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较</li><li>出栈：直接出栈即可</li></ul></li><li><p>如果想达到递减的效果：</p><ul><li>进栈：首先要比较与栈顶的大小，如果比栈顶元素小，那么直接放在栈顶即可；否则要将栈顶元素出栈，然后将这个元素与栈顶元素进行比较</li><li>出栈：直接出栈即可</li></ul></li></ul><h2 id="二、Example"><a href="#二、Example" class="headerlink" title="二、Example"></a>二、Example</h2><p>假如有下面的例子：</p><p>有一组数为：</p><blockquote><p>1，4，2，5，7，6，8</p></blockquote><p>现在要得到一个单调递增栈，过程如下：</p><table><thead><tr><th>Step</th><th>Op</th><th>Stack</th></tr></thead><tbody><tr><td>1</td><td>1  push</td><td>1</td></tr><tr><td>2</td><td>4  push</td><td>1  4</td></tr><tr><td>3</td><td>4 pop  |  2  push</td><td>1  2</td></tr><tr><td>4</td><td>5  push</td><td>1  2  5</td></tr><tr><td>5</td><td>7 push</td><td>1  2  5  7</td></tr><tr><td>6</td><td>7  pop  |  6  push</td><td>1  2  5  6</td></tr><tr><td>7</td><td>8  push</td><td>1  2  5  6  8</td></tr></tbody></table><h2 id="三、LeetCode-496"><a href="#三、LeetCode-496" class="headerlink" title="三、LeetCode 496"></a>三、LeetCode 496</h2><p>看一个典型例子 <a href="https://leetcode-cn.com/problems/next-greater-element-i/">LeetCode 0496</a> :</p><p>题意：给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br></pre></td></tr></table></figure><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; i) &#123;</span><br><span class="line">            map.put(stack.peek(), i);</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        res[i] = map.get(nums1[i]) != <span class="keyword">null</span> ? map.get(nums1[i]) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="重学算法系列" scheme="http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Algorithm" scheme="http://wangba.me/tags/Algorithm/"/>
    
    <category term="Stack" scheme="http://wangba.me/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>0084. Largest Rectangle in Histogram</title>
    <link href="http://wangba.me/2020/11/02/0084-Largest-Rectangle-in-Histogram/"/>
    <id>http://wangba.me/2020/11/02/0084-Largest-Rectangle-in-Histogram/</id>
    <published>2020-11-02T11:46:08.000Z</published>
    <updated>2020-11-05T13:41:39.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="84-Largest-Rectangle-in-Histogram-Hard"><a href="#84-Largest-Rectangle-in-Histogram-Hard" class="headerlink" title="84. Largest Rectangle in Histogram Hard"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力破解"><a href="#思路一：暴力破解" class="headerlink" title="思路一：暴力破解"></a>思路一：暴力破解</h3><ul><li>先用 HashSet 存储数组中不重复的值，主要是用来加速的，不用也可以，像在本题里面就可以少算一次 <code>2</code></li><li>然后遍历这个 set，再在 set 中进行数组遍历，找到连续比当前值大于或等于的数组值，并找到最大的宽度，像在上面的🌰中，当值为 <code>1</code> 时，遍历一遍后，最大的的宽度为 <code>6</code> </li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> height : heights) &#123;</span><br><span class="line">        set.add(height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> height : set) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : heights) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= height) &#123;</span><br><span class="line">                width++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, width);</span><br><span class="line">                width = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, width);</span><br><span class="line">        res = Math.max(res, max * (height));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>这个思路有点和 <a href="http://wangba.me/2020/10/28/0042-Trapping-Rain-Water/">42题</a> 有点像，可以看下面的🌰：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201104211959.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201104211959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201104211954756"></p><ul><li>在思路一中，是将每一个不重复的数组元素和整个数组进行对比，求出最大面积</li><li>在 该解法中，仍然是求每个柱子所占的最大面积，最后取最大的即可</li><li>红色是当前柱子，分别找到离该柱子左边最近比该柱子低的柱子 <code>leftMin </code> 和右边最近低于该柱子的柱子    <code>rightMin</code> </li><li>此时的面积可以计算为：<code>heights[cur] * ( rightMin - leftMin -1)</code></li></ul><p>那么如何求出每一个柱子的 <code>leftMin </code> ，下面的代码是时间复杂度为 O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[i] &lt;= heights[temp]) &#123;</span><br><span class="line">        temp--;</span><br><span class="line">    &#125;</span><br><span class="line">    leftMin[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上面的代码是可以降低时间复杂度的，可以看下面这个🌰：</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105213556.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105213556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201105202816731" style="zoom:200%;" /><ul><li>如果我们要求 <code>cur</code> 的 <code>leftMin</code> ，可以放弃一部分比较，具体是哪一部分呢？</li><li>如果当前 <code>cur</code> 高度小于 <code>cur - 1</code> ，那么 <code>leftMin[i - 1] + 1</code> 到 <code>cur - 1</code> 之间所有柱子的高度都是大于 <code>cur</code> 的，因为 <code>leftMin[i - 1]</code> 是第一个比 <code>cur - 1</code> 低的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">        temp = leftMin[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    leftMin[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">    leftMin[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">            temp = leftMin[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        leftMin[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] rightMin = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">    rightMin[heights.length - <span class="number">1</span>] = heights.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt;= heights.length -<span class="number">1</span> &amp;&amp; heights[temp] &gt;= heights[i]) &#123;</span><br><span class="line">            temp = rightMin[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        rightMin[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (rightMin[i] - leftMin[i] - <span class="number">1</span>) * heights[i];</span><br><span class="line">        max = Math.max(max, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三：栈"><a href="#思路三：栈" class="headerlink" title="思路三：栈"></a>思路三：栈</h3><ul><li>当遍历到 <code>cur</code> 时，出现 <code>height[cur] &lt; height[peek]</code> 时，那么 <code>leftMin</code> 一定是 <code>newPeek</code> ，<code>rightMin</code> 就是 <code>cur</code> ，此时面积最大值就是 <code>(cur - leftMin - 1) * height[peek]</code></li></ul><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105212529.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201105212529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201105212528335"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; heights.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> peek = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt;= heights[peek]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">                <span class="keyword">int</span> leftMin = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="keyword">int</span> area = (i - leftMin - <span class="number">1</span>) * height;</span><br><span class="line">                max = Math.max(area, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.pop()];</span><br><span class="line">        <span class="keyword">int</span> leftMin = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        <span class="keyword">int</span> area = (heights.length - leftMin - <span class="number">1</span>) * height;</span><br><span class="line">        max = Math.max(area, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://wangba.me/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>0071. Simplify Path</title>
    <link href="http://wangba.me/2020/10/30/0071-Simplify-Path/"/>
    <id>http://wangba.me/2020/10/30/0071-Simplify-Path/</id>
    <published>2020-10-30T12:51:58.000Z</published>
    <updated>2020-10-30T12:54:07.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="71-Simplify-Path-Medium"><a href="#71-Simplify-Path-Medium" class="headerlink" title="71. Simplify Path Medium"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. Simplify Path</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p><p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level.</p><p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 6:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">Output: &quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：栈"><a href="#思路一：栈" class="headerlink" title="思路一：栈"></a>思路一：栈</h3><p>这两个思路是一样的，只是分别使用数组和栈而已</p><ul><li>首先从 <code>/</code> 分开，然后用栈保存，如果栈不为空，且当前字符为 <code>..</code> 说明要进行进入上层目录，此时将栈中的元素弹出</li><li>只要不为空、不为 <code>.</code> 、不为 <code>..</code> ，就把其中的元素放入栈中即可</li><li>最后在最前面和每个字符串中间加上 <code>/</code></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Stack</span></span><br><span class="line">    String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; <span class="string">&quot;..&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">&quot;.&quot;</span>.equals(s) &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(s) &amp;&amp; !<span class="string">&quot;..&quot;</span>.equals(s)) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(stack);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + String.join(<span class="string">&quot;/&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：纯数组"><a href="#思路二：纯数组" class="headerlink" title="思路二：纯数组"></a>思路二：纯数组</h3><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] split = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    List&lt;String&gt; wordList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || s.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; wordListSim = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wordListSim.isEmpty()) &#123;</span><br><span class="line">                wordListSim.remove(wordListSim.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wordListSim.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + String.join(<span class="string">&quot;/&quot;</span>, wordListSim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://wangba.me/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>something need to learn or write</title>
    <link href="http://wangba.me/2020/10/29/something-need-to-learn-or-write/"/>
    <id>http://wangba.me/2020/10/29/something-need-to-learn-or-write/</id>
    <published>2020-10-29T12:52:01.000Z</published>
    <updated>2020-10-29T12:57:05.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><input disabled="" type="checkbox"> 实体类使用 java.x 的 valiation 和 hibernate 的 validator 进行校验</li><li><input disabled="" type="checkbox"> Spring Data JPA 的更深入使用</li><li><input disabled="" type="checkbox"> Shiro 或者 Spring Security 整合 JWT</li><li><input disabled="" type="checkbox"> mapstruct 和 beansUtils 的类自动赋值</li><li><input disabled="" type="checkbox"> Java 8-13 中的一些新特性</li><li><input disabled="" type="checkbox"> 前后端分离中的异常处理</li></ul><hr><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li><input disabled="" type="checkbox"> 哈佛的 CS 50 课程</li><li><input disabled="" type="checkbox"> 从零搭建一个 Hexo 主题</li></ul><hr><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><input checked="" disabled="" type="checkbox"> <a href="http://141.164.52.228/tags/Array/">数组</a></li><li><input checked="" disabled="" type="checkbox"> <a href="http://141.164.52.228/tags/LinkedList/">链表</a></li><li><input disabled="" type="checkbox"> 栈</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Life" scheme="http://wangba.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>0042. Trapping Rain Water</title>
    <link href="http://wangba.me/2020/10/28/0042-Trapping-Rain-Water/"/>
    <id>http://wangba.me/2020/10/28/0042-Trapping-Rain-Water/</id>
    <published>2020-10-28T13:42:11.000Z</published>
    <updated>2020-10-30T12:52:56.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="42-Trapping-Rain-Water-Hard"><a href="#42-Trapping-Rain-Water-Hard" class="headerlink" title="42. Trapping Rain Water Hard"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. Trapping Rain Water</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：行求解"><a href="#思路一：行求解" class="headerlink" title="思路一：行求解"></a>思路一：行求解</h3><p>每次求一行的所有水：</p><ul><li>首先要标记是否开始，只要第一次出现 height[i] &gt;= 当前层次的值时，才开始计数，因为它左边没有墙</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find the maximum num in the height</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : height) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &amp;&amp; value &lt; i) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value &gt;= i) &#123;</span><br><span class="line">                res += count;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n * m)        其中 n 为数组长度，m 为数组中最大的值</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：列求解"><a href="#思路二：列求解" class="headerlink" title="思路二：列求解"></a>思路二：列求解</h3><ul><li>只要关注于每一列就行，且关注该列的左边最高列和右边最高列</li><li>如何求解该列的水，只需要将这左右高列中较低的那个减去当前的列的高度即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. column</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minColumn = getMinColumn(i, height);</span><br><span class="line">        <span class="keyword">if</span> (minColumn &gt; height[i]) &#123;</span><br><span class="line">            count += (minColumn - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinColumn</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; left) left = height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; right) right = height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)    </p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路三：栈"><a href="#思路三：栈" class="headerlink" title="思路三：栈"></a>思路三：栈</h3><p>可以想象为括号匹配：其中墙可以看作<code>括号</code>，水可以看作括号匹配的中间计算</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3. Stack</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; height.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[cur] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = height[stack.peek()];</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> len = cur - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(height[cur], height[stack.peek()]);</span><br><span class="line">            res += (min - temp) * len;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路四：动态规划"><a href="#思路四：动态规划" class="headerlink" title="思路四：动态规划"></a>思路四：动态规划</h3><p>在思路二中，是使用没次找一个数，都要遍历整个数组找到左边和右边的最高列，然后进行计算，在这个基础上，使用一个 dp 数组将这些值维护起来：</p><p>第 i 列的左边最高列和右边最高列应该为：</p><p><code>left[i] = max(left[i - 1], height[i - 1])</code></p><p><code>right[i] = max(right[i + 1], height[i + 1])</code></p><p>这样用两个数组去维护就行了，每次遍历的时候直接在这个 dp 数组中取就行了</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use array to save the maximum left num of every item</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        left[i] = Math.max(left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use array to save the maximum right num of every item</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right[i] = Math.max(right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minColumn = Math.min(left[i], right[i]);</span><br><span class="line">        <span class="keyword">if</span> (minColumn &gt; height[i]) &#123;</span><br><span class="line">            res += minColumn - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n）    </p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路五：动态规划-双指针"><a href="#思路五：动态规划-双指针" class="headerlink" title="思路五：动态规划 + 双指针"></a>思路五：动态规划 + 双指针</h3><p>在思路四中，已经使用 dp 数组去存储左边和右边的最高列，但是仔细思考一下，这个 dp 数组中的值，其实就使用一次，那么可以将这个空间复杂度再降低一点，有点类似于用动态规划求解斐波那契数列</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = Math.min(height[l], height[r]);</span><br><span class="line">        <span class="keyword">if</span> (height[l] == mn) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt; mn) &#123;</span><br><span class="line">                res += mn - height[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt; mn) &#123;</span><br><span class="line">                res += mn - height[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n）    </p><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://wangba.me/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>0020. Valid Parentheses</title>
    <link href="http://wangba.me/2020/10/28/0020-Valid-Parentheses/"/>
    <id>http://wangba.me/2020/10/28/0020-Valid-Parentheses/</id>
    <published>2020-10-28T13:41:57.000Z</published>
    <updated>2020-10-30T12:53:03.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses Easy"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. Valid Parentheses</a> <font color="#49b666" size=5>Easy</font></h2><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]&#123;&#125;&#39;</code>.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：栈"><a href="#思路一：栈" class="headerlink" title="思路一：栈"></a>思路一：栈</h3><p>在栈的那一节中，就提及到了栈的其中一个应用就是括号匹配，大致思路如下：</p><p>遇到 <code>(</code>、 <code>&#123;</code>、 <code>[</code> 这三种左括号，直接让它入栈，直到出现 <code>）</code>、 <code>&#125;</code>、 <code>]</code> ，首先判断栈是否为空或者栈顶的元素是否对应，如果对应，那么让它出栈，继续上述操作即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="string">&#x27;)&#x27;</span> &amp;&amp; temp != <span class="string">&#x27;]&#x27;</span> &amp;&amp; temp != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;)&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;(&#x27;</span> ||</span><br><span class="line">                temp == <span class="string">&#x27;]&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;[&#x27;</span> ||</span><br><span class="line">                temp == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><p>还看到了一种反向写法</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.isEmpty()) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123; stack.push(<span class="string">&#x27;)&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123; stack.push(<span class="string">&#x27;]&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>) &#123; stack.push(<span class="string">&#x27;&#125;&#x27;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != c)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://wangba.me/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://wangba.me/2020/10/27/Stack/"/>
    <id>http://wangba.me/2020/10/27/Stack/</id>
    <published>2020-10-27T14:01:27.000Z</published>
    <updated>2020-11-23T10:57:46.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027195704.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027195704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027195658275"></p><p>快速预览：</p><ul><li>🐷：第一小节看一下栈的特性，为什么会有这种受限的数据结构的出现？</li><li>🐢：第二小节看一下要实现一个栈，最基本需要什么操作？</li><li>🐭：第三小节看一下栈的的应用，是不是这些应用驱动着栈的诞生</li><li>🐦：最后一个小节还是老套路，简单的看一下 Java 中关于栈的 API</li></ul><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>​        在前面已经介绍了数组和链表两种最基本的数据结构，可以说他俩就是整个数据结构与算法的基石。看一下栈的组成：</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027201132.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027201132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027201130766" style="zoom:67%;" /><p>那么它和其他线性表最大的区别在哪呢？毫无疑问：它只允许在<code>一端进行插入和删除</code></p><p>或者说成 <code>先进后出、后进先出</code></p><p>此时，小朋友，你是否有很多问号？为什么要有这种受限的数据结构，我用数组和链表不香吗？当然栈就是基于数组或链表实现的，但是在特定的需求下，栈就应用而生了。具体可以参考下面的栈的应用和 Java 中栈，就可以看到在某些情况下栈的优势、以及由于数组和链表暴露出太多的接口，而栈只需要其中的一小部分就可以了</p><h2 id="三、实现栈"><a href="#三、实现栈" class="headerlink" title="三、实现栈"></a>三、实现栈</h2><p>我们在上面就提到了，栈既可以基于数组实现，也可以基于链表实现。栈最重要的两个操作：<code>入栈</code> 和 <code>出栈</code> </p><h3 id="3-1-定容栈"><a href="#3-1-定容栈" class="headerlink" title="3.1 定容栈"></a>3.1 定容栈</h3><p>这是《算法》中文版中的译名，顾名思义就是容量固定的栈，基于数组并用 Java 代码来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedCapacityStackOfString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedCapacityStackOfString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[count] = item;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String item = items[count - <span class="number">1</span>];</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(1)</p><p>空间复杂度：O(1)   不包含该栈本身，操作时的空间复杂度</p></blockquote><h3 id="3-2-扩容栈"><a href="#3-2-扩容栈" class="headerlink" title="3.2 扩容栈"></a>3.2 扩容栈</h3><p>在上面的定容栈中，是用一个固定大小的数组当成实现栈的结构，那么应该如何实现一个扩容栈呢？</p><p>其实也很好实现，回忆一下动态数组的事项，是将数组进行扩容，然后将原来的数据 copy 进去就行了；那么用同样的方式对基于数组的栈进行扩容 (当然基于链表实现的栈就没有这一概念，理论上只要内存空间足够大，栈可以无限大)</p><ul><li>当栈满的时候，进行扩容：新建一个比现在大的数组</li><li>将原来栈中的数据全部复制到新的数组中</li></ul><p>具体实现可以参考下面的第五小节</p><h2 id="四、栈的应用"><a href="#四、栈的应用" class="headerlink" title="四、栈的应用"></a>四、栈的应用</h2><h3 id="4-1-撤销操作"><a href="#4-1-撤销操作" class="headerlink" title="4.1 撤销操作"></a>4.1 撤销操作</h3><p>​        如果你经常使用 command + Z 或者 ctrl + Z，你可能会非常理解这个操作：当我们复制或者修改了一个文件，我们想把它恢复成复制或修改之前的一样的状态，只需要按上面的快捷键就行了，仔细想一下是否有栈的影子在里面</p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027215546.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201027215546.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201027215543027" style="zoom:80%;" /><p>就如同上面这个例子：我们写到了 wangba，随后又不想要 wangba 了，此时进行撤销操作，只需要将栈中的 wangba pop 就可以了，有的还有前进功能，此时只需要将其 push 进来即可</p><h3 id="4-2-函数调用"><a href="#4-2-函数调用" class="headerlink" title="4.2 函数调用"></a>4.2 函数调用</h3><p>​        如果了解过操作系统或者听说过函数调用，那么可以更容易理解下面的内容，在计算机中，操作系统会给每个线程分配一个内存空间，而这个内存空间就是栈式结构，专门为函数调用存储临时变量，就例如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> res = add(a, b);</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段 Java 代码中，可以看见在 main 中调用了 add 函数，在栈帧中应该就是这样：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123155657.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123155657.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123155657021"></p><blockquote><p>当然，真实情况不是这样的，要是这么简单，计算机底层就不会这么劝退了 ～～～</p><p>如果有兴趣了解更深可以参考：《深入理解计算机系统》或者想大概了解一下可以参考 <a href="https://blog.csdn.net/wangyezi19930928/article/details/16921927">这个</a></p></blockquote><h3 id="4-3-表达式求值"><a href="#4-3-表达式求值" class="headerlink" title="4.3 表达式求值"></a>4.3 表达式求值</h3><p>🐢：在编译器中是如何对表达式进行求值的呢？如果是后缀表达式就只需要一个操作栈即可；如果是前缀或中缀表达式则需要一个操作数栈和一个操作符栈，来看一下中缀表达式的求值过程：</p><p><code>a * (b + c)</code></p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123165540.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123165540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123165539976"></p><p>过程大概如下：</p><ul><li>遇到操作数就压到操作数的栈；遇到操作符就压到操作符的栈</li><li>在压到操作符的栈是有条件的：如果操作符<code>栈顶的符号</code>的优先级大于等于要<code>压入的符号</code>，那就取操作数栈顶的两个数进行计算；如果小于则直接把操作符压入操作符的栈</li></ul><h3 id="4-4-括号匹配"><a href="#4-4-括号匹配" class="headerlink" title="4.4 括号匹配"></a>4.4 括号匹配</h3><p>关于括号匹配可以参考 <a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 0020</a>，关于这题的解答可以看 <a href="http://wangba.me/2020/10/28/0020-Valid-Parentheses/">0020. Valid Parentheses</a></p><h2 id="五、Java中的栈"><a href="#五、Java中的栈" class="headerlink" title="五、Java中的栈"></a>五、Java中的栈</h2><p>首先看一下继承与实现的关系：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170705.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170705.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123170704974"></p><p>再看一下该类中的 Structure :</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170836.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201123170836.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201123170835999"></p><p>可以看出来很简单，就如同上面在定容栈中的操作差不多，实际上差的很多，要考虑到扩容、并发等等情况，操作大都是在他的父类 Vertor 中完成，如果你看过面经啥的，你应该就听过并发不要使用 Vertor，要多使用 JUC 包下面的类，然后究其原因就是：Vertor 使用 <code>synchronized</code> 关键字，JUC 包下的是使用 <code>ReentrantLock</code>，而可重入锁的底层则是 AQS</p><p>LeetCode 重点关于栈的重点：<code>Monotonic Stack</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="重学算法系列" scheme="http://wangba.me/categories/%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Algorithm" scheme="http://wangba.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>148. SortList</title>
    <link href="http://wangba.me/2020/10/26/148-SortList/"/>
    <id>http://wangba.me/2020/10/26/148-SortList/</id>
    <published>2020-10-26T11:16:05.000Z</published>
    <updated>2020-10-26T11:17:39.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="148-Sort-List-Medium"><a href="#148-Sort-List-Medium" class="headerlink" title="148. Sort List Medium"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. Sort List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：递归法"><a href="#思路一：递归法" class="headerlink" title="思路一：递归法"></a>思路一：递归法</h3><ul><li>归并排序</li><li>找链表中点</li><li>哨兵</li></ul><p>本题是一个无序链表的排序问题，要求是空间复杂度为 <code>O(nlogn)</code> ，那只能想到快速排序、归并排序、堆排序，快排上通过索引的，不适合用在链表中；堆排序新建结点中；这题可采用归并排序，在 <a href="http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/">21题</a> 中介绍了合并两个有序列表，现在只是一个无序链表，没有条件创造条件：</p><ul><li>两个链表：找到链表中点，切断</li><li>有序：一个无序链表切开后，变成了两个无序链表，再对每一个链表进行递归，当只有一个结点，自然就是有序的了</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode slow = head, fast = head, pre = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(sortList(head), sortList(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) cur.next = l1;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(1)   其实并不是 1 ，由于递归要调用栈</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>147. Insertion Sort List</title>
    <link href="http://wangba.me/2020/10/23/147-Insertion-Sort-List/"/>
    <id>http://wangba.me/2020/10/23/147-Insertion-Sort-List/</id>
    <published>2020-10-23T13:28:07.000Z</published>
    <updated>2020-10-23T13:29:30.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="147-Insertion-Sort-List-Medium"><a href="#147-Insertion-Sort-List-Medium" class="headerlink" title="147. Insertion Sort List Medium"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. Insertion Sort List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Sort a linked list using insertion sort.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" class="lazyload" data-srcset="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"><br>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br>With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</p><p><strong>Algorithm of Insertion Sort:</strong></p><ol><li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li><li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li><li>It repeats until no input elements remain.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：插入排序"><a href="#思路一：插入排序" class="headerlink" title="思路一：插入排序"></a>思路一：插入排序</h3><p>按照插入排序的思想，要注意的点：</p><ul><li>不要断链</li><li>每一次都是从头开始进行比较</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode pre = res;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre.next;</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        pre = res;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>143. Reorder List</title>
    <link href="http://wangba.me/2020/10/22/143-Reorder-List/"/>
    <id>http://wangba.me/2020/10/22/143-Reorder-List/</id>
    <published>2020-10-22T13:26:16.000Z</published>
    <updated>2020-10-22T13:30:43.420Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="143-Reorder-List-Medium"><a href="#143-Reorder-List-Medium" class="headerlink" title="143. Reorder List Medium"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. Reorder List</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力解法"><a href="#思路一：暴力解法" class="headerlink" title="思路一：暴力解法"></a>思路一：暴力解法</h3><p>直接将链表存在数组中，然后进行操作，不用考虑断链等问题，直接用数组下标解决一切</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="comment">// 1. 暴力解法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        list.get(i).next = list.get(j);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.get(j).next = list.get(i);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    list.get(j).next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h3><p>看到递归还是要想到两个方面的问题：</p><ul><li>出口</li><li>调用递归函数的统一操作</li></ul><p>首先要明确递归传出来的是啥，为什么使用思路一的想法就是，我想找最后一个元素，但是每次都要遍历一遍才能找到那个元素，所以使用了数组，通过下标获取其中的元素。所以，我们应该递归出来的局部链表的尾元素，看下面的🌰：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022204518.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022204518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201022204517106"></p><p>现在递归到出口，那么我们应该将 <code>tail</code> 传出来</p><p>第二，本题的出口要分为两种情况：奇数个和偶数</p><p>奇数：直接传出来</p><p>偶数：将它的 <code>next</code> 传出来</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="comment">// 2. 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode count = head;</span><br><span class="line">    <span class="keyword">while</span> (count != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count = count.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(head, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">helper</span><span class="params">(ListNode listNode, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode tail = listNode.next;</span><br><span class="line">        listNode.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">        ListNode tail = listNode.next.next;</span><br><span class="line">        listNode.next.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode helper = helper(listNode.next, length - <span class="number">2</span>);</span><br><span class="line">    ListNode cur = listNode.next;</span><br><span class="line">    ListNode next = helper.next;</span><br><span class="line">    listNode.next = helper;</span><br><span class="line">    helper.next = cur;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三：分组解法"><a href="#思路三：分组解法" class="headerlink" title="思路三：分组解法"></a>思路三：分组解法</h3><p>还可以将这个题分为以下几个部分：</p><ul><li>找到中点，分割成两个链表</li><li>对后一个链表进行逆序</li><li>双指针同步进行，将后面链表与前面的链表进行连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br><span class="line"></span><br><span class="line">分割：1 -&gt; 2 -&gt; 3</span><br><span class="line">     4 -&gt; 5 -&gt; 6</span><br><span class="line">     </span><br><span class="line">逆序：6 -&gt; 5 -&gt; 4</span><br><span class="line">     </span><br><span class="line">连接：1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = reverseList(cur);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode l1 = head.next;</span><br><span class="line">        ListNode l2 = next.next;</span><br><span class="line">        head.next = next;</span><br><span class="line">        next.next = l1;</span><br><span class="line">        head = l1;</span><br><span class="line">        next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><blockquote><p>注：在 LeetCode 中，递归法时间复杂度可以 beats 100%，第三种方法不可以，按照分析来说，应该是一样的</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle II</title>
    <link href="http://wangba.me/2020/10/22/142-Linked-List-Cycle-II/"/>
    <id>http://wangba.me/2020/10/22/142-Linked-List-Cycle-II/</id>
    <published>2020-10-22T13:25:28.000Z</published>
    <updated>2020-10-22T13:29:22.519Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II Medium"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a> <font color="#fd9016" size=5>Medium</font></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p><p><strong>Follow up:</strong></p><p>Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>大体思路还是和 <a href="">141</a> 一样的，唯一的后续操作就是：让相遇点和开始点一起再向后走，这两个点再次相遇的点就是入口点，具体可以参考下面的图和数学证明：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022155330.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201022155330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201022155322951"></p><p><strong>数学证明</strong></p><p>条件：环的结点数 <code>N</code>、开始点到入口点距离 <code>X</code>、入口点到相遇点距离 <code>Y</code> (逆时针的距离，上图中长的那部分)</p><p>假设：<strong>slow</strong> 结点总共走了 <code>T</code> 步到相遇点；则 <strong>fast</strong> 结点共走了 <code>2T</code> 步</p><p>​              <strong>slow</strong> 结点总共走了 <code>K1</code> 圈； <strong>fast</strong> 结点共走了 <code>K2</code> 圈</p><p>则：</p><p><code>T = X + K1 * N + Y </code>                :one:</p><p><code>2T = X + K2 * N + Y</code>             :two:</p><p>化简：</p><p><code>T = (K2 - K1) * N</code></p><p>带到 :one: 中：</p><p><code>X = (K2 - 2K1 -1) * N + (N - Y)</code></p><p>其中：</p><p><code>(N - Y)</code> 表示相遇点到入口点的距离</p><p>这时候就可以说：我相遇点的结点向前走了 <code>(K2 - 2K1 -1)</code> 圈回到了相遇点，再走了 <code>(N - Y)</code> 到了入口点</p><p>简直就是 <code>Amazing</code> 啊！</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            temp = slow;</span><br><span class="line">            <span class="keyword">while</span> (head != temp) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O()</p><p>空间复杂度：O()</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0092. Reverse Linked List II</title>
    <link href="http://wangba.me/2020/10/21/0092-Reverse-Linked-List-II/"/>
    <id>http://wangba.me/2020/10/21/0092-Reverse-Linked-List-II/</id>
    <published>2020-10-21T12:14:42.000Z</published>
    <updated>2020-10-21T12:17:23.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="92-Reverse-Linked-List-II-Medium"><a href="#92-Reverse-Linked-List-II-Medium" class="headerlink" title="92. Reverse Linked List II Medium"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a> <font color="#fd9016" size=5>Medium</font></h2><p>难度中等551</p><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：利用反转链表"><a href="#思路一：利用反转链表" class="headerlink" title="思路一：利用反转链表"></a>思路一：利用反转链表</h3><p>在 <a href="http://wangba.me/2020/10/09/0206-Reverse-Linked-List/]">206</a> 中已经解决了反转整个链表，现在这种部分的反转链表，只需要将上面的断链，丢到反转整个链表的函数中，再恢复连接就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">断链：1 2-&gt;3-&gt;4 5-&gt;NULL</span><br><span class="line">调用函数：4-&gt;3-&gt;2</span><br><span class="line"></span><br><span class="line">恢复：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode listNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    listNode.next = head;</span><br><span class="line">    ListNode res = listNode;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">            next = listNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == m - <span class="number">1</span>) &#123;</span><br><span class="line">            pre = listNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            cur = listNode;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = cur.next;</span><br><span class="line">    cur.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = reverseList(pre.next);</span><br><span class="line">    pre.next = node;</span><br><span class="line">    next.next = temp;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写的有点复杂了……</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：头插法"><a href="#思路二：头插法" class="headerlink" title="思路二：头插法"></a>思路二：头插法</h3><p>还是要使用哨兵，避免重复操作，哨兵后面结点的操作：找到第一个要进行逆置结点的前一个结点，然后对后每个结点都进行<code>头插法</code>就行了</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = pre.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0086. Partition List</title>
    <link href="http://wangba.me/2020/10/20/0086-Partition-List/"/>
    <id>http://wangba.me/2020/10/20/0086-Partition-List/</id>
    <published>2020-10-20T13:35:39.000Z</published>
    <updated>2020-10-20T13:37:46.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List Medium"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. Partition List</a> Medium</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：大小链表"><a href="#思路一：大小链表" class="headerlink" title="思路一：大小链表"></a>思路一：大小链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原链表：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span><br><span class="line"></span><br><span class="line">大链表：4 -&gt; 3 -&gt; 5</span><br><span class="line">小链表：1 -&gt; 2 -&gt; 2</span><br><span class="line"></span><br><span class="line">合并链表：1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">//        Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">        <span class="comment">// 小链表</span></span><br><span class="line">        ListNode min = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode l  = min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大链表</span></span><br><span class="line">        ListNode max = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode h = max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                l.next = head;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next = head;</span><br><span class="line">                h = h.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = <span class="keyword">null</span>;</span><br><span class="line">        l.next = max.next;</span><br><span class="line">        <span class="keyword">return</span> min.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O()</p></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0083. Remove Duplicates from Sorted List</title>
    <link href="http://wangba.me/2020/10/19/0083-Remove-Duplicates-from-Sorted-List/"/>
    <id>http://wangba.me/2020/10/19/0083-Remove-Duplicates-from-Sorted-List/</id>
    <published>2020-10-19T13:28:17.000Z</published>
    <updated>2020-10-20T13:34:21.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List Easy"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a> <font color="#49b666" size=5>Easy</font></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：双指针"><a href="#思路一：双指针" class="headerlink" title="思路一：双指针"></a>思路一：双指针</h3><p>由于都是已经排好序的链表，相同的数都在一起，只要使用双指针：一个指向出现的第一个数，一个一直遍历到这个数结束即可</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.val == fast.val) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0025. Reverse Nodes in k-Group</title>
    <link href="http://wangba.me/2020/10/15/0025-Reverse-Nodes-in-k-Group/"/>
    <id>http://wangba.me/2020/10/15/0025-Reverse-Nodes-in-k-Group/</id>
    <published>2020-10-15T11:56:31.000Z</published>
    <updated>2020-10-15T12:01:22.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="25-Reverse-Nodes-in-k-Group-Hard"><a href="#25-Reverse-Nodes-in-k-Group-Hard" class="headerlink" title="25. Reverse Nodes in k-Group Hard"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. Reverse Nodes in k-Group</a> <font color="#e82f34" size=5>Hard</font></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes, in the end, should remain as it is.</p><p><strong>Follow up:</strong></p><ul><li>Could you solve the problem in <code>O(1)</code> extra memory space?</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">Output: [2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">Output: [3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：迭代"><a href="#思路一：迭代" class="headerlink" title="思路一：迭代"></a>思路一：迭代</h3><p>可以结合下面的图和代码进行查看：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201015194154.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201015194154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201015193552764"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ans.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode res = ans;</span><br><span class="line">    ListNode end = ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) end = end.next;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        ListNode start = res.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = <span class="keyword">null</span>;</span><br><span class="line">        res.next = reverseList(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        res = start;</span><br><span class="line"></span><br><span class="line">        end = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h3><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode point = head;</span><br><span class="line">    <span class="comment">//找到子链表的尾部</span></span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(i - <span class="number">1</span> &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        point = point.next;</span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode temp = point.next;</span><br><span class="line">    <span class="comment">//将子链表断开</span></span><br><span class="line">    point.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒置子链表，并接受新的头结点</span></span><br><span class="line">    ListNode new_head = reverseList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//head 其实是倒置链表的尾部，然后我们将后边的倒置结果接过来就可以了</span></span><br><span class="line">    <span class="comment">//temp 是链表断开后的头指针，可以参考解法一的图示</span></span><br><span class="line">    head.next = reverseKGroup(temp,k);</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> listNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>1002. Find Common Characters</title>
    <link href="http://wangba.me/2020/10/14/1002-Find-Common-Characters/"/>
    <id>http://wangba.me/2020/10/14/1002-Find-Common-Characters/</id>
    <published>2020-10-14T11:46:04.000Z</published>
    <updated>2020-10-14T11:51:39.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1002-Find-Common-Characters-Easy"><a href="#1002-Find-Common-Characters-Easy" class="headerlink" title="1002. Find Common Characters Easy"></a><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. Find Common Characters</a> <font color="#49b666" size=5>Easy</font></h4><p>Given an array <code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>. For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p><p>You may return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">Output: [&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length &lt;= 100</code></li><li><code>1 &lt;= A[i].length &lt;= 100</code></li><li><code>A[i][j]</code> is a lowercase letter</li></ol><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力破解"><a href="#思路一：暴力破解" class="headerlink" title="思路一：暴力破解"></a>思路一：暴力破解</h3><p>仅供参考：</p><ul><li>找到长度最小的字符串，由于是考虑每一个字符串中重复的元素</li><li>将这个字符串放到 map 中，map 中的值可以设为字符串数组长度</li><li>依次遍历，如果重复就 -1 ，最后看 map 中的值是否变为 0</li></ul><h3 id="思路二：哈希"><a href="#思路二：哈希" class="headerlink" title="思路二：哈希"></a>思路二：哈希</h3><p>可以结合下面的图和代码进行理解</p><ul><li>由于都是小写字母，只需要使用容量为 26 的数组表示 26 位字母；</li><li>第一个 26 位数组，将字符串数组的第一个字符串装下，重复的 + 1</li><li>后面和第一个一样操作得到新的数组，比较其中的值，取<code>最小 </code>的即可，因为最小的那个才代表着它在自己的数组中重复了多少次，在所有的字符串中，它最多的字符重复 </li><li>将结果放在第一个数组，继续比较</li></ul><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201014193842.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201014193842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201014193840865"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">        res[A[<span class="number">0</span>].charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].length(); j++) &#123;</span><br><span class="line">            temp[A[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            res[j] = Math.min(res[j], temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (res[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(String.valueOf((<span class="keyword">char</span>)((i) + <span class="string">&#x27;a&#x27;</span>)));</span><br><span class="line">            res[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0023. Merge k Sorted Lists</title>
    <link href="http://wangba.me/2020/10/14/0023-Merge-k-Sorted-Lists/"/>
    <id>http://wangba.me/2020/10/14/0023-Merge-k-Sorted-Lists/</id>
    <published>2020-10-14T06:39:51.000Z</published>
    <updated>2020-10-14T07:00:54.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists Hard"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a> <font color="#e82f34" size=5>Hard</font></h2><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> won’t exceed <code>10^4</code>.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：暴力解法"><a href="#思路一：暴力解法" class="headerlink" title="思路一：暴力解法"></a>思路一：暴力解法</h3><p>遍历链表数组中的每一个链表，在每一个链表中继续遍历，将所有的结果都存在数组中，再进行一次快速排序，最后再把数组中的每个结点组装成链表即可</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ListNode listNode : lists) &#123;</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(res);</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode ans = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : res) &#123;</span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">        head.next  = listNode;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogn)，n 为所有结点数</p><p>空间复杂度：O(n)</p></blockquote><h3 id="思路二：列比较"><a href="#思路二：列比较" class="headerlink" title="思路二：列比较"></a>思路二：列比较</h3><p>利用每个链表数组中的链表是有序的，则每次拿到最小的结点加入新的链表中，每个链表数组中的链表头的值一定是最小的</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 列比较</span></span><br><span class="line">    <span class="comment">// 最小索引</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isCompleted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 遍历一遍链表数组找到数值最小的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lists[i].val &lt; min) &#123;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                    min = lists[i].val;</span><br><span class="line">                &#125;</span><br><span class="line">                isCompleted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当所有的链表全部遍历完了，while 循环结束</span></span><br><span class="line">        <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span>;</span><br><span class="line">        head.next = lists[minIndex];</span><br><span class="line">        head = head.next;</span><br><span class="line">        lists[minIndex] = lists[minIndex].next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m * n)，m 为最长链表的长度；n 为链表数组长度</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路三：优先队列"><a href="#思路三：优先队列" class="headerlink" title="思路三：优先队列"></a>思路三：优先队列</h3><p>在上面的思路中，每次都是找到链表数组中最小的结点，再加入新链表中，在上面使用的直接遍历的方式，在这里可以采用优先队列的方式，优先队列是基于堆实现的，具体来说就是小/大根(顶)堆，只需要将每个链表的头结点放入，会自动进行大小比较，出队列是就是最小/最大</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列中默认就是小根堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(Comparator.comparing(n -&gt; n.val));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将每个结点的的头结点加入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            priorityQueue.add(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 出队列时就是最小值先出来的</span></span><br><span class="line">        head.next = priorityQueue.poll();</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="comment">// 将出队列的后面那个值加入优先队列</span></span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            priorityQueue.add(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(nlogk)，n 表示所有的结点书数，logk 表示每个结点的入队、出队</p><p>空间复杂度：O(k)，k 表示链表数组的长度；在 Java 中优先队列是有默认值的</p></blockquote><h3 id="思路四：两两合并"><a href="#思路四：两两合并" class="headerlink" title="思路四：两两合并"></a>思路四：两两合并</h3><p>在<a href="http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/">0021. Merge Two Sorted Lists</a>中，已经实现过两个有序链表的合并，本题也可以参考这个思路：首先将链表 0 和链表 1 合并，合并成新的链表 a，在和链表 2 进行合并 ……</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4. 两两合并</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        temp = mergeTwoLists(temp, lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路五：二分法两两合并"><a href="#思路五：二分法两两合并" class="headerlink" title="思路五：二分法两两合并"></a>思路五：二分法两两合并</h3><p>在上面思路五中，合并的思路是：先是合并第一个和第二个，合并为新的后，再和第三个进行合并，这样的效率有点低</p><p>这个思路也是可以优化的，使用二分法：</p><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span> , lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    ListNode l = merge(lists, left, mid);</span><br><span class="line">    ListNode r = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(l , r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>0021. Merge Two Sorted Lists</title>
    <link href="http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/"/>
    <id>http://wangba.me/2020/10/13/0021-Merge-Two-Sorted-Lists/</id>
    <published>2020-10-13T12:28:27.000Z</published>
    <updated>2020-10-14T07:00:19.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists Easy"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a> <font color="#49b666" size=5>Easy</font></h2><p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>l1</code> and <code>l2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="思路一：迭代法"><a href="#思路一：迭代法" class="headerlink" title="思路一：迭代法"></a>思路一：迭代法</h3><p>设置一个头结点，随后开始比较两个链表的结点值大小，具体逻辑可以将下面的图和代码逻辑联系起来：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013173857.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013173857.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013173854931"></p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="comment">// 1 2 4     1 3 4</span></span><br><span class="line">    <span class="comment">// 1 1 2 3 4 4</span></span><br><span class="line">    ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode res = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) temp.next = l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) temp.next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m + n)</p><p>空间复杂度：O(1)</p></blockquote><h3 id="思路二：递归法"><a href="#思路二：递归法" class="headerlink" title="思路二：递归法"></a>思路二：递归法</h3><p>递归最重要的两个点：</p><ul><li>递归的出口，在本题里面就是当其中的一个链表为空，直接返回另外一个链表即可</li><li>要进行递归，传入参数后的结果应该是已经确定的了，在这里就是链表已经排好序了</li></ul><p>举个例子：如果现在是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表la：1 -&gt; 3 -&gt; 5</span><br><span class="line"></span><br><span class="line">链表lb：2 -&gt; 4 -&gt; 6</span><br></pre></td></tr></table></figure><p>进行第一次递归时：要比较 1 和 2 的大小，发现 1 &lt; 2，此时只需要将 1.next =  <strong>mergeTwoLists(3, 2)</strong> 就行了，不要去想 <strong>mergeTwoLists(3, 2)</strong> 怎么来的，要把它当作已经确定的值就行，而 <strong>mergeTwoLists(3, 2)</strong> 的值可以看作是下面这两个链表的进行 <strong>mergeTwoLists</strong> 的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表la：3 -&gt; 5</span><br><span class="line"></span><br><span class="line">链表lb：2 -&gt; 4 -&gt; 6</span><br></pre></td></tr></table></figure><p> <strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="comment">// 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(m + n)</p><p>空间复杂度：O(m + n)</p><ul><li>由于递归是调用栈的，每递归一次需要一个栈帧</li></ul></blockquote>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://wangba.me/tags/Array/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Spring Security(七)</title>
    <link href="http://wangba.me/2020/10/13/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%83/"/>
    <id>http://wangba.me/2020/10/13/SpringBoot%E6%95%B4%E5%90%88Spring-Security-%E4%B8%83/</id>
    <published>2020-10-13T05:38:58.000Z</published>
    <updated>2020-10-13T05:40:08.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、OverView"><a href="#一、OverView" class="headerlink" title="一、OverView"></a>一、OverView</h2><p>​        这一小节整理一下前面几节的内容，主要完整的捋一遍 Spring Security 的登录过程。为了有一个 Architecture First  的印象，先将其中关键的类和接口列出，如果看到后面发现有印象，就可以跳到前面来看一下：</p><ul><li><p><strong>SecurityContextHolder</strong></p></li><li><p><strong>Authentication</strong></p></li><li><p>Token 类</p><ul><li><strong>UsernamePasswordAuthenticationToken</strong></li><li><strong>AbstractAuthenticationToken</strong></li></ul></li><li><p>Provider 和 Manger 类</p><ul><li><strong>AuthenticationManager</strong></li><li><strong>ProviderManager</strong></li><li><strong>AuthenticationProvider</strong></li><li><strong>DaoAuthenticationProvider</strong></li></ul></li><li><p><strong>UserDetails</strong> 与 <strong>UserDetailsService</strong></p></li></ul><p>主要可以参考一下这张图：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013133116.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013133116.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013133113040"></p><p>图源：<a href="https://lexburner.github.io/spring-security-1/">Spring Security(一)–Architecture Overview</a></p><h2 id="二、DeepLearning"><a href="#二、DeepLearning" class="headerlink" title="二、DeepLearning"></a>二、DeepLearning</h2><h3 id="2-1-Authentication"><a href="#2-1-Authentication" class="headerlink" title="2.1 Authentication"></a>2.1 Authentication</h3><p>先看一下 <strong>Authentication</strong> 的相关实现类</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013084521.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013084521.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013084517460"></p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>getAuthorities()：权限信息列表，默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串。</li><li>getCredentials()：密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li><li>getDetails()：细节信息，web 应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的 ip 地址和 sessionId 的值。</li><li>getPrincipal()：最重要的身份信息，大部分情况下返回的是 UserDetails 接口的实现类，也是框架中的常用接口之一。UserDetails 接口将会在下面的小节重点介绍。</li></ul></blockquote><p>在实现类中非常重要的就是 <strong>UsernamePasswordAuthenticationToken</strong> ，再看一下其中的属性和方法</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013090503.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013090503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013090502537"></p><p>以及它的父类：<strong>AbstractAuthenticationToken</strong> </p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013092222.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013092222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013092219226"></p><h3 id="2-2-UsernamePasswordAuthenticationFilter"><a href="#2-2-UsernamePasswordAuthenticationFilter" class="headerlink" title="2.2 UsernamePasswordAuthenticationFilter"></a>2.2 UsernamePasswordAuthenticationFilter</h3><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 UsernamePasswordAuthenticationFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String username = <span class="keyword">this</span>.obtainUsername(request);</span><br><span class="line">            String password = <span class="keyword">this</span>.obtainPassword(request);</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">                username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            username = username.trim();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainPassword</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.passwordParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainUsername</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.usernameParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：<strong>UsernamePasswordAuthenticationFilter</strong> 是继承 <strong>AbstractAuthenticationProcessingFilter</strong></p><blockquote><ul><li>通过 obtainUsername 和 obtainPassword 方法提取出请求里边的用户名/密码出来，提取方式就是 request.getParameter</li><li>获取到请求里传递来的用户名/密码之后，接下来就构造一个 UsernamePasswordAuthenticationToken 对象，传入 username 和 password，username 对应了 UsernamePasswordAuthenticationToken 中的 principal 属性，而 password 则对应了它的 credentials 属性</li><li>接下来 setDetails 方法给 details 属性赋值，UsernamePasswordAuthenticationToken 本身是没有 details 属性的，这个属性在它的父类 AbstractAuthenticationToken 中。details 是一个对象，这个对象里边放的是 WebAuthenticationDetails 实例，该实例主要描述了两个信息，请求的 remoteAddress 以及请求的 sessionId</li><li>最后调用 authenticate 方法去做校验了</li></ul></blockquote><p>仔细来细说一下上面代码中的最后一个方法中的校验：<strong>authenticate</strong> </p><p>校验操作首先要获取到一个 AuthenticationManager：</p><p><img src="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013100829.png" class="lazyload" data-srcset="https://gitee.com/wonderfuleight/blogImg/raw/master//20201013100829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013100826654"></p><p>这里拿到的是 ProviderManager ，所以接下来我们就进入到 ProviderManager 的 authenticate 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">   Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">   AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">   AuthenticationException parentException = <span class="keyword">null</span>;</span><br><span class="line">   Authentication result = <span class="keyword">null</span>;</span><br><span class="line">   Authentication parentResult = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span></span><br><span class="line">               + provider.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AccountStatusException | InternalAuthenticationServiceException e) &#123;</span><br><span class="line">         prepareException(e, authentication);</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">         lastException = e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         result = parentResult = parent.authenticate(authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">         lastException = parentException = e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">            &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">         ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parentResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">         eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先获取 authentication 的 Class，判断当前 provider 是否支持该 authentication</li><li>如果支持，则调用 provider 的 authenticate 方法开始做校验，校验完成后，会返回一个新的 Authentication</li><li>这里的 provider 可能有多个，如果 provider 的 authenticate 方法没能正常返回一个 Authentication，则调用 provider 的 parent 的 authenticate 方法继续校验</li><li>copyDetails 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来</li><li>接下来会调用 eraseCredentials 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 credentials 属性置空</li><li>最后通过 publishAuthenticationSuccess 方法将登录成功的事件广播出去</li></ul></blockquote><p>在具体说一下调用 provider 的 authenticate 方法的过程：</p><ul><li>在 for 循环中，第一次拿到的 provider 是一个 AnonymousAuthenticationProvider，这个 provider 压根就不支持 UsernamePasswordAuthenticationToken，也就是会直接在 provider.supports 方法中返回 false，结束 for 循环</li><li>然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。而 parent 就是 ProviderManager，所以会再次回到这个 authenticate 方法中。再次回到 authenticate 方法中，provider 也变成了 DaoAuthenticationProvider，这个 provider 是支持 UsernamePasswordAuthenticationToken 的</li><li>所以会顺利进入到该类的 authenticate 方法去执行，而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider 并且没有重写 authenticate 方法，所以 我们最终来到 AbstractUserDetailsAuthenticationProvider#authenticate 方法中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">   Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,</span><br><span class="line">         () -&gt; messages.getMessage(</span><br><span class="line">               <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Determine username</span></span><br><span class="line">   String username = (authentication.getPrincipal() == <span class="keyword">null</span>) ? <span class="string">&quot;NONE_PROVIDED&quot;</span></span><br><span class="line">         : authentication.getName();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">   UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         user = retrieveUser(username,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">                  <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> notFound;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Assert.notNull(user,</span><br><span class="line">            <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      preAuthenticationChecks.check(user);</span><br><span class="line">      additionalAuthenticationChecks(user,</span><br><span class="line">            (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">         cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">         user = retrieveUser(username,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">         preAuthenticationChecks.check(user);</span><br><span class="line">         additionalAuthenticationChecks(user,</span><br><span class="line">               (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> exception;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">      principalToReturn = user.getUsername();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先从 Authentication 提取出登录用户名</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等</li><li>additionalAuthenticationChecks 方法则是做密码比对的</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken</li></ul></blockquote><p>整体流程大概如下：</p><img src="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/Spring%20Security/core-service-Sequence.png" class="lazyload" data-srcset="http://dandandeshangni.oss-cn-beijing.aliyuncs.com/github/Spring%20Security/core-service-Sequence.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img1" style="zoom:200%;" /><p>图源：<a href="https://niocoder.com/2018/01/02/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80-Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/#%E6%A6%82%E8%BF%B0">Spring Security认证过程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Spring Boot真的香系列" scheme="http://wangba.me/categories/Spring-Boot%E7%9C%9F%E7%9A%84%E9%A6%99%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Spring Boot" scheme="http://wangba.me/tags/Spring-Boot/"/>
    
    <category term="Spring Security" scheme="http://wangba.me/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>0019.Remove Nth Node From End of List</title>
    <link href="http://wangba.me/2020/10/12/0019-Remove-Nth-Node-From-End-of-List/"/>
    <id>http://wangba.me/2020/10/12/0019-Remove-Nth-Node-From-End-of-List/</id>
    <published>2020-10-12T12:06:55.000Z</published>
    <updated>2020-10-12T12:10:23.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="19-删除链表的倒数第N个节点-Medium"><a href="#19-删除链表的倒数第N个节点-Medium" class="headerlink" title="19. 删除链表的倒数第N个节点 Medium"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a> <font color="#fd9016" size=5>Medium</font></h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先回忆一下如何删除一个结点，可以参考<a href="http://wangba.me/2020/10/03/LinkedList/">这个</a>，主要就是找到要删除前面的那个结点</p><h3 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a>思路一：暴力法</h3><p>直接两次遍历即可，第一遍找到这个链表的长度，第二遍只需要走链表长度减去这个**<em>n**</em>就行了</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode l = head;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        l = l.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sub = length - n;</span><br><span class="line">    <span class="keyword">if</span> (sub == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sub &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        l = l.next;</span><br><span class="line">        sub--;</span><br><span class="line">    &#125;</span><br><span class="line">    l.next = l.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然遍历了两次，但是时间复杂度还是 O(n)，线性长度</p><p>空间复杂度为 O(1)</p></blockquote><h3 id="思路二：相对位移法"><a href="#思路二：相对位移法" class="headerlink" title="思路二：相对位移法"></a>思路二：相对位移法</h3><p>这个思路也很简单，对比上面的思路好处是：只需要遍历一遍就行了</p><p>双指针，让 A 指针先走 <strong><em>n</em></strong>步，随后再让 B 指针和 A 指针一起走，这样就会有长度为 n 的相对位移，直到让 A 指针走到终点，此时 B 指针也就距终点 n 的长度了</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一天一道力扣题，嗤之以鼻，半信半疑，百感交集，关门大吉，skr skr ! ! !</summary>
    
    
    
    <category term="LeetCode真的难系列" scheme="http://wangba.me/categories/LeetCode%E7%9C%9F%E7%9A%84%E9%9A%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Leetcode" scheme="http://wangba.me/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://wangba.me/tags/Array/"/>
    
    <category term="LinkedList" scheme="http://wangba.me/tags/LinkedList/"/>
    
  </entry>
  
</feed>
